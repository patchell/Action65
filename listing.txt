
 ---------- Action.gram -------------
//----------------------------------
// ACTION! compiler for the 6502
// Version 0.0.1 Nov 27, 2024
//----------------------------------

TERMINALS
    "IDENT" = 256,
    "NUMBER",
    "STRING",
    "VECTOR",
    "MODULE",
    "RETURN",
    "PROC",
    "FUNC",
    "INTERRUPT",
    "INTERRUPT_IDENT",
    "PROC_IDENT",
    "FOR",
    "WHILE",
    "DO",
    "OD",
    "BEGIN",
    "END",
    "EXIT",
    "IF",
    "THEN",
    "ELSEIF",
    "ELSE",
    "FI",
    "IFF",
    "FFI",
    "UNTILL",
    "TO",
    "STEP",
    "OR",        // Logical OR operator
    "AND",        // Logical AND operator or cpu AND opcode
    "GTEQ",
    "LTEQ",
    "DEFINE",
    "TYPE",
    "RECORDTYPE",
    "BOOL",
    "CHAR",
    "BYTE",
    "CARD",
    "INT",
    "POINTER",
    "ARRAY",
    "PUSH",
    "POP",
    "BREAK",
    "BITS",
    "ACC",
    "XREG",
    "YREG",
    "ASM",
    //Assembler Tokens
    "SECTION",
    "START",
    "SIZE",
    "MODE",
    "ZEROPAGE",
    "READ_ONLY",
    "READ_WRITE",
    "true",
    "false",
    "ORG",
    "DB",
    "DW",
    "DL",
    "DAS",    //ACTION! STRING
    "DCS",    // 'C' STRING
    "DS",    // DEFINE STORAGE, BLOCK OF MEMORY
    "ASMPROC",
    "EPROC",
    "LOCAL_LABLE",
    "GLOBAL_LABLE",
    "GLOBAL_LABLE",
    "ADC",
//    "AND",        // see logical AND
    "ASL",
    "BCC",
    "BCS",
    "BEQ",
    "BMI",
    "BNE",
    "BPL",
    "BVC",
    "BVS",
    "BIT",
    "BRK",
    "CLC",
    "CLD",
    "CLI",
    "CLV",
    "CMP",
    "CPX",
    "CPY",
    "DEC",
    "DEX",
    "DEY",
    "EOR",
    "INC",
    "INX",
    "INY",
    "JMP",
    "JSR",
    "LDA",
    "LDX",
    "LDY",
    "LSR",
    "NOP",
    "ORA",
    "PHA",
    "PLA",
    "PHP",
    "PLP",
    "ROL",
    "ROR",
    "RTI",
    "RTS",
    "SBC",
    "STA",
    "SEC",
    "SED",
    "SEI",
    "STX",
    "STY",
    "TAX",
    "TAY",
    "TXA",
    "TYA",
    "TXS",
    "TSX",
    "X",
    "Y",
    "A",
    "SR",        // Status Register
    "@",        // address of operator
    ".",        // record field operator
    "^",        // pointer dereference
    "!",
    "XOR",
    "&",        // bitwise AND
    "%",        // bitwise OR
    "#",        // Not equals
    ">",        // greater than
    "<",        // less than
    "{",
    "}",
    "=",        // assignment or equal to
    "==+",
    "==-",
    "==*",
    "==/",
    "==MOD",
    "==&",
    "==!",
    "==XOR",
    "==%",
    "==LSH",
    "==RSH",
    "[",
    "]",
    ",",
    ";",
    "+",
    "-",
    "*",
    "/",
    "MOD",
    "LSH",
    "RSH",
    "(",
    ")",
    "NEG",        //cpu 'N'eg status register flage
    "CARRY",        // cpu 'C'arry status register flag
    "ZERO",        // cpu 'Z'ero status register flag
    "OVERFLOW"        // cpu 'O'verflow status register flag

GRAMMAR
//--------------------------------
// Program Structure
//--------------------------------
Action65    -> Modules;

Modules        -> Vector Modules_1;
Modules_1    -> 'MODULE' Vector Modules_1
            -> .
            ;

Vector            -> SysDecl Vector_1;
Vector_1        -> 'VECTOR' VectorAddress SysDecl Vector_1
                -> .
                ;
VectorAddress    -> '(' CompConst ')' VectorData;
VectorData        -> '=' CompConst;


//------------------------------------------
// Statements
//------------------------------------------


//---------------------------------------
// Proceedure/Function Call
//---------------------------------------
Statements        ->ForStmt ProcCall_1;
ProcCall_1        -> 'PROC_IDENT' ProcParams ForStmt ProcCall_1
                -> 'FUNC_IDENT' ProcParams ForStmt ProcCall_1
                -> .
                ;
ProcParams    -> '(' ValueList ')'
            -> .
            ;

//------------------------------------------------
// FOR statement
//------------------------------------------------
ForStmt            -> IfStmt ForStmt_1;
ForStmt_1        -> 'FOR' STEPoption DoStmt ForStmt_1
                -> .
                ;
STEPoption        -> ForTO STEPoption_1;
STEPoption_1    -> 'STEP' ArithExpr
                -> .
                ;
ForTO            -> Itterrator ForTO_1;
ForTO_1        -> 'TO' ArithExpr
                -> .
                ;
Itterrator        -> MemContentsType Itterrator_1;
Itterrator_1    -> '=' ArithExpr
                -> .
                ;

//------------------------------------------------
// IF statement
//------------------------------------------------
IfStmt            -> Iff IfStmt_1;
IfStmt_1        -> 'IF' EndIF Iff IfStmt_1
                -> .
                ;

EndIF        -> ElsePart EndIF_1;
EndIF_1        -> 'FI';

ElsePart    -> ElseIfPart ElsePart_1;
ElsePart_1    -> 'ELSE' Statements
            -> .
            ;

ElseIfPart        -> ThenPart ElseIfPart_1;
ElseIfPart_1    -> 'ELSEIF' ThenPart ElseIfPart_1
                -> .
                ;

ThenPart    -> RelOperation ThenPart_1;
ThenPart_1    -> 'THEN' Statements
            -> .
            ;

//-------------------------------------------------
// IFF Statement
//-------------------------------------------------

Iff        -> WhileStmt Iff_1;
Iff_1    -> 'IFF' IFFend WhileStmt Iff_1
        -> .
        ;

IFFend        -> IFFelse IFFend_1;
IFFend_1    -> 'FFI';

IFFelse        -> IFFthenpart IFFelse_1;
IFFelse_1    -> 'ELSE' Statements
            -> .
            ;
IFFthenpart        -> IffConditional IFFthenpart_1;
IFFthenpart_1    -> 'THEN' Statements
                -> .
                ;

IffConditional    -> Bits IffConditional_1;
IffConditional_1-> 'AREG' RelOper 
                -> 'XREG' RelOper 
                -> 'YREG' RelOper 
                -> .
                ;
RelOper            -> '<' Value
                -> 'GTEQ' Value
                -> '=' Value
                -> .
                ;

Bits            ->StatusFlags Bits_1;
Bits_1            -> 'BITS' BitValue
                -> .
                ;
BitValue        -> '[' ArithExpr ']';

StatusFlags        -> OptNot StatusFlags_1;
StatusFlags_1    -> 'NEG'        //negative flag
                -> 'CARRY'        //Carry flag
                -> 'ZERO'        //Zero
                -> 'OVERFLOW'        //Overflow
                ;

OptNot            -> '^'
                -> .
                ;


//-------------------------------------------------
// WHILE Statement
//-------------------------------------------------
WhileStmt        -> DoStmt WhileStmt_1;
WhileStmt_1        -> 'WHILE' RelOperation  DoStmt WhileStmt_1
                -> .
                ;

//------------------------------------------------
// DO Statement
//------------------------------------------------
DoStmt            -> EXITstmt DoStmt_1;
DoStmt_1        -> 'DO' DoEnd EXITstmt DoStmt_1
                -> .
                ;
DoEnd            -> Statements DoEnd_1;
DoEnd_1            -> 'OD'
                -> .
                ;

//---------------------------------------------------
// EXIT Statement
//---------------------------------------------------
EXITstmt        -> RetStmt EXITstmt_1;
EXITstmt_1        -> 'EXIT' RetStmt EXITstmt_1
                -> .
                ;
//-------------------------------------------------
// RETURN Statement
//-------------------------------------------------
RetStmt        -> InlineAssembly RetStmt_1;
RetStmt_1    -> 'RETURN' OptReturnValue  InlineAssembly RetStmt_1
                -> .
                ;
OptReturnValue    -> '(' ArithExpr ')'
                -> .
                ;
//---------------------------------------------
// Inline Assembly Code
//---------------------------------------------
InlineAssembly        -> CodeBlock InlineAssembly_1;
InlineAssembly_1    -> 'ASM' InlineAssBlock CodeBlock InlineAssembly_1
                    -> .
                    ;

InlineAssBlock        -> EndAsmBlock InlineAssBlock_1;
InlineAssBlock_1    -> '{' EndAsmBlock InlineAssBlock_1
                    -> .
                    ;
EndAsmBlock            -> AsmStmt EndAsmBlock_1;
EndAsmBlock_1        -> '}'
                    -> .
                    ;
//-----------------------------------------------
// CODE (Kluge) BLOCK statement
//-----------------------------------------------
CodeBlock        -> UntillStmt CodeBlock_1;
CodeBlock_1        -> '[' CodeBlockEnd UntillStmt CodeBlock_1
                -> .
                ;
CodeBlockEnd    -> ConstList CodeBlockEnd_1;
CodeBlockEnd_1    -> ']'
                -> .
                ;

//---------------------------------------------------
// UNTILE Statement
//---------------------------------------------------
UntillStmt        -> Push UntillStmt_1;
UntillStmt_1    -> 'UNTILL' RelOperation Push UntillStmt_1
                -> .
                ;
//---------------------------------------------------
// PUSH Statement
//---------------------------------------------------

Push        -> Pop Push_1;
Push_1        -> 'PUSH' PushSourceList Pop Push_1
            -> .
            ;
PushSourceList    -> PushSource PushSourceList_1;
PushSourceList_1-> ',' PushSource PushSourceList_1
                -> .
                ;
PushSource    -> ArithExpr PushSource_1;
PushSource_1-> 'AREG'
            -> 'XREG'
            -> 'YREG'
            -> 'SR'
            -> .
            ;
//---------------------------------------------------
// POP Statment
//---------------------------------------------------
Pop            -> Break Pop_1;
Pop_1        -> 'POP' PopDestList Break Pop_1
            -> .
            ;
PopDestList        -> PopDest PopDestList_1;
PopDestList_1    -> ',' PopDest PopDestList_1
                -> .
                ;
PopDest        -> MemContentsType PopDest_1;
PopDest_1    -> 'AREG'
            -> 'XREG'
            -> 'YREG'
            -> 'SR'
            -> .
            ;
//--------------------------------------------------
// BREAK Statement (Assembler BRK) Software Interrupt
//--------------------------------------------------
Break    -> Rti Break_1;
Break_1    -> 'BREAK' Rti Break_1
        -> .
        ;
//--------------------------------------------------
// RTI  Return from interrupt statement
//--------------------------------------------------
Rti        -> Assignment Rti_1;
Rti_1    -> 'RTI' Assignment Rti_1
        -> .
        ;
//---------------------------------------------------
// Assignment Statements
//---------------------------------------------------

Assignment    -> MemContentsType Assignment_1;
Assignment_1->  '=' ArithExpr Assignment_1
            -> '==+' ArithExpr  Assignment_1
            ->  '==-' ArithExpr  Assignment_1
            ->  '==*' ArithExpr  Assignment_1
            ->  '==/' ArithExpr Assignment_1
            ->  '==MOD' ArithExpr Assignment_1
            ->  '==&' ArithExpr    Assignment_1    // AND
            ->  '==!' ArithExpr Assignment_1    //XOR
            ->  '==%' ArithExpr Assignment_1    //OR
            ->  '==LSH' ArithExpr Assignment_1
            ->  '==RSH' ArithExpr Assignment_1
            -> .
            ;

//----------------------------------------------
// Relation Operations
//----------------------------------------------

RelOperation    -> LogicalOR RelOperation_1;
RelOperation_1    -> '>' LogicalOR RelOperation_1
                -> '<' LogicalOR RelOperation_1
                -> 'GTEQ' LogicalOR RelOperation_1
                -> 'LTEQ' LogicalOR RelOperation_1
                -> '=' LogicalOR RelOperation_1
                -> '#' LogicalOR RelOperation_1    //not equal
                -> .
                ;

LogicalOR    -> LogicalAND LogicalOR_1;
LogicalOR_1    -> 'OR' LogicalAND LogicalOR_1
            -> .
            ;

LogicalAND        -> ArithExpr LogicalAND_1;
LogicalAND_1    -> 'AND' ArithExpr LogicalAND_1
                -> .
                ;

//--------------------------------------
// Arithmetic Expressions
//--------------------------------------

ArithExpr    -> BitwiseAND BitwiseOR_1;
BitwiseOR_1    -> '%' BitwiseAND BitwiseOR_1
            -> .
            ;

BitwiseAND        -> BitwiseXOR BitwiseAND_1;
BitwiseAND_1    -> '&' BitwiseXOR BitwiseAND_1
                -> .
                ;

BitwiseXOR        -> AddExpr BitwiseXOR_1;
BitwiseXOR_1    -> '!' AddExpr BitwiseXOR_1
                -> 'XOR' AddExpr BitwiseXOR_1
                -> .
                ;

AddExpr    -> ShifExpr AddExpr_1;
AddExpr_1    -> '+' ShifExpr AddExpr_1
            -> '-' ShifExpr AddExpr_1
            -> .
            ;

ShifExpr    -> MultExpr ShiftExpr_1;
ShiftExpr_1    -> 'LSH' MultExpr ShiftExpr_1
            -> 'RSH' MultExpr ShiftExpr_1
            -> .
            ;

MultExpr    -> Unary MultExpr_1;
MultExpr_1    -> '*' Unary MultExpr_1
            -> '/' Unary MultExpr_1
            -> 'MOD' Unary MultExpr_1
            -> .
            ;

Unary    -> '-' Unary
        -> Factor
        ;

Factor        -> Value Factor_1;
Factor_1    -> '(' ArithExpr ')'
            -> .
            ;
         
//-------------------------------------------
// Declarations
//-------------------------------------------
// DEFINE declaration  Sort of a MACRO defination
//-------------------------------------------
SysDecl        -> TypeDefDecl Define;
Define    -> 'DEFINE' DefList TypeDefDecl Define
            -> .
            ;
DefList    -> Def DefList_1;
DefList_1    -> ',' Def DefList_1
            -> .
            ;
Def        -> IDENT '=' CompConst;

//----------------------------------------------
// TYPE Defination  Creates User define data
// object.
//----------------------------------------------
TypeDefDecl        -> FundDecl TypeDefDecl_1;
TypeDefDecl_1    -> 'TYPE' EndTypeDef FundDecl TypeDefDecl_1
                -> .
                ;
EndTypeDef        -> RecDefField EndTypeDef_1;
EndTypeDef_1    -> ']'
                -> .
                ;
RecDefField        -> Ident RecDefField_1;
RecDefField_1    -> '=' '[' LocalDecls
                -> '[' LocalDecls
                -> .
                ;


//--------------------------------------------
// Fundemental Declarations.  These are the
// base types that every thing is based on
//--------------------------------------------
FundDecl    ->FundPointerDecl FundDecl_1;
FundDecl_1    -> 'BOOL' FundPointerDecl FundDecl_1
            -> 'CHAR' FundPointerDecl FundDecl_1
            -> 'BYTE' FundPointerDecl FundDecl_1
            -> 'INT' FundPointerDecl FundDecl_1
            -> 'CARD' FundPointerDecl FundDecl_1
            -> 'RECORDTYPE' FundPointerDecl FundDecl_1
            -> .
            ;

FundPointerDecl        -> FundArrayDecl FundPointerDecl_1;
FundPointerDecl_1    -> 'POINTER' FundArrayDecl
                    -> .
                    ;

FundArrayDecl    -> FunctionDecl FundArrayDecl_1;
FundArrayDecl_1    -> 'ARRAY' FunctionDecl 
                -> .
                ;

FunctionDecl    -> IdentList FunctionDecl_1;;
FunctionDecl_1    -> 'FUNC' FuncDef
                -> 'PROC' ProcDef
                -> 'INTERRUPT' IrqDef
                -> .
                ;

IrqDef        -> IrqDecl IrqBody;
ProcDef        -> ProcDecl ProcBody;
FuncDef        -> FuncDecl FuncBody;

IrqDecl        -> 'IDENT' OptInit '(' ')';
ProcDecl    -> 'IDENT' OptInit '(' ParamList ')';
FuncDecl    -> 'IDENT' OptInit '(' ParamList ')';

OptInit        -> '=' CompConst
            -> .
            ;

IrqBody        -> LocalDecls Statements;
ProcBody    -> LocalDecls Statements;
FuncBody    -> LocalDecls Statements;

//----------------------------------
// Identifiers
//BYTE a,b;
//BYTE x=$a0
//BYTE y=[15]
//BYTE ARRAY a=$2000
//BYTE ARRAY b =["This is a string"]
//BYTE ARRAY c = [1 2 3 4 55 6]
//BYTE ARRAY d(156) =$2100
//----------------------------------
IdentList    -> Ident IdentList_1;
IdentList_1    -> ',' Ident IdentList_1
            -> .
            ;

Ident        -> IdentInit Ident_1;
Ident_1        -> 'IDENT' IdentInit
            -> .
            ;
IdentInit    -> ArrayDim IdentInit_1;
IdentInit_1    -> '=' Address
            -> .
            ;

Address        -> CompConst Address_1;
Address_1    -> '[' Data ']'
            -> .
            ;
Data        -> ConstList Data_1;
Data_1        -> 'STRING'
            -> .
            ;
ArrayDim    -> ArrayDim_1;
ArrayDim_1    -> '(' CompConst ')'
            -> .
            ;

//-------------------------------------------
// Parameter Declarations
//-------------------------------------------

ParamList    -> PramPointer Param_1;
Param_1        -> 'RECORDTYPE' PramPointer Param_1
            -> 'CHAR' PramPointer Param_1 
            -> 'BYTE' PramPointer Param_1 
            -> 'INT' PramPointer Param_1 
            -> 'CARD' PramPointer Param_1 
            -> 'BOOL' PramPointer Param_1 
            -> ',' Param_1
            -> .
            ;

PramPointer        -> ParamArray ParamPointer_1;
ParamPointer_1    -> 'POINTER'  ParamArray
                -> .
                ;
ParamArray        -> IdentList ParamArray_1;
ParamArray_1    -> 'ARRAY' IdentList
                -> .
                ;
                ;            
//-----------------------------------------------
// Local Variableas
//-----------------------------------------------

LocalDecls        -> LocalPointerDecl LocalDecls_1;
LocalDecls_1    -> 'CHAR' LocalPointerDecl  LocalDecls_1
                -> 'BYTE' LocalPointerDecl  LocalDecls_1
                -> 'INT' LocalPointerDecl  LocalDecls_1
                -> 'CARD' LocalPointerDecl  LocalDecls_1
                -> 'BOOL' LocalPointerDecl LocalDecls_1
                -> 'RECORDTYPE' LocalPointerDecl LocalDecls_1
                -> .
                ;

LocalPointerDecl    -> LocalArrayDecl LocalPointerDecl_1;
LocalPointerDecl_1    -> 'POINTER' LocalArrayDecl
                    -> .
                    ;

LocalArrayDecl        -> IdentList LocalArrayDecl_1;
LocalArrayDecl_1    -> 'ARRAY' IdentList
                    -> .
                    ;

//-------------------------------
// Compiler Constants
//-------------------------------
ConstList    -> CompConst ConstList_1;
ConstList_1    -> ',' CompConst ConstList_1
            -> .
            ;
CompConst        -> BaseCompConst CompConst_1;
CompConst_1        -> '+' BaseCompConst CompConst_1
                -> '-' BaseCompConst CompConst_1
                -> .
                ;
BaseCompConst    -> 'NUMBER'
                -> '*'
                -> '@' MemContentsType
                -> 'INTERUPT_IDENT'
                -> 'FUNC_IDENT'
                -> 'PROC_IDENT'
                -> .
                ;

//----------------------------------
//Variable References
//Memory References
//----------------------------------

ValueList    -> Value ValueList_1;
ValueList_1    -> ',' Value ValueList_1
                -> .
                ;

Value            -> MemContentsType Value_1;
Value_1            -> 'NUMBER'
                -> '*'        // current memroy location
                -> '@' AddressOf
                -> .
                ;

AddressOf        -> MemContentsType AddressOf_1;
AddressOf_1        ->'PROC_IDENT'
                -> 'FUNC_IDENT'
                -> 'INTERRUPT_IDENT'
                -> .
                ; 
MemContentsType        -> MemContents MemContentsType_1;
MemContentsType_1     -> '(' ArithExpr ')'    //array ref
                    -> '^'                    // Pointer Dereference
                    -> '.' MemContents MemContentsType_1        //record ref
                    -> .
                    ;

MemContents        -> 'IDENT'
                -> .
                ;



//----------------------------------------
//  Inline assembly code
//----------------------------------------

//----------------------------------------
//    Statements
//----------------------------------------

AsmStmt            -> DefineMemory Processor_1;
Processor_1        -> 'PROCESSOR' ProcessorType DefineMemory Processor_1
                -> .
                ;
ProcessorType    -> 'R6502'
                -> 'WD65C02'
                -> 'WD65C816'
                ;

//-----------------------------------------
// Code
//        These statements are what actually
// do something that concerns the machine
// code that is executed
//-----------------------------------------

//-----------------------------------------
// SECITON
//-----------------------------------------
Section        -> Org Section_1;
Section_1    -> 'SECTION' SectionName Org Section_1
                -> .
                ;
SectionName        -> SectionDef SectionName_1;
SectionName_1    -> 'IDENT' SectionDef
                -> .
                ;
            
SectionDef        -> '[' SectionAttributesList ']'
                -> .
                ;

SectionAttributesList    -> SectionAtribute SectionAttributesList_1;
SectionAttributesList_1    -> ',' SectionAtribute SectionAttributesList_1
                        -> .
                        ;

SectionAtribute    -> 'START' '=' AsmConstant
                -> 'SIZE' '=' AsmConstant
                -> 'MODE' '=' Modes
                -> 'ZEROPAGE' '=' TrueFalse
                -> .
                ;

Modes            -> 'READ_ONLY'
                -> 'READ_WRITE'
                ;

TrueFalse        -> 'true'
                -> 'false'
                ;

//-------------------------------------
// Org  Sets the location counter
// for the current section
//-------------------------------------
Org                -> DefineMemory Org_1;
Org_1            -> 'ORG' AsmConstant DefineMemory Org_1
                -> .
                ;

//-------------------------------------
// DefineMemeory
//-------------------------------------
                
DefineMemory    -> DefineStorage DefineMemory_1;
DefineMemory_1    -> 'DB' AsmConstList DefineStorage DefineMemory_1 
                -> 'DW' AsmConstList DefineStorage DefineMemory_1
                -> 'DL' AsmConstList DefineStorage DefineMemory_1
                -> 'DAS' 'STRING' DefineStorage DefineMemory_1
                -> 'DCS' 'STRING' DefineStorage DefineMemory_1
                -> .
                ;


//-------------------------------------
// DefineStorage
//-------------------------------------
DefineStorage    -> Proceedure DefineStorage_1;
DefineStorage_1    -> 'DS' AsmConstant Proceedure DefineStorage_1
                -> .
                ;

//-------------------------------------
// Proceedure
//-------------------------------------
Proceedure        -> Instruction Proceedure_1;
Proceedure_1    -> 'ASMPROC' Section 'EPROC' Instruction Proceedure_1
                -> .
                ;

//--------------------------------------
// Opcodes
//--------------------------------------
Instruction        -> Labels Instruction_1;    
Instruction_1    -> 'ADC'  AluAdrModes    Labels Instruction_1 //ALU Opcodes        
                -> 'AND'  AluAdrModes    Labels Instruction_1
                -> 'EOR'  AluAdrModes    Labels Instruction_1    
                -> 'ORA'  AluAdrModes    Labels Instruction_1    
                -> 'CMP'  AluAdrModes    Labels Instruction_1
                -> 'SBC'  AluAdrModes    Labels Instruction_1    
                -> 'LDA'  AluAdrModes    Labels Instruction_1    
                -> 'STA'  StaAddressingModes Labels Instruction_1    
                -> 'ASL' ShiftAddressingModes    Labels Instruction_1            //shift addressing modes
                -> 'ROL' ShiftAddressingModes    Labels Instruction_1    
                -> 'LSR' ShiftAddressingModes    Labels Instruction_1 
                -> 'ROR' ShiftAddressingModes    Labels Instruction_1     
                -> 'BCC' RelAddressingMode Labels Instruction_1                // Branch Op Codes
                -> 'BCS' RelAddressingMode Labels Instruction_1     
                -> 'BEQ' RelAddressingMode Labels Instruction_1
                -> 'BMI' RelAddressingMode Labels Instruction_1
                -> 'BNE' RelAddressingMode Labels Instruction_1
                -> 'BPL' RelAddressingMode Labels Instruction_1
                -> 'BVC' RelAddressingMode Labels Instruction_1
                -> 'BVS' RelAddressingMode Labels Instruction_1
                -> 'BIT' BitAddressModes    Labels Instruction_1            //BIT opcode
                -> 'BRK'    Labels Instruction_1                //Implied Addressing Mode 
                -> 'CLC'    Labels Instruction_1     
                -> 'CLD'    Labels Instruction_1    
                -> 'CLI'    Labels Instruction_1    
                -> 'CLV'    Labels Instruction_1    
                -> 'DEX'    Labels Instruction_1    
                -> 'DEY'    Labels Instruction_1    
                -> 'INX'    Labels Instruction_1    
                -> 'INY'    Labels Instruction_1    
                -> 'NOP'    Labels Instruction_1    
                -> 'PHA'    Labels Instruction_1    
                -> 'PLA'    Labels Instruction_1    
                -> 'PHP'    Labels Instruction_1    
                -> 'PLP'    Labels Instruction_1    
                -> 'RTI'    Labels Instruction_1    
                -> 'RTS'    Labels Instruction_1    
                -> 'SEC'    Labels Instruction_1    
                -> 'SED'    Labels Instruction_1    
                -> 'SEI'    Labels Instruction_1    
                -> 'TAX'    Labels Instruction_1    
                -> 'TAY'    Labels Instruction_1    
                -> 'TXA'    Labels Instruction_1    
                -> 'TYA'    Labels Instruction_1    
                -> 'TXS'    Labels Instruction_1    
                -> 'TSX'    Labels Instruction_1    
                -> 'INC' IncAddressingMOdes    Labels Instruction_1            //Inc/Dec Addressing Modes
                -> 'DEC' IncAddressingMOdes    Labels Instruction_1    
                -> 'JMP' JumpAddressingModes    Labels Instruction_1        // Jump
                -> 'JSR' CallAddressingMode    Labels Instruction_1            // Jump To Subroutine
                -> 'CPX'  CPX_CPY_AddressingMode    Labels Instruction_1    
                -> 'CPY'  CPX_CPY_AddressingMode        Labels Instruction_1
                -> 'LDX' LdxAddressingMode    Labels Instruction_1    
                -> 'LDY' LdyAddressingMode    Labels Instruction_1    
                -> 'STX' StxAddressingMode    Labels Instruction_1    
                -> 'STY' StyAddressingMode    Labels Instruction_1    
                -> .
                ;

//---------------------------------------------
// Lables
//---------------------------------------------
Labels    -> 'IDENT' Label_1    //Global
        -> .
        ;
Label_1    -> ':'        //private lable
        -> .
        ;

//-----------------------------------
//ALU Addressing Mode
//-----------------------------------

AluAdrModes        -> '#' AsmConstant
                -> '(' Indirect
                -> AsmConstant OptIndexReg
                ;
Indirect    -> AsmConstant  Indirect_1;
Indirect_1    -> ')' ',' 'YREG'
            -> ',' 'XREG' ')'
            ;

//---------------------------------------------
// STA addressing mode
//---------------------------------------------
StaAddressingModes    -> AsmConstant OptIndexReg
                    -> '(' Indirect
                    ;

//-----------------------------------------
// ASL LSR ROR and ROL addressing modes
//-----------------------------------------

ShiftAddressingModes    -> 'AREG'
                        -> AsmConstant OptXReg
                        ;

//------------------------------------------
// Branch Instructions Addressing Mode
//------------------------------------------
RelAddressingMode    -> AsmConstant;

//------------------------------------------
// BIT Instructions Addressing Mode
//------------------------------------------

BitAddressModes    -> AsmConstant;

//------------------------------------------
// INC DEC Instructions Addressing Mode
//------------------------------------------

IncAddressingMOdes    -> AsmConstant OptXReg;

//------------------------------------------
// JMP Instructions Addressing Mode
//------------------------------------------

JumpAddressingModes    -> JumpDirect JumpIndirect;
JumpIndirect        -> '(' AsmConstant ')'
                    -> .
                    ;
JumpDirect            -> AsmConstant;
//------------------------------------------
// JSR Instructions Addressing Mode
//------------------------------------------

CallAddressingMode    -> AsmConstant;

//------------------------------------------
// LDX Instructions Addressing Mode
//------------------------------------------

LdxAddressingMode    -> '#' AsmConstant
                    -> AsmConstant OptYReg
                    ;
//------------------------------------------
// CPX & CPY Instructions Addressing Mode
//------------------------------------------

CPX_CPY_AddressingMode    -> '#' AsmConstant
                        -> AsmConstant
                        ;

//------------------------------------------
// STX Instructions Addressing Mode
//------------------------------------------

StxAddressingMode    -> AsmConstant OptYReg;

//------------------------------------------
// LDY Instructions Addressing Mode
//------------------------------------------

LdyAddressingMode    -> '#' AsmConstant
                    -> AsmConstant OptXReg
                    ;

//------------------------------------------
// STY Instructions Addressing Mode
//------------------------------------------

StyAddressingMode    -> AsmConstant OptXReg;

//---------------------------------------------
//    Optional Index Registers
//---------------------------------------------

OptIndexReg        -> ',' OptIndexReg_1
                -> .
                ;
OptIndexReg_1    -> 'XREG'
                -> 'YREG'
                ;

OptXReg            -> ',' 'XREG'
                -> .
                ;

OptYReg            -> ',' 'YREG'
                -> .
                ;

//---------------------------------------
// Assembler Constants
//---------------------------------------
AsmConstList    -> 'STRING'
                -> AsmConstList_1
                ;
AsmConstList_1    -> AsmConstant AsmConstList_2;
AsmConstList_2    -> ',' AsmConstant AsmConstList_2
                -> .
                ;

AsmConstant        -> AsmConstAddSub AsmConstant_1;
AsmConstant_1    -> '>' AsmConstAddSub     //Lower Part
                -> '<' AsmConstAddSub     //Upper Part
                -> .
                ;

AsmConstAddSub        -> BaseAsmConstant AsmConstAddSub_1;
AsmConstAddSub_1    -> '+' BaseAsmConstant AsmConstAddSub_1
                    -> '-' BaseAsmConstant AsmConstAddSub_1
                    -> .
                    ;

BaseAsmConstant    -> 'LOCAL_LABLE'
                -> 'GLOBAL_LABLE'
                -> 'IDENT'
                -> 'NUMBER'
                -> 'CHAR_CONSTANT'
                -> '*'                //current location counter
                ;

 ---------- AccessModeStackItem.h -------------
#pragma once

class CAccessModeStackItem : public CStackItem
{
    CSection::Mode m_AccessMode;
public:
    CAccessModeStackItem();
    virtual ~CAccessModeStackItem();
    bool Create();
    CSection::Mode GetAccessMode() { return m_AccessMode; }
    void SetAccessMode(CSection::Mode AM) { m_AccessMode = AM; }
};


 ---------- Act65ACC.h -------------
#pragma once

class CAct65ACC : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".A";
public:
    CAct65ACC();
    virtual ~CAct65ACC();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ADD.h -------------
#pragma once

class CAct65ADD : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ADD";
public:
    CAct65ADD();
    virtual ~CAct65ADD();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};

 ---------- Act65ARRAY.h -------------
#pragma once

class CAct65ARRAY : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ARRAY";
public:
    CAct65ARRAY();
    virtual ~CAct65ARRAY();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ASM.h -------------
#pragma once

class CAct65ASM : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ASM";
public:
    CAct65ASM();
    virtual ~CAct65ASM();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ASMPROC.h -------------
#pragma once

class CAct65ASMPROC : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ASMPROC";
public:
    CAct65ASMPROC();
    virtual ~CAct65ASMPROC();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ASMstatement.h -------------
#pragma once

class CAct65ASMstatement : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ASMstmt";
public:
    CAct65ASMstatement();
    virtual ~CAct65ASMstatement();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignADD.h -------------
#pragma once

class CAct65AssignADD : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=ADD";
public:
    CAct65AssignADD();
    virtual ~CAct65AssignADD();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignAND.h -------------
#pragma once

class CAct65AssignAND : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=AND";
public:
    CAct65AssignAND();
    virtual ~CAct65AssignAND();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignDIV.h -------------
#pragma once

class CAct65AssignDIV : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=DIV";
public:
    CAct65AssignDIV();
    virtual ~CAct65AssignDIV();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignLSH.h -------------
#pragma once

class CAct65AssignLSh : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=LSH";
public:
    CAct65AssignLSh();
    virtual ~CAct65AssignLSh();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65Assignment.h -------------
#pragma once

class CAct65Assignment : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=";
public:
    CAct65Assignment();
    virtual ~CAct65Assignment();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignMOD.h -------------
#pragma once

class CAct65AssignMOD : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=MOD";
public:
    CAct65AssignMOD();
    virtual ~CAct65AssignMOD();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignMULT.h -------------
#pragma once

class CAct65AssignMULT :public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=MUL";
public:
    CAct65AssignMULT();
    virtual ~CAct65AssignMULT();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};

 ---------- Act65AssignOR.h -------------
#pragma once

class CAct65AssignOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=OR";
public:
    CAct65AssignOR();
    virtual ~CAct65AssignOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignRSH.h -------------
#pragma once

class CAct65AssignRSH : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=RSH";
public:
    CAct65AssignRSH();
    virtual ~CAct65AssignRSH();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignSUB.h -------------
#pragma once

class CAct65AssignSUB : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=SUB";
public:
    CAct65AssignSUB();
    virtual ~CAct65AssignSUB();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65AssignXOR.h -------------
#pragma once

class CAct65AssignXOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "=XOR";
public:
    CAct65AssignXOR();
    virtual ~CAct65AssignXOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65BEGIN.h -------------
#pragma once

class CAct65BEGIN : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "BEGIN";
public:
    CAct65BEGIN();
    virtual ~CAct65BEGIN();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};

 ---------- Act65BIT.h -------------
#pragma once

class CAct65BIT : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "BIT";
public:
    CAct65BIT();
    virtual ~CAct65BIT();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65BitWiseAND.h -------------
#pragma once

class CAct65BitWiseAND : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "BW-AND";
public:
    CAct65BitWiseAND();
    virtual ~CAct65BitWiseAND();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65BitWiseOR.h -------------
#pragma once

class CAct65BitWiseOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "BW-OR";
public:
    CAct65BitWiseOR();
    virtual ~CAct65BitWiseOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65BOOL.h -------------
#pragma once

class CAct65BOOL : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "BOOL";
public:
    CAct65BOOL();
    virtual ~CAct65BOOL();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65BREAK.h -------------
#pragma once

class CActBREAK : public CAstNode
{
public:
    CActBREAK();
    virtual ~CActBREAK();
    bool Create();
    virtual CValue* Process();
};


 ---------- Act65BYTE.h -------------
#pragma once

class CAct65BYTE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "BYTE";
public:
    CAct65BYTE();
    virtual ~CAct65BYTE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65CARD.h -------------
#pragma once

class CAct65CARD : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "CARD";
public:
    CAct65CARD();
    virtual ~CAct65CARD();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65CHAR.h -------------
#pragma once

class CAct65CHAR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "CHAR";
public:
    CAct65CHAR();
    virtual ~CAct65CHAR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};



 ---------- Act65CharCibstabt.h -------------
#pragma once

class CAct65CharConstant : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "CHAR-CONST";
public:
    CAct65CharConstant();
    virtual ~CAct65CharConstant();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65CodeBlock.h -------------
#pragma once

class CAct65CodeBlock : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "CODE-BLOCK";
public:
    CAct65CodeBlock();
    virtual ~CAct65CodeBlock();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65CurrentLocation.h -------------
#pragma once
#include "AstNode.h"
class CAct65CurrentLocation : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "*";
public:
    CAct65CurrentLocation();
    virtual ~CAct65CurrentLocation();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DAS.h -------------
#pragma once

class CAct65DAS : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DAS";
public:
    CAct65DAS();
    virtual ~CAct65DAS();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DB.h -------------
#pragma once

class CAct65DB : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DB";
public:
    CAct65DB();
    virtual ~CAct65DB();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DCS.h -------------
#pragma once

class CAct65DCS : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DCS";
public:
    CAct65DCS();
    virtual ~CAct65DCS();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DEFINE.h -------------
#pragma once

class CAct65DEFINE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DEFINE";
public:
    CAct65DEFINE();
    virtual ~CAct65DEFINE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DL.h -------------
#pragma once

class CAct65DL : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DL";
public:
    CAct65DL();
    virtual ~CAct65DL();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DO.h -------------
#pragma once

class CAct65DO : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DO";
public:
    CAct65DO();
    virtual ~CAct65DO();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DS.h -------------
#pragma once

class CAct65DS : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DS";
public:
    CAct65DS();
    virtual ~CAct65DS();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65DW.h -------------
#pragma once

class CAct65DW : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "DW";
public:
    CAct65DW();
    virtual ~CAct65DW();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ELSE.h -------------
#pragma once

class CAct65ELSE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ELSE";
public:
    CAct65ELSE();
    virtual ~CAct65ELSE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ELSEIF.h -------------
#pragma once

class CAct65ELSEIF : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ELSEIF";
public:
    CAct65ELSEIF();
    virtual ~CAct65ELSEIF();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65END.h -------------
#pragma once

class CAct65END : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "END";
public:
    CAct65END();
    virtual ~CAct65END();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65EPROC.h -------------
#pragma once

class CAct65EPROC : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "EPROC";
public:
    CAct65EPROC();
    virtual ~CAct65EPROC();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65EqualTO.h -------------
#pragma once

class CAct65EqualTO : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "EQU-TO";
public:
    CAct65EqualTO();
    virtual ~CAct65EqualTO();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65EXIT.h -------------
#pragma once

class CAct65EXIT : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "EXIT";
public:
    CAct65EXIT();
    virtual ~CAct65EXIT();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65FFI.h -------------
#pragma once

class CAct65FFI : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "FFI";
public:
    CAct65FFI();
    virtual ~CAct65FFI();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65FI.h -------------
#pragma once

class CAct65FI : public CAstNode
{
public:
    CAct65FI();
    virtual ~CAct65FI();
    bool Create();
    virtual CValue* Process();
};


 ---------- Act65FlagCARRY.h -------------
#pragma once

class CAct65FlagCARRY : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".C";
public:
    CAct65FlagCARRY();
    virtual ~CAct65FlagCARRY();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};

 ---------- Act65FlagNEG.h -------------
#pragma once

class CAct65FlagNEG : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".N";
public:
    CAct65FlagNEG();
    virtual ~CAct65FlagNEG();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65FlagOVERFLOW.h -------------
#pragma once

class CAct65FlagOVERFLOW : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".O";
public:
    CAct65FlagOVERFLOW();
    virtual ~CAct65FlagOVERFLOW();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65FlagZERO.h -------------
#pragma once

class CAct65FlagZERO : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".Z";
public:
    CAct65FlagZERO();
    virtual ~CAct65FlagZERO();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65FOR.h -------------
#pragma once

class CAct65FOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "FOR";
public:
    CAct65FOR();
    virtual ~CAct65FOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ForItterator.h -------------
#pragma once

class CAct65ForItterator : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ITRATR";
public:
    CAct65ForItterator();
    virtual ~CAct65ForItterator();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ForSTEP.h -------------
#pragma once

class CAct65ForSTEP : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "STEP";
public:
    CAct65ForSTEP();
    virtual ~CAct65ForSTEP();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ForTO.h -------------
#pragma once

class CAct65ForTO : public CAstNode
{
public:
    CAct65ForTO();
    virtual ~CAct65ForTO();
    bool Create();
    virtual CValue* Process();
};


 ---------- Act65FuncCall.h -------------
#pragma once

class CAct65FuncCall : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "FUNC-CALL";
public:
    CAct65FuncCall();
    virtual ~CAct65FuncCall();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65GreaterTHAN.h -------------
#pragma once

class CAct65GreaterTHAN : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "THAN";
public:
    CAct65GreaterTHAN();
    virtual ~CAct65GreaterTHAN();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65GTEQ.h -------------
#pragma once

class CAct65GTEQ : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "GTEQ";
public:
    CAct65GTEQ();
    virtual ~CAct65GTEQ();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65IDENT.h -------------
#pragma once

class CAct65IDENT : public CAstNode
{
public:
    CAct65IDENT();
    virtual ~CAct65IDENT();
    bool Create(CBin* pSym);
    virtual CValue* Process();
};


 ---------- Act65IF.h -------------
#pragma once

class CAct65IF : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "IF";
public:
    CAct65IF();
    virtual ~CAct65IF();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65IFF.h -------------
#pragma once

class CAct65IFF : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "IFF";
public:
    CAct65IFF();
    virtual ~CAct65IFF();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65INT.h -------------
#pragma once

class CAct65INT : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "INT";
public:
    CAct65INT();
    virtual ~CAct65INT();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65INTERRUPT.h -------------
#pragma once

class CAct65INTERRUPT : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "IRQ";
public:
    CAct65INTERRUPT();
    virtual ~CAct65INTERRUPT();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65Label.h -------------
#pragma once

class CAct65Label : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "LABEL";
public:
    CAct65Label();
    virtual ~CAct65Label();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65LessTHAN.h -------------
#pragma once

class CAct65LessTHAN : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "LT";
public:
    CAct65LessTHAN();
    virtual ~CAct65LessTHAN();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65LogicalAND.h -------------
#pragma once

class CAct65LogicalAND : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "L-AND";
public:
    CAct65LogicalAND();
    virtual ~CAct65LogicalAND();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65LogicalOR.h -------------
#pragma once

class CAct65LogicalOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "L-OR";
public:
    CAct65LogicalOR();
    virtual ~CAct65LogicalOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65LowerPart.h -------------
#pragma once

class CAct65LowerPart : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "LowPart";
public:
    CAct65LowerPart();
    virtual ~CAct65LowerPart();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65LSH.h -------------
#pragma once

class CAct65LSH : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "LSH";
public:
    CAct65LSH();
    virtual ~CAct65LSH();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65LTEQ.h -------------
#pragma once

class CAct65LTEQ : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "LTEQ";
public:
    CAct65LTEQ();
    virtual ~CAct65LTEQ();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65Module.h -------------
#pragma once

class CAct65Module : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "MODULE";
public:
    CAct65Module();
    virtual ~CAct65Module();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65NotEquelTO.h -------------
#pragma once

class CAct65NotEquelTO : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "NEQ";
public:
    CAct65NotEquelTO();
    virtual ~CAct65NotEquelTO();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65OD.h -------------
#pragma once

class CAct65OD : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "OD";
public:
    CAct65OD();
    virtual ~CAct65OD();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65Opcode.h -------------
#pragma once

class CAct65Opcode : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "OP";
    Token m_OpcodeToken;
    const char* m_pOpCodeName;
    int m_LineNumber;
    int m_ColumnNumber;
    CSymbol* m_pSym;    // Symbol for argument
    CSymbol* m_pLabel;    // Symbol for instruction location
    AdrModeType m_AdressMode;
    CInstruction* m_pInstruction;
public:
    CAct65Opcode();
    virtual ~CAct65Opcode();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    //-----------------------------
    // Node Processor
    //-----------------------------
    virtual CValue* Process();
    //-----------------------------
    // Setter/Getter Methods
    //-----------------------------
    Token GetToken() { return m_OpcodeToken; }
    void SetToken(Token t) { m_OpcodeToken = t; }
    const char* GetOpcodeName() { return m_pOpCodeName; }
    void SetOpcodeName(const char* pN) { m_pOpCodeName = pN; }
    int GetLineNumber() { return m_LineNumber; }
    void SetLineNumber(int n) { m_LineNumber = n; }
    int GetColumnNumber() { return m_ColumnNumber; }
    void SetColumnNumber(int c) { m_ColumnNumber = c; }
};


 ---------- Act65OptNOT.h -------------
#pragma once

class CAct65OptNOT : public CAstNode
{
public:
    CAct65OptNOT();
    virtual ~CAct65OptNOT();
    virtual bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ORG.h -------------
#pragma once

class CAct65ORG : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ORG";
public:
    CAct65ORG();
    virtual ~CAct65ORG();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65POINTER.h -------------
#pragma once

class CAct65POINTER : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "POINTER";
public:
    CAct65POINTER();
    virtual ~CAct65POINTER();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65POP.h -------------
#pragma once

class CAct65POP : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "POP";
public:
    CAct65POP();
    virtual ~CAct65POP();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65PopDest.h -------------
#pragma once

class CAct65PopDest : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "POP-DST";
public:
    CAct65PopDest();
    virtual ~CAct65PopDest();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();

};


 ---------- Act65Private.h -------------
#pragma once

class CAct65Private : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PRIVATE";
public:
    CAct65Private();
    virtual ~CAct65Private();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65PROC.h -------------
#pragma once

class CAct65PROC : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PROC";
public:
    CAct65PROC();
    virtual ~CAct65PROC();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ProcCall.h -------------
#pragma once

class CAct65ProcCall : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PROC-CALL";
public:
    CAct65ProcCall();
    virtual ~CAct65ProcCall();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65PROCESSOR.h -------------
#pragma once

class CAct65PROCESSOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PROCESSOR";
public:
    CAct65PROCESSOR();
    virtual ~CAct65PROCESSOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65PROCname.h -------------
#pragma once

class CAct65PROCname : public CAstNode
{
public:
    CAct65PROCname();
    virtual ~CAct65PROCname();
    bool Create();
    virtual CValue* Process();

};


 ---------- Act65ProcParams.h -------------
#pragma once

class CAct65ProcParams : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PROC-PARAMS";
public:
    CAct65ProcParams();
    virtual ~CAct65ProcParams();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65PUSH.h -------------
#pragma once

class CAct65PUSH : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PUSH";
public:
    CAct65PUSH();
    virtual ~CAct65PUSH();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65PushSource.h -------------
#pragma once

class CAct65PushSource : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "PUSH-SRC";
public:
    CAct65PushSource();
    virtual ~CAct65PushSource();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65RECTYPE.h -------------
#pragma once

class CAct65RECTYPE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "RECTYPE";
public:
    CAct65RECTYPE();
    virtual ~CAct65RECTYPE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65RETURN.h -------------
#pragma once

class CAct65RETURN : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "RETURN";
public:
    CAct65RETURN();
    virtual ~CAct65RETURN();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ROL.h -------------
#pragma once

class CAct65ROL : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ROL";
public:
    CAct65ROL();
    virtual ~CAct65ROL();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65ROR.h -------------
#pragma once

class CAct65ROR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ROR";
public:
    CAct65ROR();
    virtual ~CAct65ROR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65RSH.h -------------
#pragma once

class CAct65RSH : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "RSH";
public:
    CAct65RSH();
    virtual ~CAct65RSH();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65RTI.h -------------
#pragma once

class CAct65RTI : public CAstNode
{
public:
    CAct65RTI();
    virtual ~CAct65RTI();
    bool Create();
    virtual CValue* Process();
};


 ---------- Act65SecAtrbFALSE.h -------------
#pragma once

class CAct65SecAtrbFALSE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "FALSE";
public:
    CAct65SecAtrbFALSE();
    virtual ~CAct65SecAtrbFALSE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SecAtrbMODE.h -------------
#pragma once

class CAct65SecAtrbMODE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "MODE";
public:
    CAct65SecAtrbMODE();
    virtual ~CAct65SecAtrbMODE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SecAtrbREADONLY.h -------------
#pragma once

class CAct65SecAtrbREADONLY : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "RD-ONLY";
public:
    CAct65SecAtrbREADONLY();
    virtual ~CAct65SecAtrbREADONLY();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SecAtrbREADWRITE.h -------------
#pragma once

class CAct65SecAtrbREADWRITE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "R/W";
public:
    CAct65SecAtrbREADWRITE();
    virtual ~CAct65SecAtrbREADWRITE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SecAtrbSIZE.h -------------
#pragma once

class CAct65SecAtrbSIZE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "SIZE";
public:
    CAct65SecAtrbSIZE();
    virtual ~CAct65SecAtrbSIZE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SecAtrbSTART.h -------------
#pragma once

class CAct65SecAtrbSTART : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ATRB-START";
public:
    CAct65SecAtrbSTART();
    virtual ~CAct65SecAtrbSTART();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SecAtrbZEROPAGE.h -------------
#pragma once

class CAct65SecAtrbZEROPAGE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ZERO-PAGE";
public:
    CAct65SecAtrbZEROPAGE();
    virtual ~CAct65SecAtrbZEROPAGE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SECTION.h -------------
#pragma once

class CAct65SECTION : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "SECTION";
public:
    CAct65SECTION();
    virtual ~CAct65SECTION();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65SUB.h -------------
#pragma once

class CAct65SUB : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "SUB";
public:
    CAct65SUB();
    virtual ~CAct65SUB();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65THEN.h -------------
#pragma once

class CAct65THEN : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "THEN";
public:
    CAct65THEN();
    virtual ~CAct65THEN();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};

 ---------- Act65TRUE.h -------------
#pragma once

class CAct65TRUE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "TRUE";
public:
    CAct65TRUE();
    virtual ~CAct65TRUE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65TYPEDEF.h -------------
#pragma once

class CAct65tTYPEDEF : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "TYPEDEF";
public:
    CAct65tTYPEDEF();
    virtual ~CAct65tTYPEDEF();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65UNTILL.h -------------
#pragma once

class CAct65UNTILL : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "UNTILL";
public:
    CAct65UNTILL();
    virtual ~CAct65UNTILL();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65UpperPart.h -------------
#pragma once

class CAct65UpperPart : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "UpPart";
public:
    CAct65UpperPart();
    virtual ~CAct65UpperPart();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65VECTOR.h -------------
#pragma once

class CAct65VECTOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "VECTOR";
public:
    CAct65VECTOR();
    virtual ~CAct65VECTOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65WHILE.h -------------
#pragma once

class CAct65WHILE : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "ASM";
public:
    CAct65WHILE();
    virtual ~CAct65WHILE();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65XOR.h -------------
#pragma once

class CAct65XOR : public CAstNode
{
    inline static const char* m_pNodeTyypeName = "XOR";
public:
    CAct65XOR();
    virtual ~CAct65XOR();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65XREG.h -------------
#pragma once

class CAct65XREG : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".X";
public:
    CAct65XREG();
    virtual ~CAct65XREG();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};


 ---------- Act65YREG.h -------------
#pragma once

class CAct65YREG : public CAstNode
{
    inline static const char* m_pNodeTyypeName = ".Y";
public:
    CAct65YREG();
    virtual ~CAct65YREG();
    bool Create(CAstNode* pChild, CAstNode* pNext);
    virtual CValue* Process();
};

    
 ---------- ActionApp.h -------------
#pragma once

class CActionApp
{
    char* m_pSourceFile;
    char* m_pLogFile;
    char* m_pObjectFile;
    char* m_pBinaryFile;
    FILE* m_pfSrc;
    FILE* m_pfLog;
    FILE* m_pfBin;
    FILE* m_pfObj;
    CParser m_ActParse;
public:
    CActionApp();
    virtual ~CActionApp();
    virtual bool Create(int argc, char* argv[]);
    virtual bool Run();
    bool OpenSource();
    bool OpenLog();
    bool OpenObj();
    bool OpenBin();

    void CloseSource();
    void CloseLog();
    void CloseObj();
    void CloseBin();
    void CloseAll();
    char* GetSourceFileName() {
        return m_pSourceFile;
    }
    char* GetLogFileName() {
        return m_pLogFile;
    }
    char* GetObjFileName() {
        return m_pObjectFile;
    }
    char* GetBinFileName() {
        return m_pBinaryFile;
    }
    virtual FILE* SrcFile() {
        return m_pfSrc;
    }
    virtual FILE* LogFile() {
        return m_pfLog;
    }
    virtual FILE* ObjFile() {
        return m_pfObj;
    }
    virtual FILE* BinFile() {
        return m_pfBin;
    }
    virtual CParser* GetParser()
    {
        return &m_ActParse;
    }
    char* IndentString(char* s, int Indent, int c);
    static void Dump(
        FILE* pOut, 
        char* pMem, 
        unsigned StartAddress, 
        unsigned Size
    );
    //-----------------------------------------
    char* CreateIndentString(char* s, int n, int Indent, int c = ' ');
};

extern CActionApp* Act();

 ---------- ActionAstTree.h -------------
#pragma once

class CActionAstTree : public CAstTree
{
public:
    CActionAstTree();
    virtual ~CActionAstTree();
    bool Create();
    virtual CAstNode* MakeNewNode(
        int Type,
        CAstNode* Child,
        CAstNode* Next
    );
};


 ---------- ActStatusFlags.h -------------
#pragma once

class CActStatusFlags : public CAstNode
{
public:
    CActStatusFlags();
    virtual ~CActStatusFlags();
    bool Create();
};


 ---------- AddressSizeStackItem.h -------------
#pragma once

class CAddressSizeStackItem : public CStackItem
{
    CSection::AddressSize m_OpRandAdrSize;
public:
    CAddressSizeStackItem();
    virtual ~CAddressSizeStackItem();
    bool Create();
    CSection::AddressSize GetOprandSize() { return m_OpRandAdrSize; }
    void SetOprandSize(CSection::AddressSize OpSize) { m_OpRandAdrSize = OpSize; }
};


 ---------- AstNode.h -------------
#pragma once

class CAstNode
{
    inline static int m_NodeCount = 0;
    int m_NodeID;
    int m_NodeType;
    const char* m_pNodeName;
    CAstNode* m_pStart;
    CAstNode* m_pNext;
    CAstNode* m_pPrev;
    CAstNode* m_pHead;
    CAstNode* m_pTail;
    CAstNode* m_pChild;
    CAstNode* m_pParent;
    CValue* m_pValue;
public:
    CAstNode();
    CAstNode(int NodeType);
    virtual ~CAstNode();
    bool CreateNode(
        CAstNode* pChild = 0,
        CAstNode* pNext = 0
    );
    virtual CValue* Process() = 0;
    virtual void Print(FILE* pOut, int Indent, char* s);
    void AddToHead(CAstNode* pN);
    void AddToTail(CAstNode* pN);
    // Getter/Setter Methods
    CAstNode* GetHead() { return m_pHead; }
    CAstNode* GetTail() { return m_pTail; }
    CAstNode* GetStart() { return m_pStart; }
    CAstNode* GetNext() { return m_pNext; }
    CAstNode* GetPrev() { return m_pPrev; }
    CAstNode* GetChild() { return m_pChild; }
    CAstNode* GetParent() { return m_pParent; }
    void SetHead(CAstNode* pAN) { m_pHead = pAN; }
    void SetTail(CAstNode* pAN) { m_pTail = pAN; }
    void SetStart(CAstNode* pAN) { m_pStart = pAN; }
    void SetNext(CAstNode* pAN) { m_pNext = pAN; }
    void SetPrev(CAstNode* pAN) { m_pPrev = pAN; }
    void SetChild(CAstNode* pAN) { m_pChild = pAN; }
    void SetParent(CAstNode* pAN) { m_pParent = pAN; }
    //---------------------------------------------------
    int GetID() { return m_NodeID; }
    void SetID(int Id) { m_NodeID = Id; }
    int GetNodeType() { return m_NodeType; }
    void SetNodeType(int Nt) { m_NodeType = Nt; }
    const char* GetNodeName() { return m_pNodeName; }
    void SetNodeName(const char* pName) {
        m_pNodeName = pName;
    }
    bool SetSymbol(CBin* pSym) {
        bool rV = true;

        if (m_pValue)
            m_pValue->SetSymbol(pSym);
        else
            rV = false;
        return rV;
    }
    CBin* GetSymbol() { 
        CBin* pSym = 0;

        if (m_pValue)
            pSym = m_pValue->GetSymbol();
        return pSym; }
};

 ---------- AstTree.h -------------
#pragma once

class CAstTree
{
    CAstNode* m_pRoot;
public:
    CAstTree();
    virtual ~CAstTree();
    bool Create();
    void Print(FILE* pOut);
    void TraverseTree(
        FILE* pOut, 
        CAstNode* pNode, 
        char* s
    );
    //--------------------------------
    void SetRootNode(CAstNode* pRoot) { m_pRoot = pRoot; }
    CAstNode* GetRootNode() { return m_pRoot; }
};


 ---------- Bin.h -------------
#pragma once

class CBin
{
public:
    enum BinType {
        ALL,
        SYMBOL,
        SECTION,
        WHERE_USED,
        UNRESOLVED
    };
private:
    CBin* m_pNext;
    CBin* m_pPrev;
    CBin* m_pHead;
    CBin* m_pTail;
    char* m_pName;
    BinType m_Type;
    Token m_Token;
    char m_strName[MAX_SYMBOL_NAME_LEN];
public:
    CBin() {
        m_pHead = 0;
        m_pTail = 0;
        m_Token = Token(0);
        m_pNext = 0;
        m_pPrev = 0;
        m_pName = new char[MAX_NAME_LEN];
        m_Type = BinType(0);
        m_Token = Token(0);
        for (int i = 0; i < MAX_SYMBOL_NAME_LEN; ++i)
            m_strName[i] = 0;
    }
    CBin(BinType type) {
        m_pName = new char[MAX_NAME_LEN];
        m_pNext = 0;
        m_pPrev = 0;
        m_pHead = 0;
        m_pTail = 0;
        m_Token = Token::ENDOFTOKENS;
        m_Type = type;
        for (int i = 0; i < MAX_SYMBOL_NAME_LEN; ++i)
            m_strName[i] = 0;
    }
    virtual ~CBin() {
        if (m_pName)
            delete[]m_pName;
    };
    bool Create() { return true; }
    CBin* GetNext() { return m_pNext; }
    void SetNext(CBin* pB) { m_pNext = pB; }
    CBin* GetPrev() { return m_pPrev; }
    void SetPrev(CBin* pB) { m_pPrev = pB; }
     virtual char* GetName(void) { return m_pName; }
     virtual void SetName(const char* pName) {
        int l = (int)strlen(pName) + 1;
        if (m_pName) delete m_pName;
        m_pName = new char[l];
        strcpy_s(m_pName, l, pName);
    }
     virtual bool Compare(const char *name, int aux = 0);
     BinType GetType() { return m_Type; }
     //    virtual bool Compare(const char* name) {
//        bool rV = false;
//        if (strcmp(m_pName, name) == 0) rV = true;
//        return rV;
    //}
     void SetToken(Token t) { m_Token = t; }
     Token GetToken() { return m_Token; }
     virtual void Print(FILE* pOut, const char* s = 0);
     //------------------------------------------
     // SubList Methods
     //------------------------------------------
     void Add(CBin* pSym);
     CBin* Find(const char* pName, CBin::BinType Type);
     void Delete(CBin* pSym);
     void Unlink(CBin* pSym);
     inline void SetHead(CBin* pH) { m_pHead = pH; }
     inline CBin* GetHead() { return m_pHead; }
     inline void SetTail(CBin* pT) { m_pTail = pT; }
     inline CBin* GetTail() { return m_pTail; }
};


 ---------- BinStackItem.h -------------
#pragma once

class CBinStackItem : public CStackItem
{
    CBin* m_pBin;
public:
    CBinStackItem();
    virtual ~CBinStackItem();
    bool Create();
    CBin* GetBin() { return m_pBin; }
    void SetBin(CBin* pB) { m_pBin = pB; }
};


 ---------- Bucket.h -------------
#pragma once

class CBucket
{
    CBin* m_pHead;
    CBin* m_pTail;
public:
    CBucket() {
        m_pHead = 0;
        m_pTail = 0;
    }
    virtual ~CBucket();
    void Add(CBin* pSym);
    bool Create() { return true; }
    CBin* Find(const char* pName, int scope);
    void Delete(CBin* pSym);
    void Unlink(CBin* pSym);
    inline void SetHead(CBin* pH) { m_pHead = pH; }
    inline CBin* GetHead() { return m_pHead; }
    inline void SetTail(CBin* pT) { m_pTail = pT; }
    inline CBin* GetTail() { return m_pTail; }
};


 ---------- DataSizeStackItem.h -------------
#pragma once

class CDataSizeStackItem : public CStackItem
{
    int m_ObjectSize;
public:
    CDataSizeStackItem();
    virtual ~CDataSizeStackItem();
    bool Create();
    void SetSize(int size) { m_ObjectSize = size; }
    int GetSize() { return m_ObjectSize; }
};


 ---------- Instruction.h -------------
#pragma once


class CInstruction : public CStackItem
{
    //-------------------------------
    // Bytes are Little Endian Order
    //-------------------------------
    char m_OpCode;
    char m_LowByte;
    char m_HighByte;
    char m_unused;
    Token m_OpCodeToken;
    int m_ByteCount;
    bool m_UnResolved;
public:
    CInstruction();
    ~CInstruction();
    bool Create();
    void SetByteCount(int n) { m_ByteCount = n; }
    int GetByteCount() { return m_ByteCount; }
    void SetOpCodeToken(Token Op) { m_OpCodeToken = Op; }
    Token GetOpCodeToken() { return m_OpCodeToken; }
    void SetOpcode(unsigned op) { m_OpCode = op; }
    void AddToOpCode(unsigned v) { m_OpCode += v; }
    char GetOpCode() { return m_OpCode; }
    bool IsUnResolved() { return m_UnResolved; }
    bool IsResolved() { return !m_UnResolved; }
    void SetUnResolved() { m_UnResolved = true; }
    void SetOperandW(unsigned v) {
        m_LowByte = v & 0xff;
        m_HighByte = (v & 0x0ff00) >> 8;
    }
    unsigned GetOperandW() {
        unsigned v;

        v = (m_LowByte & 0x0ff) | ((m_HighByte & 0x0ff) << 8);
        return v;
    }
    unsigned char GetLowByte() { return m_LowByte; }
    void SetLowByte(unsigned v) { m_LowByte = v; }
    unsigned char GetHighByte() { return m_HighByte;}
    void SetHighByte(unsigned v) { m_HighByte = v; }
    void AddToCurrentSection();
    bool IsRelative();
};


 ---------- Lexer.h -------------
#pragma once

class CLexer
{
public:
    
private:
    struct AdressModeItem {
        AdrModeType Mode;
        int inc;
        AdressModeItem() {
            Mode = AdrModeType::NA;
            inc = 0;
        }
        AdressModeItem(AdrModeType T, int I) {
            Mode = T;
            inc = I;
        }
        int GetInc(AdrModeType ModeType) {
            //---------------------------
            // GetInc
            //    Compares the address mode
            // type of this object to the
            // one that is desired.  If
            // they are equal, we get
            // back the increment value,
            // If they are not equal, we
            // get back -1
            //---------------------------
            int rV = -1;

            if (ModeType == Mode)
                rV = inc;
            return rV;
        }
    };
    struct AdressModeLUT {
        CLexer::AdressModeItem* ModeInc;
        int m_nElements;
        AdressModeLUT() {
            ModeInc = 0;
            m_nElements = 0;
        }
        AdressModeLUT(int n, AdressModeItem* MI) {
            ModeInc = MI;
            m_nElements = n;
        }
        int GetInc(AdrModeType Type) {
            int i, rV = -1;
            bool Loop = true;

            for (i = 0; Loop && i < m_nElements; ++i)
            {
                rV = ModeInc[i].GetInc(Type);
                if (rV >= 0)
                    Loop = false;
            }
            return rV;
        }
    };
    //alu access modes
    static inline AdressModeItem Order8[8] = {
        {AdrModeType::INDIRECT_X_ADR, 0},
        {AdrModeType::ZERO_PAGE_ADR, 4},
        {AdrModeType::IMMEDIATE_ADR, 8},
        {AdrModeType::ABSOLUTE_ADR, 12},
        {AdrModeType::INDIRECT_Y_ADR, 16},
        {AdrModeType::ZERO_PAGE_X_ADR, 20},
        {AdrModeType::ABSOLUTE_Y_ADR, 24},
        {AdrModeType::ABSOLUTE_X_ADR, 28}
    };
    static inline AdressModeLUT LUT_Order8 = { 8, Order8 };

    // sta address modes
    static inline AdressModeItem Order7[7] = {
        {AdrModeType::INDIRECT_X_ADR, 0},
        {AdrModeType::ZERO_PAGE_ADR, 4},
        {AdrModeType::ABSOLUTE_ADR, 12},
        {AdrModeType::INDIRECT_Y_ADR, 16},
        {AdrModeType::ZERO_PAGE_X_ADR, 20},
        {AdrModeType::ABSOLUTE_Y_ADR, 24},
        {AdrModeType::ABSOLUTE_X_ADR, 28}
    };
    static inline AdressModeLUT LUT_Order7 = { 8, Order7 };
    //---------------------------------------
    // ASL, LSR, ROR, ROL
    static inline AdressModeItem Order5[5] = {
        {AdrModeType::ZERO_PAGE_ADR, 0},
        {AdrModeType::ACCUMULATOR,4},
        {AdrModeType::ABSOLUTE_ADR, 8},
        {AdrModeType::ZERO_PAGE_X_ADR, 16},
        {AdrModeType::ABSOLUTE_X_ADR, 24}
    };
    static inline AdressModeLUT LUT_Order5 = { 5, Order5 };
    //----------------------------------------------
    static inline AdressModeItem Order5_LDY[5] = {
        {AdrModeType::IMMEDIATE_ADR,0},
        {AdrModeType::ZERO_PAGE_ADR, 4},
        {AdrModeType::ABSOLUTE_ADR, 12},
        {AdrModeType::ZERO_PAGE_X_ADR, 20},
        {AdrModeType::ABSOLUTE_X_ADR, 28}
    };
    static inline AdressModeLUT LUT_Order5_LDY = { 5, Order5_LDY };
    //---------------------------------------------
    static inline AdressModeItem Order5_LDX[5] = {
        {AdrModeType::IMMEDIATE_ADR,0},
        {AdrModeType::ZERO_PAGE_ADR, 4},
        {AdrModeType::ABSOLUTE_ADR, 12},
        {AdrModeType::ZERO_PAGE_Y_ADR, 20},
        {AdrModeType::ABSOLUTE_Y_ADR, 28}
    };
    static inline AdressModeLUT LUT_Order5_LDX = { 5, Order5_LDX };
    //---------------------------------------------
    static inline AdressModeItem Order4[4] = {
        {AdrModeType::ZERO_PAGE_ADR, 0},
        {AdrModeType::ABSOLUTE_ADR, 8},
        {AdrModeType::ZERO_PAGE_X_ADR, 16},
        {AdrModeType::ABSOLUTE_X_ADR, 24}
    };
    static inline AdressModeLUT LUT_Order4 = { 4, Order4 };
    //---------------------------------------------
    static inline AdressModeItem Order3_STX[3] = {    //STX
        {AdrModeType::ZERO_PAGE_ADR, 0},
        {AdrModeType::ZERO_PAGE_Y_ADR,16},
        {AdrModeType::ABSOLUTE_ADR, 8},
    };
    static inline AdressModeLUT LUT_Order3_STX = { 3, Order3_STX };
    //---------------------------------------------
    static inline AdressModeItem Order3_STY[3] = {    //STY
        {AdrModeType::ZERO_PAGE_ADR, 0},
        {AdrModeType::ZERO_PAGE_X_ADR,16},
        {AdrModeType::ABSOLUTE_ADR, 8},
    };
    static inline AdressModeLUT LUT_Order3_STY = { 3, Order3_STY };
    //---------------------------------------------
    static inline AdressModeItem Order3_CPY_CPX[3] = {    //CPY/CPX
        {AdrModeType::IMMEDIATE_ADR,0},
        {AdrModeType::ZERO_PAGE_ADR, 4},
        {AdrModeType::ABSOLUTE_ADR, 12}
    };
    static inline AdressModeLUT LUT_Order3__CPY_CPX = { 3, Order3_CPY_CPX };
    //---------------------------------------------
    static inline AdressModeItem Order2[2] = {
        {AdrModeType::ABSOLUTE_ADR,0 },
        {AdrModeType::INDIRECT_ADR,32 }
    };
    static inline AdressModeLUT LUT_Order2 = { 3, Order2 };
    //---------------------------------------------
    static inline AdressModeItem Order2_BIT[2] = {
        {AdrModeType::ZERO_PAGE_ADR,0 },
        {AdrModeType::ABSOLUTE_ADR,8 }
    };
    static inline AdressModeLUT LUT_Order2_BIT = { 3, Order2_BIT };
    //---------------------------------------------
    static inline AdressModeItem Order1[1] = {
        {AdrModeType::ABSOLUTE_ADR,0 }
    };
    static inline AdressModeLUT LUT_Order1 = { 3, Order1 };
    struct KeyWord {
        Token m_TokenID;    //token value
        const char* m_Name;    //token name
        int m_MaxBytes;            //Maximum number of bytes for instruction
        int m_OpCode;            //base opcode
        Processor m_Processor;    //for which processor
        AdressModeLUT* m_pAddresModeLUT;
        int NumOfAdrModes;
        const char* LookupToName(Token Toke);
        int FindInc(AdrModeType AdrMode);
        Token LookupToToken(const char* pName);
    };
    static inline KeyWord KeyWords[] = {
        {Token::ENDOFFILE,"End Of File"},        //1
        {Token::IDENT,"IDENT"},                    //2
        {Token::NUMBER,"NUMBER"},                //3
        {Token::MOD,"MOD"},        
        //--------- Assignment -------------
        { Token::ASSIGN_ADD,"==+", 0 },
        { Token::ASSIGN_SUB,"==-", 0 },
        { Token::ASSIGN_MUL,"==*", 0 },
        { Token::ASSIGN_DIV,"==/", 0 },
        { Token::ASSIGN_MOD,"==MOD", 0 },
        { Token::ASSIGN_AND,"==&", 0 },
        { Token::ASSIGN_OR,"==%", 0 },
        { Token::ASSIGN_XOR,"==XOR", 0 },
        { Token::ASSIGN_RSH,"==RSH", 0 },
        { Token::ASSIGN_LSH,"==LSH", 0 },
        //---------- Operators ------------
        {Token::LSH,"LSH"},                        
        {Token::RSH,"RSH"},                        
        {Token::OR,"OR"},                        
        {Token::XOR, "XOR"},    
        {Token::MOD,"MOD", 0 },
        {Token::GTEQ,">=", 0 },
        {Token::LTEQ,"<=", 0 },
        //--------------- Functions --------------
        {Token::PROC,"PROC"},    // Proceedure Declaration
        {Token::FUNC,"FUNC"},    //  Function Declaration
        {Token::INTERRUPT,"INTERRUPT"},
        {Token::PROC_IDENT,"PROC Idnet"},    //  Proceedure Declaration
        {Token::FUNC_IDENT,"FUNC Ident"},    //  Function Declaration
        {Token::INTERRUPT_IDENT,"INTERRUPT Indent"},
        //------ Data Types -----------------
        {Token::BOOL,"BOOL"},
        {Token::BYTE,"BYTE"},
        {Token::CHAR,"CHAR"},
        {Token::INT,"INT"},
        {Token::CARD,"CARD"},
        {Token::TYPE, "TYPE"},
        {Token::RECORDTYPE,"Record Type (TYPE)"},
        {Token::POINTER,"POINTER"},
        {Token::ARRAY,"ARRAY"},
        //--------- Statements --------------
        {Token::MODULE,"MODULE"},
        {Token::VECTOR,"VECTOR"},
        {Token::FOR,"FOR"},
        {Token::TO,"TO"},
        {Token::STEP,"STEP"},
        {Token::IF,"IF"},
        {Token::IFF,"IFF"},
        {Token::THEN,"THEN"},
        {Token::ELSEIF,"ELSEIF"},
        {Token::ELSE,"ELSE"},
        {Token::FI,"FI"},
        {Token::FFI,"FFI"},
        {Token::WHILE,"WHILE"},
        {Token::DO,"DO"},
        {Token::OD,"OD"},
        {Token::UNTIL,"UNTIL"},
        {Token::EXIT,"EXIT"},
        {Token::RETURN,"RETURN"},
        {Token::ASM,"ASM"},
        {Token::PUSH,"PUSH"},
        {Token::POP,"POP"},
        {Token::BREAK, "BREAK"},
        {Token::BITS,"BITS"},
        {Token::BEGIN,"BEGIN"},
        {Token::END, "END"},
        //--------- Compiler Directives -----------------
        {Token::DEFINE,"DEFINE"},
        {Token::SET,"SET"},
        {Token::INCLUDE,"INCLUDE"},
        //---------------------------------
        // Assembler Tokens
        //---------------------------------
        //--------- Section ------------
        {Token::SECTION,"SECTION", 0,0, Processor::ALL,NULL,0},
        {Token::SECTION_NAME,"SECTION NAME", 0,0, Processor::ALL,NULL,0},
        {Token::START,"START", 0,0,Processor::ALL,NULL,0},
        {Token::SIZE,"SIZE", 0,0,Processor::ALL,NULL,0},
        {Token::NAME,"NAME", 0,0,Processor::ALL,NULL,0},
        {Token::MODE,"MODE", 0,0,Processor::ALL,NULL,0},
        {Token::READ_WRTE,"READ_WRITE", 0,0,Processor::ALL,NULL,0},
        {Token::READ_ONLY,"READ_ONLY", 0,0,Processor::ALL,NULL,0},
        {Token::ZEROPAGE,"ZEROPAGE", 0},
        {Token::True,"true", 0},
        {Token::False,"false", 0},
        //----- Assembler Declarations
        {Token::ORG,"ORG", 0,0, Processor::ALL,NULL,0},
        {Token::DB,"DB", 0,0, Processor::ALL,NULL,0},
        {Token::DW,"DW", 0,0, Processor::ALL,NULL,0},
        {Token::DL,"DL", 0,0, Processor::ALL,NULL,0},
        {Token::DAS,"DAS", 0,0, Processor::ALL,NULL,0},
        {Token::DCS,"DCS", 0,0, Processor::ALL,NULL,0},
        {Token::DS,"DS", 0,0, Processor::ALL,NULL,0},
        //----------- Opcodes --------------
        {Token::ADC,"ADC", 3 ,0X61, Processor::R6502, &LUT_Order8,8},
        {Token::AND,"AND", 3,0X21, Processor::R6502, &LUT_Order8,8},
        {Token::ASL,"ASL", 3,0X06, Processor::R6502, &LUT_Order5,5},
        {Token::BCC,"BCC", 2,0x90, Processor::R6502, NULL,0},
        {Token::BCS,"BCS", 2,0XB0, Processor::R6502, NULL,0},
        {Token::BEQ,"BEQ", 2,0XF0, Processor::R6502, NULL,0},
        {Token::BMI,"BMI", 2,0x30, Processor::R6502, NULL,0},
        {Token::BNE,"BNE", 2,0XD0, Processor::R6502, NULL,0},
        {Token::BPL,"BPL", 2,0x10, Processor::R6502, NULL,0},
        {Token::BVC,"BVC", 2,0x50, Processor::R6502, NULL,0},
        {Token::BVS,"BVS", 2,0x70, Processor::R6502, NULL,0},
        {Token::BIT,"BIT", 3,0X24, Processor::R6502, &LUT_Order2_BIT,2},
        {Token::BRK,"BRK", 1,0x00, Processor::R6502, NULL,0},
        {Token::CLC,"CLC", 1,0X18, Processor::R6502, NULL,0},
        {Token::CLD,"CLD", 1,0xd8, Processor::R6502, NULL,0},
        {Token::CLI,"CLI", 1,0X58, Processor::R6502, NULL,0},
        {Token::CLV,"CLV", 1,0xb8, Processor::R6502, NULL,0},
        {Token::CMP,"CMP", 3,0xc1, Processor::R6502, &LUT_Order8,8},
        {Token::CPX,"CPX", 3,0XE0, Processor::R6502, &LUT_Order3__CPY_CPX,3},
        {Token::CPY,"CPY", 3,0XC0, Processor::R6502, &LUT_Order3__CPY_CPX,3},
        {Token::DEC,"DEC", 3,0xc6, Processor::R6502, &LUT_Order4,4},
        {Token::DEX,"DEX", 1,0xca, Processor::R6502, NULL,0},
        {Token::DEY,"DEY", 1,0x88, Processor::R6502, NULL,0},
        {Token::EOR,"EOR", 3,0X41, Processor::R6502, &LUT_Order8,8},
        {Token::INC,"INC", 3,0xe6, Processor::R6502, &LUT_Order4,4},
        {Token::INX,"INX", 1,0xe8, Processor::R6502, NULL,0},
        {Token::INY,"INY", 1,0xc8, Processor::R6502, NULL,0},
        {Token::JMP,"JMP", 3,0X4C, Processor::R6502, &LUT_Order2,2},
        {Token::JSR,"JSR", 3,0x20, Processor::R6502, &LUT_Order1,1},
        {Token::LDA, "LDA", 3, 0xa1, Processor::R6502, & LUT_Order8, 8},
        { Token::LDX,"LDX", 3,0xA2, Processor::R6502, &LUT_Order5_LDX,5 },
        { Token::LDY,"LDY", 3,0xa0, Processor::R6502, &LUT_Order5_LDY,5 },
        { Token::LSR,"LSR", 3,0X46, Processor::R6502, &LUT_Order5,5 },
        { Token::NOP,"NOP", 1,0xea, Processor::R6502, NULL,0 },
        { Token::ORA,"ORA", 3,0X01, Processor::R6502, &LUT_Order8,8 },
        { Token::PHA,"PHA", 1,0X48, Processor::R6502, NULL,0 },
        { Token::PLA,"PLA", 1,0x68, Processor::R6502, NULL,0 },
        { Token::PHP,"PHP", 1,0X08, Processor::R6502, NULL,0 },
        { Token::PLP,"PLP", 1,0X28, Processor::R6502, NULL,0 },
        { Token::ROL,"ROL",3,0X26, Processor::R6502, &LUT_Order5,5 },
        { Token::ROR,"ROR",3,0X66, Processor::R6502, &LUT_Order5,5 },
        { Token::RTI,"RTI", 1,0x40, Processor::R6502, NULL,0 },
        { Token::RTS,"RTS", 1,0x60, Processor::R6502, NULL,0 },
        { Token::SBC,"SBC",3,0xe1, Processor::R6502, &LUT_Order8,8 },
        { Token::STA,"STA",3,0x81, Processor::R6502, &LUT_Order7,7 },
        { Token::SEC,"SEC", 1,0x38, Processor::R6502, NULL,0 },
        { Token::SED,"SED", 1,0Xf8, Processor::R6502, NULL,0 },
        { Token::SEI,"SEI", 1,0x78, Processor::R6502, NULL,0 },
        { Token::STX,"STX",3,0x86, Processor::R6502, &LUT_Order3_STX,3 },
        { Token::STY,"STY",3,0x84, Processor::R6502, &LUT_Order3_STY,3 },
        { Token::TAX,"TAX", 1,0xaa, Processor::R6502, NULL,0 },
        { Token::TAY,"TAY", 1,0xa8, Processor::R6502, NULL,0 },
        { Token::TXA,"TXA", 1,0x8a, Processor::R6502, NULL,0 },
        { Token::TYA,"TYA", 1,0x98, Processor::R6502, NULL,0 },
        { Token::TXS,"TXS", 1,0x9a, Processor::R6502, NULL,0 },
        { Token::TSX,"TSX", 1,0xba, Processor::R6502, NULL,0 },
        //--------------------------------------------
        // Lower Case Opcodes
        //--------------------------------------------
        { Token::ADC,"adc", 3 ,0X61, Processor::R6502, &LUT_Order8,8 },
        { Token::AND,"and", 3,0X21, Processor::R6502, &LUT_Order8,8 },
        { Token::ASL,"asl", 3,0X06, Processor::R6502, &LUT_Order5,5 },
        { Token::BCC,"bcc", 2,0x90, Processor::R6502, NULL,0 },
        { Token::BCS,"bcs", 2,0XB0, Processor::R6502, NULL,0 },
        { Token::BEQ,"beq", 2,0XF0, Processor::R6502, NULL,0 },
        { Token::BMI,"bmi", 2,0x30, Processor::R6502, NULL,0 },
        { Token::BNE,"bne", 2,0XD0, Processor::R6502, NULL,0 },
        { Token::BPL,"bpl", 2,0x10, Processor::R6502, NULL,0 },
        { Token::BVC,"bvc", 2,0x50, Processor::R6502, NULL,0 },
        { Token::BVS,"bvs", 2,0x70, Processor::R6502, NULL,0 },
        { Token::BIT,"bit", 3,0X24, Processor::R6502, &LUT_Order2_BIT,2 },
        { Token::BRK,"brk", 1,0x00, Processor::R6502, NULL,0 },
        { Token::CLC,"clc", 1,0X18, Processor::R6502, NULL,0 },
        { Token::CLD,"cld", 1,0xd8, Processor::R6502, NULL,0 },
        { Token::CLI,"cli", 1,0X58, Processor::R6502, NULL,0 },
        { Token::CLV,"clv", 1,0xb8, Processor::R6502, NULL,0 },
        { Token::CMP,"cmp", 3,0xc1, Processor::R6502, &LUT_Order8,8 },
        { Token::CPX,"cpx", 3,0XE0, Processor::R6502, &LUT_Order3__CPY_CPX,3 },
        { Token::CPY,"cpy", 3,0XC0, Processor::R6502, &LUT_Order3__CPY_CPX,3 },
        { Token::DEC,"dec", 3,0xc6, Processor::R6502, &LUT_Order4,4 },
        { Token::DEX,"dex", 1,0xca, Processor::R6502, NULL,0 },
        { Token::DEY,"dey", 1,0x88, Processor::R6502, NULL,0 },
        { Token::EOR,"eor", 3,0X41, Processor::R6502, &LUT_Order8,8 },
        { Token::INC,"inc", 3,0xe6, Processor::R6502, &LUT_Order4,4 },
        { Token::INX,"inx", 1,0xe8, Processor::R6502, NULL,0 },
        { Token::INY,"iny", 1,0xc8, Processor::R6502, NULL,0 },
        { Token::JMP,"jmp", 3,0X4C, Processor::R6502, &LUT_Order2,2 },
        { Token::JSR,"jsr", 3,0x20, Processor::R6502, &LUT_Order1,1 },
        { Token::LDA,"lda", 3,0xa1, Processor::R6502, &LUT_Order8,8 },
        { Token::LDX,"ldx", 3,0xA2, Processor::R6502, &LUT_Order5_LDX,5 },
        { Token::LDY,"ldy", 3,0xa0, Processor::R6502, &LUT_Order5_LDY,5 },
        { Token::LSR,"lsr", 3,0X46, Processor::R6502, &LUT_Order5,5 },
        { Token::NOP,"nop", 1,0xea, Processor::R6502, NULL,0 },
        { Token::ORA,"ora", 3,0X01, Processor::R6502, &LUT_Order8,8 },
        { Token::PHA,"pha", 1,0X48, Processor::R6502, NULL,0 },
        { Token::PLA,"pla", 1,0x68, Processor::R6502, NULL,0 },
        { Token::PHP,"php", 1,0X08, Processor::R6502, NULL,0 },
        { Token::PLP,"plp", 1,0X28, Processor::R6502, NULL,0 },
        { Token::ROL,"rol",3,0X26, Processor::R6502, &LUT_Order5,5 },
        { Token::ROR,"ror",3,0X66, Processor::R6502, &LUT_Order5,5 },
        { Token::RTI,"rti", 1,0x40, Processor::R6502, NULL,0 },
        { Token::RTS,"rts", 1,0x60, Processor::R6502, NULL,0 },
        { Token::SBC,"sbc",3,0xe1, Processor::R6502, &LUT_Order8,8 },
        { Token::STA,"sta",3,0x81, Processor::R6502, &LUT_Order7,7 },
        { Token::SEC,"sec", 1,0x38, Processor::R6502, NULL,0 },
        { Token::SED,"sed", 1,0Xf8, Processor::R6502, NULL,0 },
        { Token::SEI,"sei", 1,0x78, Processor::R6502, NULL,0 },
        { Token::STX,"stx",3,0x86, Processor::R6502, &LUT_Order3_STX,3 },
        { Token::STY,"sty",3,0x84, Processor::R6502, &LUT_Order3_STY,3 },
        { Token::TAX,"tax", 1,0xaa, Processor::R6502, NULL,0 },
        { Token::TAY,"tay", 1,0xa8, Processor::R6502, NULL,0 },
        { Token::TXA,"txa", 1,0x8a, Processor::R6502, NULL,0 },
        { Token::TYA,"tya", 1,0x98, Processor::R6502, NULL,0 },
        { Token::TXS,"txs", 1,0x9a, Processor::R6502, NULL,0 },
        { Token::TSX,"tsx", 1,0xba, Processor::R6502, NULL,0 },
        { Token::ENDOFOPCODES,"EOO", 0, 0, Processor::ALL,NULL,0 },
        //------- Lables -------------
        { Token::LOCAL_LABEL,"Local Lable", 0,0,Processor::ALL,NULL,0 },
        { Token::GLOBAL_LABLE,"Global Lable", 0,0,Processor::ALL,NULL,0 },
        //-------- Registers -------------
        { Token::AREG,"A", 0,0, Processor::ALL,NULL,0 },
        { Token::XREG,"X", 0,0, Processor::ALL,NULL,0 },
        { Token::YREG,"Y", 0,0, Processor::ALL,NULL,0 },
        { Token::SPREG,"S", 0,0, Processor::ALL,NULL,0 },
        { Token::PSREG,"P", 0,0, Processor::ALL,NULL,0 },
        { Token::AREG,"a", 0,0, Processor::ALL,NULL,0 },
        { Token::XREG,"x", 0,0, Processor::ALL,NULL,0 },
        { Token::YREG,"y", 0,0, Processor::ALL,NULL,0 },
        { Token::SPREG,"s", 0,0, Processor::ALL,NULL,0 },
        { Token::PSREG,"p", 0,0, Processor::ALL,NULL,0 },
        //--------- Status Register Bits -------------
        { Token::NEG,"N" },
        { Token::ZERO,"Z" },
        {Token::CARRY,"C"},
        {Token::OVERFLOW,"O"},
        {Token::DECIMAL_MODE,"D"},
        {Token::IRQENABLE,"I"},
        //-------- Processor Selection -------
        { Token::PROCESSOR,"PROCESSOR", 0,0,Processor::ALL,NULL,0 },
        { Token::R6502,"R6502", 0,0, Processor::ALL,NULL,0 },
        { Token::WD65C02,"WD65C02", 0,0, Processor::ALL ,NULL,0 },
        { Token::WD65C816,"WD65C816", 0,0, Processor::ALL,NULL,0 },
        //----------------------------------
        // Misc
        //----------------------------------
        { Token::EPROC,"EPROC", 0 },
        {Token::CHAR_CONSTANT,"Character Constant"},
        { Token('('),"(", 0 },
        { Token(')'),")", 0 },
        { Token('{'),"{", 0 },
        { Token('}'),"}", 0 },
        { Token('['),"[", 0 },
        { Token(']'),"]", 0 },
        { Token('<'),"<", 0 },
        { Token('>'),">", 0 },
        { Token('!'),"!", 0 },
        { Token('@'),"@", 0 },
        { Token('#'),"#", 0 },
        { Token('$'),"$", 0 },
        { Token('%'),"%", 0 },
        { Token('^'),"^", 0 },
        { Token('&'),"&", 0 },
        { Token('*'),"*", 0 },
        { Token('-'),"-", 0 },
        { Token('='),"=", 0 },
        { Token('+'),"+", 0 },
        { Token(','),",", 0 },
        { Token('.'),".", 0 },
        { Token('/'),"/", 0 },
        { Token('?'),"?", 0 },
        { Token('~'),"~", 0 },
        {Token::ENDOFTOKENS,NULL}
    };
    CSymTab m_SymbolTable;
    int m_UngetBuffer;
    char m_aLexBuff[256];
    int m_LexBuffIndex;
    int m_Line;
    int m_Col;
    int m_Number;
    CSymbol* m_pLexSymbol;
    char* m_pFileBuffeer;
    int m_InFileSize;
    int m_FileIndex;
    bool m_bAsmMode;
public:
    CLexer();
    virtual ~CLexer();
    bool Create();
    FILE* LogFile();
    bool IsAsmMode() { return m_bAsmMode; }
    void SetActionMode() { m_bAsmMode = false; }
    void SetAsmMode() { m_bAsmMode = true; }
    int LexGet();
    int LexLook(int index);
    void LexUnGet(int c);
    bool IsValidHexNumber(int c);
    bool IsValidNumber(int c);
    bool IsValidNameChar(int c);
    bool IsWhiteSpace(int c);
    bool IsValidAssignmentOperator(int c);
    Token Lex();
    //------------------------------------------
    // Symbol Table Methods
    //------------------------------------------
    CBin* LookupSymbol(const char* pName);
    CSymTab* GetSymTab() { return &m_SymbolTable; }
    //------------------------------------------
    // Keyword Lookup Methods
    //------------------------------------------
    Token LookupKeyword(const char* pKeyword);
    KeyWord* FindKeyword(Token KeywordToken);
    Processor LookupProcessor(Token KeywordToken);
    int LookupOpcode(Token OpcodeToken);
    int GetOpcode(Token OpCodeToken);
    KeyWord* GetKeyWords() { return KeyWords; }
    //--------------------------------------
    // Symbol Methods
    //--------------------------------------
    CSymbol* GetLexSymbol() { return m_pLexSymbol; }
    int GetNumber() { return m_Number; }
    char* GetLexBuffer() { return m_aLexBuff; }
    int GetLineNumber() { return m_Line; }
    int GetColunm() { return m_Col; }
};


 ---------- LHead.h -------------
#pragma once

class CLHead
{
public:
    Token m_Token;
    CAstNode* m_pNode;
public:
    CLHead();
    CLHead(Token T, CAstNode* pN) {
        m_Token = T;
        m_pNode = pN;
    }
    virtual ~CLHead();
    bool Create();
    void SetToken(Token T) { m_Token = T; }
    Token GetToken() { return m_Token; }
    void SetNode(CAstNode* pN) { m_pNode = pN; }
    CAstNode* GetNode() {
        return m_pNode;
    }
    void operator=(const CLHead & pLH);
};


 ---------- NumberStackItem.h -------------
#pragma once

class CSymbol;

class CNumberStackItem :public CStackItem
{
    int m_Value;
    CSymbol* m_pSymbol;
public:
    CNumberStackItem();
    virtual ~CNumberStackItem();
    bool Create();
    void SetValue(int v) { m_Value = v; }
    int GetValue() { return m_Value; }
    CSymbol* GetSymbol() { return m_pSymbol; }
    void SetSymbol(CSymbol* pSym) { m_pSymbol = pSym; }
    //--------------------------------
    //    Operations
    //--------------------------------
    void Neg() { m_Value = -m_Value; }
    void Add(CNumberStackItem* pOperand) { m_Value += pOperand->GetValue(); }
    void Sub(CNumberStackItem* pOperand) { m_Value -= pOperand->GetValue(); }
};

#define VALUE(x)    ((CNuberStackItem *)(x))
 ---------- ObjFormatCode.h -------------
#pragma once

class CObjFormatCode : public CObjFormatSectionItem
{
    unsigned short m_BlockSize;
    unsigned short m_StartAddress;
    char* m_pCode;
public:
    CObjFormatCode();
    virtual ~CObjFormatCode();
    bool Create(int StartAddress, int BlockSize, const char* pCode);
    virtual void Out(FILE* pOut);
    virtual void Print(FILE* pO, int Indent);
};


 ---------- ObjFormatData.h -------------
#pragma once

class CObjFormatData : public CObjFormatSectionItem
{
    int m_BlockSize;
    int m_Index;
    char* m_pData;
public:
    CObjFormatData();
    virtual ~CObjFormatData();
    bool Create(int BlockSize);
    virtual void Out(FILE* pOut);
    virtual void Print(FILE* pO, int Indent);
    bool AddByte(char d);
};


 ---------- ObjFormatFile.h -------------
#pragma once

class CObjFormatFile
{
    char m_strName[512];
    CObjFormatSection* m_pHead;
    CObjFormatSection* m_pTail;
public:
    CObjFormatFile();
    virtual ~CObjFormatFile();
    bool Create(const char* pName);
    CSymTab* GetSymTab();
    char* GetObjectName() { return m_strName; }
    //-------------------------------------------------
    CObjFormatSection* GetHead() { return m_pHead; }
    void SetHead(CObjFormatSection* pHead) { m_pHead = pHead; }
    CObjFormatSection* GetTail() { return m_pTail; }
    void SetTail(CObjFormatSection* pT) { m_pTail = pT; };
    //-------------------------------------------------
    virtual void Print(FILE* pO);
    virtual void Out(FILE* pO);
    //-------------------------------------------------
    void AddSection(CSection* pSection);
    void AddObjFormatSection(CObjFormatSection* pAOFS);
};


 ---------- ObjFormatRelocation.h -------------
#pragma once

class CObjFormatRelocation : public CObjFormatSectionItem
{

public:
    CObjFormatRelocation();
    virtual ~CObjFormatRelocation();
    bool Create();
    virtual void Out(FILE* pO);
    virtual void Print(FILE* pO, int Indent);
};


 ---------- ObjFormatSection.h -------------
#pragma once

class CObjFormatSection
{
    struct SObjSectionData {
        //-----------------------------------------------
        //    SECTION, \0        8 Bytes
        //    < Section Name>    32 bytes, 0 terminated
        //    < Attributes        2 bytes
        //    < Section Token>    2 bytes
        //    < File Offset From 0 of data>    4 bytes
        //-----------------------------------------------
        char m_BlockTypeName[8];
        char m_SectionName[32];
        unsigned short m_Attributes;
        unsigned short m_SectionToken;
        unsigned m_FileOffset;
        SObjSectionData() {
            int i;

            m_Attributes = 0;
            m_SectionToken = 0;
            m_FileOffset = 0;
            strcpy_s(m_BlockTypeName, 8, "SECTION");
            for (i = 0; i < 32; ++i)
                m_SectionName[i] = 0;
        }
    };
    CSection* m_pSection;
    CObjFormatSection* m_pNext;
    CObjFormatSection* m_pPrev;
    CObjFormatSectionItem* m_pHead;
    CObjFormatSectionItem* m_pTail;
public:
    CObjFormatSection();
    virtual ~CObjFormatSection();
    bool Create(CSection* pSection);
    CSection* GetSection() { return m_pSection; }
    //--------------------------------------------------
    CObjFormatSectionItem* GetHead() { return m_pHead; }
    void SetHead(CObjFormatSectionItem* pH) { m_pHead = pH; }
    CObjFormatSectionItem* GetTail() { return m_pTail; }
    void SetTail(CObjFormatSectionItem* pT) { m_pTail = pT; }
    //---------------------------------------------------
    void AddItem(CObjFormatSectionItem* pItem);
    //-------------------------------------------------
    virtual void Print(FILE* pO, int Indent);
    virtual void Out(FILE* pO);
    //------------------------------------------------
    void SetNext(CObjFormatSection* pN) { m_pNext = pN; }
    CObjFormatSection* GetNext() { return m_pNext; }
    void SetPrev(CObjFormatSection* pP) { m_pPrev = pP; }
    CObjFormatSection* GetPrev() { return m_pPrev; }
};


 ---------- ObjFormatSectionItem.h -------------
#pragma once

class CObjFormatSectionItem

{
public:
    enum class FormatType {
        NONE,
        CODE,
        DATA,
        RELOCATIONTABEL,
        SYMBOLS,
        SYMBOL
    };
private:
    struct FormatTypeLUT {
        FormatType m_LutType;
        const char* m_pLutString;
    };
    inline static const FormatTypeLUT FormatStringLUT[] = {
        {FormatType::NONE, "NONE"},
        {FormatType::CODE, "CODE"},
        {FormatType::DATA, "DATA"},
        {FormatType::RELOCATIONTABEL, "RELOCATION TABEL"},
        {FormatType::SYMBOLS, "SYMBOL Table"},
        {FormatType::SYMBOL, "SYMBOL"},
        {FormatType(-1), NULL},
    };
    FormatType m_Type;
    CObjFormatSectionItem* m_pNext;
    CObjFormatSectionItem* m_pPrev;
public:
    CObjFormatSectionItem();
    virtual ~CObjFormatSectionItem();
    bool Create(FormatType Type);
    CObjFormatSectionItem* GetNext() { return m_pNext; }
    void SetNext(CObjFormatSectionItem* pN) { m_pNext = pN; }
    CObjFormatSectionItem* GetPrev() { return m_pPrev; }
    void SetPrev(CObjFormatSectionItem* pP) { m_pPrev = pP; }
    virtual void Out(FILE* pOut);
    virtual void Print(FILE* pO, int Indent);
    static const char* LookupFormatSectionType(FormatType Type);
    static FormatType LookupFormatSectionType(const char* pName);
};


 ---------- ObjFormatSymbolItem.h -------------
#pragma once

class CObjFormatSymbolItem : public CObjFormatSectionItem
{
    char m_strName[MAX_SYMBOL_NAME_LEN];
    unsigned m_DefinedAddress;
public:
    CObjFormatSymbolItem();
    virtual ~CObjFormatSymbolItem();
    bool Create(CSymbol* pSym);
    virtual void Out(FILE* pOut);
    virtual void Print(FILE* pO);
};


 ---------- ObjFormatSymbols.h -------------
#pragma once

class CObjFormatSymbols : public CObjFormatSectionItem
{
    CObjFormatSymbolItem* m_pHead;
    CObjFormatSymbolItem* m_pTail;
public:
    CObjFormatSymbols();
    virtual ~CObjFormatSymbols();
    bool Create();
    virtual void Print(FILE* pO, int Indent);
    virtual void Out(FILE* pO);
    virtual void Add(CObjFormatSymbolItem pSym);
};


 ---------- ObjType.h -------------
#pragma once

class CObjType
{
public:
    enum class Spec {
        NONE,
        BYTE,
        CHAR,
        INT,
        CARD,
        BOOL,
        TYPEDEF,
        ARRAY,
        POINTER,
        PROC,
        FUNC
    };
private:
    struct Types {
        Spec m_SpecType;
        const char* m_pName;
        Types() {
            m_SpecType = Spec::NONE;
            m_pName = 0;
        }
        Types(Spec T, const char* pName) {
            m_SpecType = T;
            m_pName = pName;
        }
        static const char* FindName(Spec T);
    };
    static inline Types TypesLUT[] = {
        {Spec::NONE,"NONE"},
        {Spec::BYTE,"BYTE"},
        {Spec::CHAR,"CHAR"},
        {Spec::INT,"INT"},
        {Spec::CARD,"CARD"},
        {Spec::BOOL,"BOOL"},
        {Spec::TYPEDEF,"TYPEDEF"},
        {Spec::ARRAY,"ARRAY"},
        {Spec::POINTER,"POINTER"},
        {Spec::PROC,"PROC"},
        {Spec::FUNC,"FUNC"},
        {Spec(-1),0}
    };
    Spec m_SpecType;
    CObjType* m_pNext;
    CObjType* m_pPrev;
public:
    CObjType();
    virtual ~CObjType();
    bool Create();
    const char* FindName(Spec T) {
        return Types::FindName(T);
    }
    CObjType* GetNext() { return m_pNext; }
    void SetNext(CObjType* pN) { m_pNext = pN; }
    CObjType* GetPrev() { return m_pPrev; }
    void SetPrev(CObjType* pP) { m_pPrev = pP; }
};


 ---------- Parser.h -------------
#pragma once

//-------------------------------------
// Allowed Addressing Modes
//-------------------------------------

constexpr auto ADR_MODE_ABSOLUTE = 0x0001;
constexpr auto ADR_MODE_ABSOLUTE_X = 0x0002;
constexpr auto ADR_MODE_ABSOLUTE_Y = 0x0041;
constexpr auto ADR_MODE_ZEROPAGE = 0x0008;
constexpr auto ADR_MODE_ZEROPAGE_X = 0x0010;
constexpr auto ADR_MODE_ZEROPAGE_Y = 0x0020;
constexpr auto ADR_MODE_IMMEDIATE = 0x0040;
constexpr auto ADR_MODE_INDIRECT_Y = 0x0080;
constexpr auto ADR_MODE_INDIRECT_X = 0x0100;
constexpr auto ADR_MODE_INDIRECT = 0x0200;
constexpr auto ADR_MODE_RELATIVE = 0x0400;
constexpr auto ADR_MODE_ACCUMULATOR = 0x0800;
constexpr auto ADR_MODE_IMPLIED = 0x1000;

class CParser
{
public:
    enum class PHASE {
        NONE,
        GENERATE_AST,
        EXECUTE_AST_PASS1,
        EXECUTE_AST_PASS2,
        GENTERATE_OUT_FILES
    };
private:
    struct PHASE_LUT {
        PHASE m_Phase;
        const char* m_pName;
        const char* LookupPhaseName(PHASE phase);
        PHASE LookupPhaseToken(const char* pName);
    };
    static inline PHASE_LUT ParsePhase[4] = {
        {PHASE::GENERATE_AST,"GENERATE_AST"},
        {PHASE::EXECUTE_AST_PASS1,"EXECUTE_AST_PASS1"},
        {PHASE::EXECUTE_AST_PASS2,"EXECUTE_AST_PASS2"},
        {PHASE::GENTERATE_OUT_FILES,"GENTERATE_OUT_FILES"},
    };
    CLexer* m_pLex;
    PHASE m_Phase;            // Phase of the compiler operation
    CSection* m_pCurrentSection;
    Processor m_Processor;
    int m_Recursion;
    int m_Bump;
    CActionAstTree m_AstTree;
    CStack m_ValueStack;
public:
    CParser();
    virtual ~CParser();
    bool Create();
    CStack* GetValueStack() { return &m_ValueStack; }
    void SetCurrentSection(CSection* pSection) {
        m_pCurrentSection = m_pCurrentSection;
    }
    CSection* GetCurrentSection() {
        return m_pCurrentSection;
    }
    CLexer* GetLexer() { return m_pLex; }
    CActionAstTree* GetAstTree() { return &m_AstTree; }
    FILE* LogFile();
    CLHead Run();
    //---------------------------------
    Token Expect(Token LookaheadToken, Token Expected);
    bool Accept(Token LookaheadToken, Token Expected);
private:
    void PrepareInstruction(CInstruction** ppInst, Token Op);
    //---------------------------------
    // Parsing Methods
    //---------------------------------
    // Program Structure
    //---------------------------------
    CLHead Action65(CLHead LookaHead);
    CLHead Modules(CLHead LookaHead);
    CLHead Vector(CLHead LookaHead);
    CLHead VectorAddress(CLHead LookaHead);
    //------------------------------------------
    // Statements
    //------------------------------------------
    CLHead Statements(CLHead LookaHead);
    CLHead ProcParams(CLHead LookaHead);
    //----FOR
    CLHead ForStmt(CLHead LookaHead);
    CLHead STEPoption(CLHead LookaHead);
    CLHead ForTO(CLHead LookaHead);
    CLHead Iterator(CLHead LookaHead);
    //--- IF
    CLHead IfStmt(CLHead LookaHead);
    CLHead EndIf(CLHead LookaHead);
    CLHead ElsePart(CLHead LookaHead);
    CLHead ElseIfPart(CLHead LookaHead);
    CLHead ThenPart(CLHead LookaHead);
    //----IFF
    CLHead IffStmt(CLHead LookaHead);
    CLHead IFFend(CLHead LookaHead);;
    CLHead IFFelse(CLHead LookaHead);;
    CLHead IFFthenpart(CLHead LookaHead);;
    CLHead IffConditional(CLHead LookaHead);;
    CLHead RelOper(CLHead LookaHead);;
    CLHead StatusFlags(CLHead LookaHead);;
    CLHead OptNot(CLHead LookaHead);;
    CLHead BitValue(CLHead LookaHead);;
    CLHead Bits(CLHead LookaHead);;
    //----WHILE
    CLHead WhileStmt(CLHead LookaHead);
    //----DO
    CLHead DoStmt(CLHead LookaHead);
    CLHead DoEND(CLHead LookaHead);
    //----EXIT
    CLHead EXITstmt(CLHead LookaHead);
    //----RETURN
    CLHead RetStmt(CLHead LookaHead);
    CLHead OptReturnValue(CLHead LookaHead);
    //----ASM
    CLHead InlineAssembly(CLHead LookaHead);
    CLHead InlineAssBlock(CLHead LookaHead);
    CLHead EndAsmBlock(CLHead LookaHead);
    //----CODE BLOCK
    CLHead CodeBlock(CLHead LookaHead);
    CLHead CodeBlockEnd(CLHead LookaHead);
    //---- UNTIL
    CLHead UntillStmt(CLHead LookaHead);
    //---- PUSH
    CLHead Push(CLHead LookaHead);
    CLHead PushSourceList(CLHead LookaHead);
    CLHead PushSource(CLHead LookaHead);
    //---- POP
    CLHead Pop(CLHead LookaHead);
    CLHead PopDestList(CLHead LookaHead);
    CLHead PopDest(CLHead LookaHead);
    //---- BREAK
    CLHead Break(CLHead LookaHead);
    //---- RTI
    CLHead Rti(CLHead LookaHead);
    //---- Assogmemt
    CLHead Assignment(CLHead LookaHead);
    //--------------------------------------
    // Logical Expressions
    //--------------------------------------
    CLHead RelOperation(CLHead LookaHead);
    CLHead LogicalOR(CLHead LookaHead);
    CLHead LogicalAND(CLHead LookaHead);
    //--------------------------------------
    // Arithmetic Expressions
    //--------------------------------------
    CLHead ArithExpr(CLHead LookaHead);    //bitwise OR
    CLHead BitwiseAND(CLHead LookaHead);
    CLHead BitwiseXOR(CLHead LookaHead);
    CLHead AddExpr(CLHead LookaHead);
    CLHead ShifExpr(CLHead LookaHead);
    CLHead MultExpr(CLHead LookaHead);
    CLHead Unary(CLHead LookaHead);
    CLHead Factor(CLHead LookaHead);

    //-------------------------------------------
    // Declarations
    //-------------------------------------------
    CLHead SysDecl(CLHead LookaHead);
    CLHead DefList(CLHead LookaHead);
    CLHead Def(CLHead LookaHead);
    //--------------------------------------
    // TYPEdef Definition
    //--------------------------------------
    CLHead TypeDefDecl(CLHead LookaHead);
    CLHead EndTypeDef(CLHead LookaHead);
    CLHead RecDefField(CLHead LookaHead);
    //----------------------------------------
    // Fundamental Declarations
    //----------------------------------------
    CLHead FundDecl(CLHead LookaHead);
    CLHead FundPointerDecl(CLHead LookaHead);
    CLHead FundArrayDecl(CLHead LookaHead);
    CLHead FunctionDecl(CLHead LookaHead);
    CLHead IrqDef(CLHead LookaHead);
    CLHead ProcDef(CLHead LookaHead);
    CLHead FuncDef(CLHead LookaHead);
    CLHead IrqDecl(CLHead LookaHead);
    CLHead ProcDecl(CLHead LookaHead);
    CLHead FuncDecl(CLHead LookaHead);
    CLHead IrqBody(CLHead LookaHead);
    CLHead ProcBody(CLHead LookaHead);
    CLHead FuncBody(CLHead LookaHead);
    CLHead OptInit(CLHead LookaHead);
    //----------------------------------
    // Identifiers
    //----------------------------------
    CLHead IdentList(CLHead LookaHead);
    CLHead Ident(CLHead LookaHead);
    CLHead IdentInit(CLHead LookaHead);
    CLHead Address(CLHead LookaHead);
    CLHead Data(CLHead LookaHead);
    CLHead ArrayDim(CLHead LookaHead);
    //-------------------------------------------
    // Parameter Declarations
    //-------------------------------------------
    CLHead ParamList(CLHead LookaHead);
    CLHead PramPointer(CLHead LookaHead);
    CLHead ParamArray(CLHead LookaHead);
    //-----------------------------------------------
    // Local Variableas
    //-----------------------------------------------
    CLHead LocalDecls(CLHead LookaHead);
    CLHead LocalPointerDecl(CLHead LookaHead);
    CLHead LocalArrayDecl(CLHead LookaHead);
    //-------------------------------
    // Compiler Constants
    //-------------------------------
    CLHead ConstList(CLHead LookaHead);
    CLHead CompConst(CLHead LookaHead);
    CLHead BaseCompConst(CLHead LookaHead);
    //----------------------------------
    //Variable References
    //Memory References
    //----------------------------------
    CLHead ValueList(CLHead LookaHead);
    CLHead Value(CLHead LookaHead);
    CLHead AddressOf(CLHead LookaHead);
    CLHead MemContentsType(CLHead LookaHead);
    CLHead MemContents(CLHead LookaHead);
    //****************************************
    //----------------------------------------
    //  Inline assembly code
    //----------------------------------------
    //    Statements
    //----------------------------------------
    //****************************************
    CLHead AsmStmt(CLHead LookaHead);
    CLHead Processor_1(CLHead LookaHead);
    CLHead ProcessorType(CLHead LookaHead);
    //-----------------------------------------
    // Code
    //        These statements are what actually
    // do something that concerns the machine
    // code that is executed
    //-----------------------------------------

    //-----------------------------------------
    // SECITON
    //-----------------------------------------
    CLHead Section(CLHead LookaHead);
    CLHead SectionName(CLHead LookaHead);
    CLHead SectionDef(CLHead LookaHead);
    CLHead SectionAttributesList(CLHead LookaHead);
    CLHead SectionAtribute(CLHead LookaHead);
    CLHead Modes(CLHead LookaHead);
    CLHead TrueFalse(CLHead LookaHead);
    //-------------------------------------
    // Org  Sets the location counter
    // for the current section
    //-------------------------------------
    CLHead Org(CLHead LookaHead);
    //-------------------------------------
    // Define Memeory
    //-------------------------------------
    CLHead DefineMemory(CLHead LookaHead);
    //-------------------------------------
    // DefineStorage
    //-------------------------------------
    CLHead DefineStorage(CLHead LookaHead);
    //-------------------------------------
    // Proceedure
    //-------------------------------------
    CLHead Proceedure(CLHead LookaHead);
    //--------------------------------------
    // Opcodes
    //--------------------------------------
    CLHead Instruction(CLHead LookaHead);
    //---------------------------------------------
    // Lables
    //---------------------------------------------
    CLHead Labels(CLHead LookaHead);
    CLHead LocalGlobal(CLHead LookaHead);
    //-----------------------------------
    //ALU Addressing Mode
    //-----------------------------------
    CLHead AluAdrModes(CLHead LookaHead);
    CLHead Indirect(CLHead LookaHead);
    //---------------------------------------------
    // STA addressing mode
    //---------------------------------------------
    CLHead StaAddressingModes(CLHead LookaHead);
    //-----------------------------------------
    // ASL LSR ROR and ROL addressing modes
    //-----------------------------------------
    CLHead ShiftAddressingModes(CLHead LookaHead);
    //------------------------------------------
    // Branch Instructions Addressing Mode
    //------------------------------------------
    CLHead RelAddressingMode(CLHead LookaHead);
    //------------------------------------------
    // BIT Instructions Addressing Mode
    //------------------------------------------
    CLHead BitAddressModes(CLHead LookaHead);
    //------------------------------------------
    // INC DEC Instructions Addressing Mode
    //------------------------------------------
    CLHead IncAddressingMOdes(CLHead LookaHead);
    //------------------------------------------
    // JMP Instructions Addressing Mode
    //------------------------------------------
    CLHead JumpAddressingModes(CLHead LookaHead);
    //------------------------------------------
    // JSR Instructions Addressing Mode
    //------------------------------------------
    CLHead CallAddressingMode(CLHead LookaHead);
    //------------------------------------------
    // LDX Instructions Addressing Mode
    //------------------------------------------
    CLHead LdxAddressingMode(CLHead LookaHead);
    //------------------------------------------
    // CPX & CPY Instructions Addressing Mode
    //------------------------------------------
    CLHead CPX_CPY_AddressingMode(CLHead LookaHead);
    //------------------------------------------
    // STX Instructions Addressing Mode
    //------------------------------------------
    CLHead StxAddressingMode(CLHead LookaHead);
    //------------------------------------------
    // LDY Instructions Addressing Mode
    //------------------------------------------
    CLHead LdyAddressingMode(CLHead LookaHead);
    //------------------------------------------
    // STY Instructions Addressing Mode
    //------------------------------------------
    CLHead StyAddressingMode(CLHead LookaHead);
    //---------------------------------------------
    //    Optional Index Registers
    //---------------------------------------------
    CLHead OptIndexReg(CLHead LookaHead);
    CLHead OptIndexReg_1(CLHead LookaHead);
    CLHead OptXReg(CLHead LookaHead);
    CLHead OptYReg(CLHead LookaHead);
    //---------------------------------------
    // Assembler Constants
    //---------------------------------------
    CLHead AsmConstList(CLHead LookaHead);
    CLHead AsmConstList_1(CLHead LookaHead);
    CLHead AsmConstant(CLHead LookaHead);
    CLHead AsmConstAddSub(CLHead LookaHead);
    CLHead BaseAsmConstant(CLHead LookaHead);
    CLHead Immediate(CLHead LookaHead, CInstruction* pInst);
    void PageZero(CInstruction* pInst, int Address, AdrModeType ModeType);
    void Absolute(CInstruction* pInst, int Address, AdrModeType ModeType);
    bool CheckZeroPageAddress(int A);
    //---------------- Utillity ----------------------
    void PrintLookahead(
        FILE* pLog,
        CLHead token,
        const char* pS,
        int RecursionLevel,
        int Bump = 0
    );
    //---------------------------------
};


 ---------- pch.h -------------
#ifndef  PCH__H
#define PCH__H

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <sys\stat.h>
#include <sys\types.h>

constexpr auto MAX_SYMBOL_NAME_LEN = 256;
constexpr auto MAX_NAME_LEN = 64;
constexpr auto MAX_STRING_LEN = 512;

enum  class Token {
    ENDOFFILE = -1,    // 1
    IDENT = 256,    //2
    STRING,            //3
    NUMBER,            //4
    //------ Assignment
    ASSIGN_ADD,        //5
    ASSIGN_SUB,        //6
    ASSIGN_MUL,        //7
    ASSIGN_DIV,        //8
    ASSIGN_MOD,        //9
    ASSIGN_AND,        //10
    ASSIGN_OR,
    ASSIGN_XOR,
    ASSIGN_RSH,
    ASSIGN_LSH,
    //------- Operators
    MOD,
    LSH,
    RSH,
    GTEQ,
    LTEQ,
    OR,        //logical OR
    XOR,    //bitwise Exclusive OR
    //-------- Functions --------
    PROC,
    FUNC,
    INTERRUPT,
    INTERRUPT_IDENT,
    FUNC_IDENT,
    PROC_IDENT,
    //------ Data Types -----------------
    BOOL,
    BYTE,
    CHAR,
    INT,
    CARD,
    POINTER,
    TYPE,
    RECORDTYPE,
    ARRAY,
    //--------Statements----------
    MODULE,
    VECTOR,
    FOR,
    TO,
    STEP,
    IF,
    IFF,
    THEN,
    ELSEIF,
    ELSE,
    FI,
    FFI,
    WHILE,
    DO,
    OD,
    UNTIL,
    EXIT,
    RETURN,
    ASM,
    PUSH,
    POP,
    BREAK,
    BITS,
    BEGIN,
    END,
    // Compiler Directives
    DEFINE,
    SET,
    INCLUDE,
    //---------- Assembler Tokens ------------
    //--------- Section --------
    SECTION,
    SECTION_NAME,
    START,
    SIZE,
    NAME,
    MODE,
    READ_WRTE,
    READ_ONLY,
    ZEROPAGE,
    True,
    False,
    //----- Assembler declarators
    ORG,
    DB,
    DW,
    DL,
    DAS,    //define action! string
    DCS,    //define C String
    DS,        //define storage
    //------- Opcodes
    ADC,
    AND,    //Logical Action AND or ASM Opcode
    ASL,
    BCC,
    BCS,
    BEQ,
    BMI,
    BNE,
    BPL,
    BVC,
    BVS,
    BIT,
    BRK,
    CLC,
    CLD,
    CLI,
    CLV,
    CMP,
    CPX,
    CPY,
    DEC,
    DEX,
    DEY,
    EOR,
    INC,
    INX,
    INY,
    JMP,
    JSR,
    LDA,
    LDX,
    LDY,
    LSR,
    NOP,
    ORA,
    PHA,
    PLA,
    PHP,
    PLP,
    ROL,
    ROR,
    RTI,
    RTS,
    SBC,
    STA,
    SEC,
    SED,
    SEI,
    STX,
    STY,
    TAX,
    TAY,
    TXA,
    TYA,
    TXS,
    TSX,
    ENDOFOPCODES,
    //----- Registers
    AREG,        //accumulator
    XREG,
    YREG,
    SPREG,        //stack pointer
    PSREG,        //processor status register
    //---------- Lables 
    LOCAL_LABEL,
    GLOBAL_LABLE,
    //-------- Status Register bits
    NEG,
    ZERO,
    CARRY,
    OVERFLOW,
    IRQENABLE,
    DECIMAL_MODE,
    //------- Processor Selector
    PROCESSOR,
    R6502,
    WD65C02,
    WD65C816,
    //------- Misc
    CHAR_CONSTANT,
    EPROC,        // proceedure end
    EOL,
    //------------------------
    ENDOFTOKENS = 0
};



enum class IdentType {
    NEW_SYMBOL,
    LABEL,
    PROC,
    FUNC,
    FUNC_BYTE,
    FUNC_CHAR,
    FUNC_CARD,
    FUNC_INT,
    FUNC_POINTER_BYTE,
    FUNC_POINTER_CHAR,
    FUNC_POINTER_CARD,
    FUNC_POINTER_INT,
    MEM_GLOBAL_BYTE,
    MEM_GLOBAL_CHAR,
    MEM_GLOBAL_CARD,
    MEM_GLOBAL_INT,
    MEM_GLOBAL_POINTER_BYTE,
    MEM_GLOBAL_POINTER_CHAR,
    MEM_GLOBAL_POINTER_CARD,
    MEM_GLOBAL_POINTER_INT,
    MEM_PARAM_BYTE,
    MEM_PARAM_CHAR,
    MEM_PARAM_CARD,
    MEM_PARAM_INT,
    MEM_PARAM_POINTER_BYTE,
    MEM_PARAM_POINTER_CHAR,
    MEM_PARAM_POINTER_CARD,
    MEM_PARAM_POINTER_INT,
    MEM_LOCAL_BYTE,
    MEM_LOCAL_CHAR,
    MEM_LOCAL_CARD,
    MEM_LOCAL_INT,
    MEM_LOCAL_POINTER_BYTE,
    MEM_LOCAL_POINTER_CHAR,
    MEM_LOCAL_POINTER_CARD,
    MEM_LOCAL_POINTER_INT
};

enum class AdrModeType {
    NA,
    IMPLIED,
    INDIRECT_X_ADR,
    ZERO_PAGE_ADR,
    IMMEDIATE_ADR,
    ABSOLUTE_ADR,
    INDIRECT_Y_ADR,
    ZERO_PAGE_X_ADR,
    ABSOLUTE_Y_ADR,
    ABSOLUTE_X_ADR,
    ZERO_PAGE_Y_ADR,
    INDIRECT_ADR,
    ACCUMULATOR
};
enum class AddressModesClass {    //ToDo: Delete?
    IMPLIED,        //0
    ONE_MODE,        //1
    TWO_MODES,        //2
    THREE_MODES,    //3
    FOUR_MODES,        //4
    FIVE_MODES,        //5
    SIX_MODES,        //6
    SEVEN_MODES,    //7
    EIGHT_MODES        //8
};
enum class Processor {
    ALL,
    R6502,
    WD65C02,
    WD65C816
};


#include "StackItem.h"
#include "DataSizeStackItem.h"
#include "RegisterStackItem.h"
#include "Instruction.h"
#include "StackSectionItem.h"
#include "NumberStackItem.h"

#include "ObjType.h"

#include "Bin.h"
#include "WhereSymbolIsUsed.h"
#include "UnResolvedSymbol.h"
#include "Bucket.h"
#include "Symbol.h"
#include "Value.h"

constexpr auto MAX_EXCEPTION_STRING_LEN = 512;


class Exception {
public:
    enum class ExceptionType {
        WHOKNOWS,
        UNEXPECTED_TOKEN,
        SECTION_ADDRES_RANGE_EXCEEDED,
        SECTION_UNDEFINED,
        NOSECTION_DEFINED,
        LEXER_STUMPTED,
        ILLEGAL_ADDRESSING_MODE,
        TOKEN_OUT_OF_PLACE,
        VALUE_EXCEEDS_RANGE,
        STACK,
        INTERNAL_ERROR
    };
    enum class ExceptionSubType {
        WHOKNOWS,
        //--------------------
        // Stack Exceptions Subtypes
        //--------------------
        STACK_UNEXPECTED_NULL,
        STACK_EMPTY,
        STACK_ITEM_MISMATCH
    };
private:
    ExceptionType m_Type;
    ExceptionSubType m_SubType;        
    const char* m_Name;
    Token badToken;
    CBin* m_pSymbol;
    char ErrorString[MAX_EXCEPTION_STRING_LEN];
    inline static int MaxStringLen = MAX_EXCEPTION_STRING_LEN;
    //------------------------------------------------
    struct ExceptionSubTypeStrings {
        ExceptionSubType m_Type;
        const char* m_Name;
        ExceptionSubTypeStrings() {
            m_Type = ExceptionSubType::WHOKNOWS;
            m_Name = 0;
        }
        ExceptionSubTypeStrings(ExceptionSubType Type, const char* pName) {
            m_Type = Type;
            m_Name = pName;
        }
        const char* FindSubTypeString(ExceptionSubType Type);
    };
    //------------------------------------------------
    struct ExcepTypeToString {
        ExceptionType m_Type;
        const char* m_Name;
        ExcepTypeToString() {
            m_Type = ExceptionType::WHOKNOWS;
            m_Name = 0;
        }
        ExcepTypeToString(ExceptionType Type, const char* pName) {
            m_Type = Type;
            m_Name = pName;
        }
        const char* FindString(ExceptionType Type);
    };
    //-------------------------------------------------------
    inline static ExcepTypeToString ExceptionTypesLUT[] = {
        {ExceptionType:: WHOKNOWS, "WHO KNOWS, Whatever" },
        { ExceptionType::UNEXPECTED_TOKEN, "UNEXPECTED TOKEN" },
        { ExceptionType::SECTION_ADDRES_RANGE_EXCEEDED, "SECTION ADDRES RANGE EXCEEDED" },
        { ExceptionType::SECTION_UNDEFINED, "SECTION UNDEFINED" },
        { ExceptionType::NOSECTION_DEFINED, "NO SECTION DEFINED" },
        {ExceptionType::LEXER_STUMPTED, "LEXER is STUMPTED!" },
        { ExceptionType::ILLEGAL_ADDRESSING_MODE, "ILLEGAL ADDRESSING MODE" },
        { ExceptionType::TOKEN_OUT_OF_PLACE, "TOKEN OUT OF PLACE" },
        { ExceptionType::VALUE_EXCEEDS_RANGE, "VALUE EXCEEDS RANGE" },
        { ExceptionType::INTERNAL_ERROR, "This is too much, INTERNAL ERROR!" },
        { ExceptionType(-1), NULL}
    };
    //--------------------------------------------------
    inline static ExceptionSubTypeStrings XcepSubTypesLUT[] =
    {
        {ExceptionSubType::WHOKNOWS,"Who Knows, Not me!"},
        {ExceptionSubType::STACK_UNEXPECTED_NULL,"Top of Stack is NULL"},
        {ExceptionSubType::STACK_EMPTY,"Stack is Empty"},
        {ExceptionSubType::STACK_ITEM_MISMATCH,"Mismatch"},
        {ExceptionSubType(-1),0}
    };
public:
    Exception() {
        int i;

        m_Name = 0;
        m_Type = ExceptionType::WHOKNOWS;
        m_SubType = ExceptionSubType::WHOKNOWS;
        badToken = Token(0);
        m_pSymbol = 0;
        for (i = 0; i < MAX_EXCEPTION_STRING_LEN; ++i)
            ErrorString[i] = 0;
    }
    const char* GetExceptionTypeString(ExceptionType xType);
    ExceptionType GetXCeptType() { return m_Type; }
    void SetXCeptType(ExceptionType Type) { m_Type = Type; }
    Token GetGotToken() { return badToken; }
    void SetGotToken(Token t) { badToken = t; }
    char* GetErrorString() { return ErrorString; }
    int GetMaxStringLen() {
        return MaxStringLen;
    }
    void SetSymbol(CBin* pSym) { m_pSymbol = pSym; }
    CBin* GetSymbol() { return m_pSymbol; }
    const char* FindXceptnSubType(ExceptionSubType Type) {
        return XcepSubTypesLUT->FindSubTypeString(Type);
    }
    const char* FindXceptnType(ExceptionType Type) {
        return ExceptionTypesLUT->FindString(Type);
    }
};




#include "BinStackItem.h"
#include "StackSymbolItem.h"
#include "Stack.h"
#include "SymTab.h"
//--------------------------------------
// Object File Format
//--------------------------------------
#include "ObjFormatSectionItem.h"
#include "ObjFormatSymbolItem.h"
#include "ObjFormatSymbols.h"
#include "ObjFormatCode.h"
#include "ObjFormatData.h"
#include "ObjFormatRelocation.h"
#include "ObjFormatSection.h"
#include "ObjFormatFile.h"
//--------------------------------------
#include "Section.h"
//---------------------------------------
//----------------Value Stack -----------
//---------------------------------------
#include "Stack.h"
#include "StackItem.h"
#include "StackSectionItem.h"
#include "StackSymbolItem.h"
#include "AddressSizeStackItem.h"
#include "AccessModeStackItem.h"

//-------------- AST Base Class ----------
#include "AstNode.h"
//----------------------------------------
//------------- AST Node Classes ---------
//----------------------------------------
//------------ Program Structure --------------
#include "Act65Module.h"
#include "Act65VECTOR.h"
#include "Act65INTERRUPT.h"
#include "Act65PROC.h"
//----------- Declaration AST Nodes -----------
//----- Types ------
#include "Act65BYTE.h"
#include "Act65CHAR.h"
#include "Act65CARD.h"
#include "Act65BOOL.h"
#include "Act65INT.h"
#include "Act65RECTYPE.h"
#include "Act65POINTER.h"
//----- Modifiers --------------
#include "Act65ARRAY.h"
#include "Act65DEFINE.h"
#include "Act65TYPEDEF.h"

//-----------------------------------------
//---- Logical/Arithmetic AST Nodes -------
//-----------------------------------------
#include "Act65GreaterTHAN.h"
#include "Act65LessTHAN.h"
#include "Act65GTEQ.h"
#include "Act65LTEQ.h"
#include "Act65EqualTO.h"
#include "Act65NotEquelTO.h"
#include "Act65LogicalOR.h"
#include "Act65LogicalAND.h"
#include "Act65BitWiseOR.h"
#include "Act65BitWiseAND.h"
#include "Act65XOR.h"
#include "Act65ADD.h"
#include "Act65SUB.h"
#include "Act65LSH.h"
#include "Act65RSH.h"
#include "Act65ROR.h"
#include "Act65ROL.h"
//---------------------------------------------
//----------------Statement AST Nodes ---------
//---------------------------------------------
#include "Act65ProcCall.h"
#include "Act65FuncCall.h"
#include "Act65ProcParams.h"
#include "Act65FOR.h"
#include "Act65ForSTEP.h"
#include "Act65ForTO.h"
#include "Act65ForItterator.h"
#include "Act65IF.h"
#include "Act65FI.h"
#include "Act65THEN.h"
#include "Act65ELSEIF.h"
#include "Act65ELSE.h"
#include "Act65IFF.h"
#include "Act65BEGIN.h"
#include "Act65END.h"
#include "Act65FFI.h"
#include "Act65FlagNEG.h"
#include "Act65FlagCARRY.h"
#include "Act65FlagZERO.h"
#include "Act65FlagOVERFLOW.h"
#include "Act65OptNOT.h"
#include "Act65BIT.h"
#include "Act65WHILE.h"
#include "Act65DO.h"
#include "Act65OD.h"
#include "Act65EXIT.h"
#include "Act65RETURN.h"
#include "Act65ASM.h"
#include "Act65ASMstatement.h"
#include "Act65CodeBlock.h"
#include "Act65UNTILL.h"
#include "Act65PUSH.h"
#include "Act65PushSource.h"
#include "Act65POP.h"
#include "Act65PopDest.h"
#include "Act65RTI.h"
#include "Act65BREAK.h"
//--------- Assignment Node Classes ------
#include "Act65Assignment.h"
#include "Act65AssignADD.h"
#include "Act65AssignSUB.h"
#include "Act65AssignMULT.h"
#include "Act65AssignDIV.h"
#include "Act65AssignMOD.h"
#include "Act65AssignOR.h"
#include "Act65AssignAND.h"
#include "Act65AssignXOR.h"
#include "Act65AssignLSH.h"
#include "Act65AssignRSH.h"
//------------------------------------
// Assembler AST Nodes
//------------------------------------
#include "Act65PROCESSOR.h"
#include "Act65SECTION.h"
#include "Act65SecAtrbSTART.h"
#include "Act65SecAtrbSIZE.h"
#include "Act65SecAtrbMODE.h"
#include "Act65SecAtrbZEROPAGE.h"
#include "Act65SecAtrbREADONLY.h"
#include "Act65SecAtrbREADWRITE.h"
#include "Act65TRUE.h"
#include "Act65SecAtrbFALSE.h"
#include "Act65ORG.h"
#include "Act65DB.h"
#include "Act65DW.h"
#include "Act65DL.h"
#include "Act65DAS.h"
#include "Act65DCS.h"
#include "Act65DS.h"
#include "Act65ASMPROC.h"
#include "Act65EPROC.h"
#include "Act65Opcode.h"
#include "Act65Label.h"
#include "Act65Private.h"
#include "Act65XREG.h"
#include "Act65YREG.h"
#include "Act65ACC.h"
#include "Act65CharCibstabt.h"
#include "Act65LowerPart.h"
#include "Act65UpperPart.h"
#include "Act65CurrentLocation.h"
#include "ActStatusFlags.h"
//------------------------------------
#include "Act65PROCname.h"
#include "Act65IDENT.h"
//------------------------------------
#include "AstTree.h"
#include "ActionAstTree.h"

#include "LHead.h"

#include "Lexer.h"
#include "Parser.h"
#include "ActionApp.h"


extern Exception ThrownException;


#endif // ! PCH__H


 ---------- RegisterStackItem.h -------------
#pragma once

class CRegisterStackItem :  public CStackItem
{
public:
    enum RegType {
        NONE,
        X,
        Y
    };
private:
    RegType m_RegType;
public:
    CRegisterStackItem();
    virtual ~CRegisterStackItem();
    bool Create();
    RegType GetRegType() { return m_RegType; }
    void SetRegType(RegType t) { m_RegType = t; }
};


 ---------- Section.h -------------
#pragma once

class CSection : public CBin
{
public:
    enum class Mode {
        MODE_READ_ONLY,
        MODE_READ_WRITE
    };
    enum class AddressSize {
        ADDRESSSIZE_WORD,
        ADDRESSSIZE_ZEROPAGE
    };
private:
    unsigned m_StartAddress;    //where section starts in memory
    unsigned m_Size;        //max size of the memory block
    unsigned m_LocationCounter;    //current location to store data
    char* m_pSectionData;    //where the data is
    Mode m_AccessMode;    //read only or read write
    AddressSize m_ZeroPageAddressSize;
public:
    CSection();
    virtual ~CSection(); 
    bool Create();
    unsigned GetStartAddress() { return m_StartAddress; }
    void SetStartAddress(unsigned SA);
    unsigned GetSectionSize() { return m_Size; }
    void SetSectionSize(unsigned S);
    unsigned short GetLocationCounter() { return m_LocationCounter; }
    unsigned short IncrementLocationCounterBy(unsigned short v) { 
        m_LocationCounter += v;
        return m_LocationCounter;
    }
    void SetLocationCounter(unsigned short NewAddress);
    unsigned short AddData(unsigned ObjectSize, int Value);
    void AddDataAt(unsigned Adr, unsigned ObjectSize, int valu);
    unsigned short AllocateDataBlock(unsigned short size);    //define Storage
    void SetAccessMode(Mode Am) { m_AccessMode = Am; }
    CSection::Mode GetAccessMode() { return m_AccessMode; }
    void SetZeroPageFlag(AddressSize SizeFlag) { m_ZeroPageAddressSize = SizeFlag; }
    CSection::AddressSize GetZeroPageFlag() { return m_ZeroPageAddressSize; }
    virtual void Print(FILE* pOut, const char* s = 0);
    void Info();
};


 ---------- Stack.h -------------
#pragma once

class CStack
{
    static inline char m_sExceptionString[MAX_STRING_LEN];
    const char* m_pName;
    CStackItem* m_pHead;
    int m_ItemCount;
public:
    CStack();
    virtual ~CStack();
    bool Create(const char* pName);
    virtual void Push(CStackItem* pItem);
    virtual CStackItem* Pop(CStackItem::ItemType Type);
    virtual CStackItem* Look(int Depth, CStackItem::ItemType Type);
    virtual CStackItem* GetHead() { return m_pHead; }
    virtual void SetHead(CStackItem* pSI) { m_pHead = pSI; }
    virtual bool IsTopOfType(CStackItem::ItemType Type);
    virtual void Print(
        FILE* pLog, 
        const char* pName, 
        int Indent = 0,
        CStackItem* pRV = 0
    );
    void StackException(const char* pDesc, Exception::ExceptionSubType SubType);
    virtual const char* GetStackName() { return m_pName; }
    int GetItemCount() { return m_ItemCount; }
};


 ---------- StackItem.h -------------
#pragma once

class CStackItem
{
public:
    enum class ItemType {
        NONE,
        SYMBOL,
        SECTION,
        INTVALUE,
        INSTRUCTION,
        REGTYPE,
        ADDRESSSIZE,
        ACCESS_MODE,
        DATA_SIZE,
        BIN,
        NODE
    };
    struct ItemTypeLUT {
        ItemType m_Type;
        const char* m_pName;
        ItemTypeLUT() {
            m_Type = ItemType::NONE;
            m_pName = 0;
        }
        ItemTypeLUT(ItemType T, const char* s) {
            m_Type = T;
            m_pName = s;
        }
        static const char* FindItemName(CStackItem::ItemType Type);
    };
private:
    inline static ItemTypeLUT TypeString[] = {
        {ItemType::NONE,"NONE"},
        {ItemType::SYMBOL,"SYMBOL"},
        {ItemType::SECTION,"SECTION"},
        {ItemType::INTVALUE,"INT VALUE"},
        {ItemType::INSTRUCTION,"INSTRUCTION"},
        {ItemType::REGTYPE,"REGTYPE"},
        {ItemType::ADDRESSSIZE,"ADDRESS SIZE"},
        {ItemType::ACCESS_MODE,"ACCESS MODE"},
        {ItemType::DATA_SIZE,"DATA SIZE"},
        {ItemType::BIN,"BIN"},
        {ItemType::NODE,"NODE"},
        {ItemType(-1),NULL}
    };
    ItemType m_Type;
    CStackItem* m_pNext;
public:
    CStackItem();
    virtual ~CStackItem();
    bool Create(ItemType Type);
    void SetNext(CStackItem* pSI) {    m_pNext = pSI; }
    CStackItem* GetNext() { return m_pNext; }
    ItemType GetStackItemType() { return m_Type; }
    bool Verify(CStackItem::ItemType Type);
    static const char* LookupItemName(CStackItem::ItemType Type);
};


 ---------- StackNodeItem.h -------------
#pragma once

class CAstNode;

class CStackNodeItem : public CStackItem
{
    CAstNode* m_pAstNode;
public:
    CStackNodeItem();
    virtual ~CStackNodeItem();
    bool Create(CAstNode* pNode);
    void SetNode(CAstNode* pNode) { m_pAstNode = pNode; }
    CAstNode* GetNode() { return m_pAstNode; }
};


 ---------- StackSectionItem.h -------------
#pragma once

class CSection;

class CStackSectionItem : public CStackItem
{
    CSection* m_pSection;
public:
    CStackSectionItem();
    ~CStackSectionItem();
    bool Create(CSection* pSect);
    void SetSection(CSection* pSect) { m_pSection = pSect; }
    CSection* GetSection() { return m_pSection; }
};


 ---------- StackSymbolItem.h -------------
#pragma once

class CSymbol;

class CStackSymbolItem : public CStackItem
{
    CSymbol* m_pSymbol;
public:
    CStackSymbolItem();
    ~CStackSymbolItem();
    bool Create(CSymbol* pSym);
    void SetSymbol(CSymbol* pSym) { m_pSymbol = pSym; }
    CSymbol* GetSymbol() { return m_pSymbol; }
};


 ---------- Symbol.h -------------
#pragma once

constexpr auto SYMBOL_SCOPE_ANY = 0;
constexpr auto SYMBOL_SCOPE_GLOBAL = 1;
constexpr auto SYMBOL_SCOPE_LOCAKL = 2;

class CSection;

class CSymbol: public CBin
{
    unsigned m_Address;
    int m_Value;
    int m_Scope;
    CSection* m_pSection;
    IdentType m_IdentType;
    bool m_UnResolved;
    //---------------------------
    // Type Chain
    //---------------------------
    CObjType* m_pTcHead;
    CObjType* m_pTcTail;
public:
    CSymbol() {
        m_Address = 0;
        m_Value = 0;
        m_Scope = SYMBOL_SCOPE_ANY;
        m_pSection = 0;
        m_IdentType = IdentType::NEW_SYMBOL;
        m_UnResolved = true;
        m_pTcHead = 0;
        m_pTcTail = 0;
    }
    virtual ~CSymbol() {}
    bool Create() { return true; }
    virtual bool Compare(const char* name, int scope);
    virtual void Print(FILE* pOut, const char* s);
    //-----------------------------
    // Accessor Methods
    //-----------------------------
    unsigned GetAddress() { return m_Address; }
    void SetAddress(unsigned A) { m_Address = A; }
    int GetValue() { return m_Value; }
    void SetValue(int v) { m_Value = v; }
    int GetScope() { return m_Scope; }
    void SetScope(int S) { m_Scope = S; }
    CSection* GetSection() { return m_pSection; }
    void SetSection(CSection* pS) { m_pSection = pS; }
    void SetIdentType(IdentType IT) { m_IdentType = IT; }
    IdentType GetIdentType() { return m_IdentType; }
    bool IsUnResolved() {
        return m_UnResolved;
    }
    bool IsResolved() {
        return !m_UnResolved;
    }
    void SetResolved() { m_UnResolved = false; }
    void SetUnResolved() { m_UnResolved = true; }
    //-------------------------------------------------
    // Backfill unresolved references
    //-------------------------------------------------
    void BackFillUnresolved();
    //-----------------------------------
    // Type chain methods
    //-----------------------------------
    void AddAtHead(CObjType* pObjType);
    void AddAtTail(CObjType* pObjType);
    void Delete(CObjType* pObjType);
    void Unlink(CObjType* pObjType);
    void SetTcHead(CObjType* pOT) { m_pTcHead = pOT; }
    CObjType* GetTcHead() { return m_pTcHead; }
    void SetTcTail(CObjType* pOT) { m_pTcTail = pOT; }
    CObjType* GetTcTail() { return m_pTcTail; }

};


 ---------- SymTab.h -------------
#pragma once

class CSymTab
{
    int Hash(const char* name);
protected:
    int m_nElements;    //total number of elements in table
    int m_tSize;    //depth of table
    CBucket** m_ppTab;    //pointer to table
    int m_GeneralSymbolCount;
    int m_SectionSymbolCount;
public:
    CSymTab() {
        m_ppTab = 0;
        m_nElements = 0;
        m_tSize = 0;
        m_GeneralSymbolCount = 0;
        m_SectionSymbolCount = 0;
    }
    virtual ~CSymTab();
    bool Create(int TableDepth);
    int GetSectionCount() { return m_SectionSymbolCount; }
    int GetSymbolCount() { return m_GeneralSymbolCount; }
    virtual CBin* FindSymbol(const char* name, int scope);
    virtual void AddSymbol(CBin* pSym);
    virtual void DelSymbol(CBin* pSym);
    virtual void PrintTable(FILE* pOut);
    inline int GetNumElements() { return m_nElements; }
    inline int GetTableSize() { return m_tSize; }
    inline CBucket** GetTable() { return m_ppTab; }
    bool FindAll(
        CBin::BinType Type,
        int NumberOfObject,
        CBin** ppObjects
    );
};


 ---------- TreeNodeValue.h -------------

 ---------- UnResolvedSymbol.h -------------
#pragma once

class CUnResolvedSymbol: public CBin
{
    unsigned m_Address;
    CSection* m_pSection;
    CWhereSymbolIsUsed::UnResolvedType m_UnResRefType;
public:
    CUnResolvedSymbol();
    virtual ~CUnResolvedSymbol();
    bool Create();
    void SetAddress(unsigned a);
};


 ---------- Value.h -------------
#pragma once

class CValue
{
    CBin* m_pSym;
public:
    CValue();
    virtual ~CValue();
    bool Create(CBin* pSym);
    void SetSymbol(CBin* pSym) { m_pSym = pSym; }
    CBin* GetSymbol() { return m_pSym; }
};


 ---------- WhereSymbolIsUsed.h -------------
#pragma once

class CWhereSymbolIsUsed : public CBin
{
public:
    enum UnResolvedType {
        ABSOLUTE_REFERENCE,
        RELATIVE_REFERENCE
    };
private:
    struct UnResolvedSymItem {
        UnResolvedType m_Type;
        const char* m_pName;
        UnResolvedSymItem() {
            m_Type = ABSOLUTE_REFERENCE;
            m_pName = 0;
        }
        UnResolvedSymItem(UnResolvedType t, const char* pS) {
            m_Type = t;
            m_pName = pS;
        }
    };
    inline static UnResolvedSymItem UnResolvedTypeLUTLUT[2] = {
        {ABSOLUTE_REFERENCE,"ABSOLUTE REFERENCE"},
        {RELATIVE_REFERENCE,"RELATIVE REFERENCE"}
    };
    int m_Address;    //address location where found
    CSection* m_pSection;    // section block where found
    UnResolvedType m_UnResRefType;    //type of reference
public:
    CWhereSymbolIsUsed();
    virtual ~CWhereSymbolIsUsed();
    bool Create();
    void SetAddress(int a);
    int GetAddress() { return m_Address; }
    void SetSection(CSection* pS) { 
        m_pSection = pS; 
    }
    CSection* GetSection() { 
        return m_pSection; 
    }
    void SetUnResType(UnResolvedType type) { m_UnResRefType = type; }
    UnResolvedType GetUnResType() { return m_UnResRefType; }
};


 ---------- AccessModeStackItem.cpp -------------
#include "pch.h"

CAccessModeStackItem::CAccessModeStackItem()
{
    m_AccessMode = CSection::Mode::MODE_READ_WRITE;
}

CAccessModeStackItem::~CAccessModeStackItem()
{
}

bool CAccessModeStackItem::Create()
{
    return CStackItem::Create(CStackItem::ItemType::ACCESS_MODE);
}

 ---------- Act65ACC.cpp -------------
#include "pch.h"

CAct65ACC::CAct65ACC()
{
}

CAct65ACC::~CAct65ACC()
{
}

bool CAct65ACC::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild,pNext);
}

CValue* CAct65ACC::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ADD.cpp -------------
#include "pch.h"

CAct65ADD::CAct65ADD()
{
}

CAct65ADD::~CAct65ADD()
{
}

bool CAct65ADD::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ADD::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}
/*
static value* binary(NODE* n, int op)
{
    NODE* n1, * n2;        /*    child nodes    */
//    value* v1, * v2;      /*    values returned from processor nodes    */
//    value* rV = NULL;
//    value* Lv;        //left value
//
//    if (Debug) printf("BINOP=%s\n", binop_strings[op]);
//    n1 = n->down;
//    n2 = n1->next;
//    Lv = (value*)n->aux;
//    if (Lv) fprintf(stderr, "Levft Value is %s\n", Lv->name);
//    v1 = (node_proc[n1->id])(n1);        /*    process nodes    */
//    v2 = (node_proc[n2->id])(n2);
//    if (v1 && v2)    //good values?
//    {
//        //printf("VALUE1 %s  VALUE2 %s\n",v1->name,v2->name);
//        if (do_binary_const(&v1, binop_ops[op], &v2))        /*    was this a const    */
//        {
//            release_value(v2);
//            if (Debug) printf("VALUE=%d\n", v1->type->V_INT);
//            rV = v1;
//        }
//        else
//        {
//            if ((SizeOfRef(v1->type) != SizeOfRef(v2->type)) && (!IS_CONSTANT(v1->type) && !IS_CONSTANT(v2->type)))
//                //----------------------------
                //OK, these guys are not the
                //smae size and they need to
                // be in order to combine them
                //----------------------------
//                if (SizeOfRef(v1->type) > SizeOfRef(v2->type))
//                {
////                    v2 = ConvertTypeUp(OutFile, v2, v1->type);
//                    //---------------------------
//                    // this operation leaves the
////                    // in registers if v2 is not
//                    // a long. so we need to save
                    // v2 to a temp otherwise
                    //--------------------------
//                }
//                else if (SizeOfRef(v2->type) > SizeOfRef(v1->type))
////                {
//                    v1 = ConvertTypeUp(OutFile, v1, v2->type);
//                }
//            }
//            if (ValInMem(v1) && !ValInMem(v2))
//            {
//                if (NotRelOp(op))    //we can swap operands
//                {
//                    value* t;
//                    t = v1;
//                    v1 = v2;
//                    v2 = t;        //swap around the args
//                }
//                else
//                {
//                    v2 = SaveToTemp(OutFile, v2);    //put in temp
//                }
//            }
//            else if (!ValInMem(v1) && !ValInMem(v2))
//            {
//                v2 = SaveToTemp(OutFile, v2);    //put V2 in a temp
//            }
//            rV = DoBinary(OutFile, v1, op, v2, 1, 1, NULL, NULL, Lv);
            //            release_value(v2);
//        }
//    }
//    return rV;
//}

 ---------- Act65ARRAY.cpp -------------
#include "pch.h"

CAct65ARRAY::CAct65ARRAY()
{
}

CAct65ARRAY::~CAct65ARRAY()
{
}

bool CAct65ARRAY::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ARRAY::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ASM.cpp -------------
#include "pch.h"

CAct65ASM::CAct65ASM()
{
}

CAct65ASM::~CAct65ASM()
{
}

bool CAct65ASM::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ASM::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ASMPROC.cpp -------------
#include "pch.h"

CAct65ASMPROC::CAct65ASMPROC()
{
}

CAct65ASMPROC::~CAct65ASMPROC()
{
}

bool CAct65ASMPROC::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ASMPROC::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ASMstatement.cpp -------------
#include "pch.h"

CAct65ASMstatement::CAct65ASMstatement()
{
}

CAct65ASMstatement::~CAct65ASMstatement()
{
}

bool CAct65ASMstatement::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ASMstatement::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignADD.cpp -------------
#include "pch.h"

CAct65AssignADD::CAct65AssignADD()
{
}

CAct65AssignADD::~CAct65AssignADD()
{
}

bool CAct65AssignADD::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignADD::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignAND.cpp -------------
#include "pch.h"

CAct65AssignAND::CAct65AssignAND()
{
}

CAct65AssignAND::~CAct65AssignAND()
{
}

bool CAct65AssignAND::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignAND::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignDIV.cpp -------------
#include "pch.h"

CAct65AssignDIV::CAct65AssignDIV()
{
}

CAct65AssignDIV::~CAct65AssignDIV()
{
}

bool CAct65AssignDIV::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignDIV::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignLSh.cpp -------------
#include "pch.h"

CAct65AssignLSh::CAct65AssignLSh()
{
}

CAct65AssignLSh::~CAct65AssignLSh()
{
}

bool CAct65AssignLSh::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignLSh::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65Assignment.cpp -------------
#include "pch.h"

CAct65Assignment::CAct65Assignment()
{
}

CAct65Assignment::~CAct65Assignment()
{
}

bool CAct65Assignment::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65Assignment::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignMOD.cpp -------------
#include "pch.h"

CAct65AssignMOD::CAct65AssignMOD()
{
}

CAct65AssignMOD::~CAct65AssignMOD()
{
}

bool CAct65AssignMOD::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignMOD::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignMULT.cpp -------------
#include "pch.h"


CAct65AssignMULT::CAct65AssignMULT()
{
}

CAct65AssignMULT::~CAct65AssignMULT()
{
}

bool CAct65AssignMULT::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignMULT::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}


 ---------- Act65AssignOR.cpp -------------
#include "pch.h"

CAct65AssignOR::CAct65AssignOR()
{
}

CAct65AssignOR::~CAct65AssignOR()
{
}

bool CAct65AssignOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignRSH.cpp -------------
#include "pch.h"

CAct65AssignRSH::CAct65AssignRSH()
{
}

CAct65AssignRSH::~CAct65AssignRSH()
{
}

bool CAct65AssignRSH::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignRSH::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignSUB.cpp -------------
#include "pch.h"

CAct65AssignSUB::CAct65AssignSUB()
{
}

CAct65AssignSUB::~CAct65AssignSUB()
{
}

bool CAct65AssignSUB::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignSUB::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65AssignXOR.cpp -------------
#include "pch.h"

CAct65AssignXOR::CAct65AssignXOR()
{
}

CAct65AssignXOR::~CAct65AssignXOR()
{
}

bool CAct65AssignXOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65AssignXOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65BEGIN.cpp -------------
#include "pch.h"

CAct65BEGIN::CAct65BEGIN()
{
}

CAct65BEGIN::~CAct65BEGIN()
{
}

bool CAct65BEGIN::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65BEGIN::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65BIT.cpp -------------
#include "pch.h"

CAct65BIT::CAct65BIT()
{
}

CAct65BIT::~CAct65BIT()
{
}

bool CAct65BIT::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65BIT::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65BitWiseAND.cpp -------------
#include "pch.h"

CAct65BitWiseAND::CAct65BitWiseAND()
{
}

CAct65BitWiseAND::~CAct65BitWiseAND()
{
}

bool CAct65BitWiseAND::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65BitWiseAND::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65BitWiseOR.cpp -------------
#include "pch.h"

CAct65BitWiseOR::CAct65BitWiseOR()
{
}

CAct65BitWiseOR::~CAct65BitWiseOR()
{
}

bool CAct65BitWiseOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65BitWiseOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65BOOL.cpp -------------
#include "pch.h"

CAct65BOOL::CAct65BOOL()
{
}

CAct65BOOL::~CAct65BOOL()
{
}

bool CAct65BOOL::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65BOOL::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65BREAK.cpp -------------
#include "pch.h"

CActBREAK::CActBREAK()
{
}

CActBREAK::~CActBREAK()
{
}

bool CActBREAK::Create()
{
    return false;
}

CValue* CActBREAK::Process()
{
    return nullptr;
}

 ---------- Act65BYTE.cpp -------------
#include "pch.h"

CAct65BYTE::CAct65BYTE()
{
}

CAct65BYTE::~CAct65BYTE()
{
}

bool CAct65BYTE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65BYTE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65CARD.cpp -------------
#include "pch.h"

CAct65CARD::CAct65CARD()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65CARD::~CAct65CARD()
{
}

bool CAct65CARD::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65CARD::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65CHAR.cpp -------------
#include "pch.h"

CAct65CHAR::CAct65CHAR()
{
}

CAct65CHAR::~CAct65CHAR()
{
}

bool CAct65CHAR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65CHAR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;

}

 ---------- Act65CharCibstabt.cpp -------------
#include "pch.h"

CAct65CharConstant::CAct65CharConstant()
{
}

CAct65CharConstant::~CAct65CharConstant()
{
}

bool CAct65CharConstant::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65CharConstant::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65CodeBlock.cpp -------------
#include "pch.h"

CAct65CodeBlock::CAct65CodeBlock()
{
}

CAct65CodeBlock::~CAct65CodeBlock()
{
}

bool CAct65CodeBlock::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65CodeBlock::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65CurrentLocation.cpp -------------
#include "pch.h"

CAct65CurrentLocation::CAct65CurrentLocation()
{
}

CAct65CurrentLocation::~CAct65CurrentLocation()
{
}

bool CAct65CurrentLocation::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65CurrentLocation::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65DAS.cpp -------------
#include "pch.h"

CAct65DAS::CAct65DAS()
{
}

CAct65DAS::~CAct65DAS()
{
}

bool CAct65DAS::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65DAS::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65DCS.cpp -------------
#include "pch.h"

CAct65DCS::CAct65DCS()
{
}

CAct65DCS::~CAct65DCS()
{
}

bool CAct65DCS::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65DCS::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65DEFINE.cpp -------------
#include "pch.h"

CAct65DEFINE::CAct65DEFINE()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65DEFINE::~CAct65DEFINE()
{
}

bool CAct65DEFINE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65DEFINE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65DL.cpp -------------
#include "pch.h"

CAct65DL::CAct65DL()
{
}

CAct65DL::~CAct65DL()
{
}

bool CAct65DL::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65DL::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65DO.cpp -------------
#include "pch.h"

CAct65DO::CAct65DO()
{
}

CAct65DO::~CAct65DO()
{
}

bool CAct65DO::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65DO::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65DW.cpp -------------
#include "pch.h"

CAct65DW::CAct65DW()
{
}

CAct65DW::~CAct65DW()
{
}

bool CAct65DW::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65DW::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ELSE.cpp -------------
#include "pch.h"

CAct65ELSE::CAct65ELSE()
{
}

CAct65ELSE::~CAct65ELSE()
{
}

bool CAct65ELSE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ELSE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ELSEIF.cpp -------------
#include "pch.h"

CAct65ELSEIF::CAct65ELSEIF()
{
}

CAct65ELSEIF::~CAct65ELSEIF()
{
}

bool CAct65ELSEIF::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ELSEIF::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65END.cpp -------------
#include "pch.h"

CAct65END::CAct65END()
{
}

CAct65END::~CAct65END()
{
}

bool CAct65END::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65END::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65EPROC.cpp -------------
#include "pch.h"

CAct65EPROC::CAct65EPROC()
{
}

CAct65EPROC::~CAct65EPROC()
{
}

bool CAct65EPROC::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65EPROC::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65EqualTO.cpp -------------
#include "pch.h"

CAct65EqualTO::CAct65EqualTO()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65EqualTO::~CAct65EqualTO()
{
}

bool CAct65EqualTO::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65EqualTO::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65EXIT.cpp -------------
#include "pch.h"

CAct65EXIT::CAct65EXIT()
{
}

CAct65EXIT::~CAct65EXIT()
{
}

bool CAct65EXIT::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65EXIT::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65FFI.cpp -------------
#include "pch.h"

CAct65FFI::CAct65FFI()
{
}

CAct65FFI::~CAct65FFI()
{
}

bool CAct65FFI::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FFI::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65FI.cpp -------------
#include "pch.h"

CAct65FI::CAct65FI()
{
}

CAct65FI::~CAct65FI()
{
}

bool CAct65FI::Create()
{
    return false;
}

CValue* CAct65FI::Process()
{
    return nullptr;
}

 ---------- Act65FlagCARRY.cpp -------------
#include "pch.h"

CAct65FlagCARRY::CAct65FlagCARRY()
{
}

CAct65FlagCARRY::~CAct65FlagCARRY()
{
}

bool CAct65FlagCARRY::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FlagCARRY::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65FlagNEG.cpp -------------
#include "pch.h"

CAct65FlagNEG::CAct65FlagNEG()
{
}

CAct65FlagNEG::~CAct65FlagNEG()
{
}

bool CAct65FlagNEG::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FlagNEG::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65FlagOVERFLOW.cpp -------------
#include "pch.h"

CAct65FlagOVERFLOW::CAct65FlagOVERFLOW()
{
}

CAct65FlagOVERFLOW::~CAct65FlagOVERFLOW()
{
}

bool CAct65FlagOVERFLOW::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FlagOVERFLOW::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65FlagZERO.cpp -------------
#include "pch.h"

CAct65FlagZERO::CAct65FlagZERO()
{
}

CAct65FlagZERO::~CAct65FlagZERO()
{
}

bool CAct65FlagZERO::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FlagZERO::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65FOR.cpp -------------
#include "pch.h"

CAct65FOR::CAct65FOR()
{
}

CAct65FOR::~CAct65FOR()
{
}

bool CAct65FOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ForItterator.cpp -------------
#include "pch.h"

CAct65ForItterator::CAct65ForItterator()
{
}

CAct65ForItterator::~CAct65ForItterator()
{
}

bool CAct65ForItterator::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ForItterator::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ForSTEP.cpp -------------
#include "pch.h"

CAct65ForSTEP::CAct65ForSTEP()
{
}

CAct65ForSTEP::~CAct65ForSTEP()
{
}

bool CAct65ForSTEP::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ForSTEP::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ForTO.cpp -------------
#include "pch.h"

CAct65ForTO::CAct65ForTO()
{
}

CAct65ForTO::~CAct65ForTO()
{
}

bool CAct65ForTO::Create()
{
    return false;
}

CValue* CAct65ForTO::Process()
{
    return nullptr;
}

 ---------- Act65FuncCall.cpp -------------
#include "pch.h"

CAct65FuncCall::CAct65FuncCall()
{
}

CAct65FuncCall::~CAct65FuncCall()
{
}

bool CAct65FuncCall::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65FuncCall::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65GreaterTHAN.cpp -------------
#include "pch.h"

CAct65GreaterTHAN::CAct65GreaterTHAN()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65GreaterTHAN::~CAct65GreaterTHAN()
{
}

bool CAct65GreaterTHAN::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65GreaterTHAN::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65GTEQ.cpp -------------
#include "pch.h"

CAct65GTEQ::CAct65GTEQ()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65GTEQ::~CAct65GTEQ()
{
}

bool CAct65GTEQ::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65GTEQ::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65IDENT.cpp -------------
#include "pch.h"

CAct65IDENT::CAct65IDENT()
{
}

CAct65IDENT::~CAct65IDENT()
{
}

bool CAct65IDENT::Create(CBin* pSym)
{
    bool rV = true;
    CValue* pV = new CValue;
    pV->Create(pSym);
    CAstNode::CreateNode();
    return rV;
}

CValue* CAct65IDENT::Process()
{
    return nullptr;
}

 ---------- Act65IF.cpp -------------
#include "pch.h"

CAct65IF::CAct65IF()
{
}

CAct65IF::~CAct65IF()
{
}

bool CAct65IF::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65IF::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65IFF.cpp -------------
#include "pch.h"

CAct65IFF::CAct65IFF()
{
}

CAct65IFF::~CAct65IFF()
{
}

bool CAct65IFF::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65IFF::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65INT.cpp -------------
#include "pch.h"

CAct65INT::CAct65INT()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65INT::~CAct65INT()
{
}

bool CAct65INT::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65INT::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65INTERRUPT.cpp -------------
#include "pch.h"

CAct65INTERRUPT::CAct65INTERRUPT()
{
}

CAct65INTERRUPT::~CAct65INTERRUPT()
{
}

bool CAct65INTERRUPT::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65INTERRUPT::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65Label.cpp -------------
#include "pch.h"

CAct65Label::CAct65Label()
{
}

CAct65Label::~CAct65Label()
{
}

bool CAct65Label::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65Label::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65LessTHAN.cpp -------------
#include "pch.h"

CAct65LessTHAN::CAct65LessTHAN()
{
    SetNodeName(m_pNodeTyypeName);
}

CAct65LessTHAN::~CAct65LessTHAN()
{
}

bool CAct65LessTHAN::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65LessTHAN::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65LogicalAND.cpp -------------
#include "pch.h"

CAct65LogicalAND::CAct65LogicalAND()
{
}

CAct65LogicalAND::~CAct65LogicalAND()
{
}

bool CAct65LogicalAND::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65LogicalAND::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65LogicalOR.cpp -------------
#include "pch.h"

CAct65LogicalOR::CAct65LogicalOR()
{
}

CAct65LogicalOR::~CAct65LogicalOR()
{
}

bool CAct65LogicalOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65LogicalOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65LowerPart.cpp -------------
#include "pch.h"

CAct65LowerPart::CAct65LowerPart()
{
}

CAct65LowerPart::~CAct65LowerPart()
{
}

bool CAct65LowerPart::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65LowerPart::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65LSH.cpp -------------
#include "pch.h"

CAct65LSH::CAct65LSH()
{
}

CAct65LSH::~CAct65LSH()
{
}

bool CAct65LSH::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65LSH::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65LTEQ.cpp -------------
#include "pch.h"

CAct65LTEQ::CAct65LTEQ()
{
}

CAct65LTEQ::~CAct65LTEQ()
{
}

bool CAct65LTEQ::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65LTEQ::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65Module.cpp -------------
#include "pch.h"

CAct65Module::CAct65Module()
{
}

CAct65Module::~CAct65Module()
{
}

bool CAct65Module::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65Module::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65NotEquelTO.cpp -------------
#include "pch.h"

CAct65NotEquelTO::CAct65NotEquelTO()
{
}

CAct65NotEquelTO::~CAct65NotEquelTO()
{
}

bool CAct65NotEquelTO::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65NotEquelTO::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65OD.cpp -------------
#include "pch.h"

CAct65OD::CAct65OD()
{
}

CAct65OD::~CAct65OD()
{
}

bool CAct65OD::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65OD::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65Opcode.cpp -------------
#include "pch.h"

CAct65Opcode::CAct65Opcode()
{
    m_OpcodeToken = Token(-1);
    m_pOpCodeName = 0;
    m_pInstruction = 0;
    m_LineNumber = 0;
    m_ColumnNumber = 0;
    m_pSym = 0;
    m_pLabel = 0;
    m_AdressMode = AdrModeType::NA;
}

CAct65Opcode::~CAct65Opcode()
{
    if (m_pInstruction)
        delete m_pInstruction;
}

bool CAct65Opcode::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65Opcode::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65OptNOT.cpp -------------
#include "pch.h"

CAct65OptNOT::CAct65OptNOT()
{
}

CAct65OptNOT::~CAct65OptNOT()
{
}

bool CAct65OptNOT::Create(CAstNode* pChild, CAstNode* pNext)
{
    return false;
}

CValue* CAct65OptNOT::Process()
{
    return nullptr;
}

 ---------- Act65ORG.cpp -------------
#include "pch.h"

CAct65ORG::CAct65ORG()
{
}

CAct65ORG::~CAct65ORG()
{
}

bool CAct65ORG::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ORG::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65POINTER.cpp -------------
#include "pch.h"

CAct65POINTER::CAct65POINTER()
{
}

CAct65POINTER::~CAct65POINTER()
{
}

bool CAct65POINTER::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65POINTER::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65POP.cpp -------------
#include "pch.h"

CAct65POP::CAct65POP()
{
}

CAct65POP::~CAct65POP()
{
}

bool CAct65POP::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65POP::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65PopDest.cpp -------------
#include "pch.h"

CAct65PopDest::CAct65PopDest()
{
}

CAct65PopDest::~CAct65PopDest()
{
}

bool CAct65PopDest::Create(CAstNode* pChild, CAstNode* pNext)
{
    return false;
}

CValue* CAct65PopDest::Process()
{
    return nullptr;
}

 ---------- Act65Private.cpp -------------
#include "pch.h"

CAct65Private::CAct65Private()
{
}

CAct65Private::~CAct65Private()
{
}

bool CAct65Private::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65Private::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65PROC.cpp -------------
#include "pch.h"

CAct65PROC::CAct65PROC()
{
}

CAct65PROC::~CAct65PROC()
{
}

bool CAct65PROC::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65PROC::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ProcCall.cpp -------------
#include "pch.h"

CAct65ProcCall::CAct65ProcCall()
{
}

CAct65ProcCall::~CAct65ProcCall()
{
}

bool CAct65ProcCall::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ProcCall::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65PROCESSOR.cpp -------------
#include "pch.h"

CAct65PROCESSOR::CAct65PROCESSOR()
{
}

CAct65PROCESSOR::~CAct65PROCESSOR()
{
}

bool CAct65PROCESSOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65PROCESSOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65PROCname.cpp -------------
#include "pch.h"

CAct65PROCname::CAct65PROCname()
{
}

CAct65PROCname::~CAct65PROCname()
{
}

bool CAct65PROCname::Create()
{
    return false;
}

CValue* CAct65PROCname::Process()
{
    return nullptr;
}

 ---------- Act65ProcParams.cpp -------------
#include "pch.h"

CAct65ProcParams::CAct65ProcParams()
{
}

CAct65ProcParams::~CAct65ProcParams()
{
}

bool CAct65ProcParams::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ProcParams::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65PUSH.cpp -------------
#include "pch.h"

CAct65PUSH::CAct65PUSH()
{
}

CAct65PUSH::~CAct65PUSH()
{
}

bool CAct65PUSH::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65PUSH::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65PushSource.cpp -------------
#include "pch.h"

CAct65PushSource::CAct65PushSource()
{
}

CAct65PushSource::~CAct65PushSource()
{
}

bool CAct65PushSource::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65PushSource::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65RECTYPE.cpp -------------
#include "pch.h"

CAct65RECTYPE::CAct65RECTYPE()
{
}

CAct65RECTYPE::~CAct65RECTYPE()
{
}

bool CAct65RECTYPE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65RECTYPE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65RETURN.cpp -------------
#include "pch.h"

CAct65RETURN::CAct65RETURN()
{
}

CAct65RETURN::~CAct65RETURN()
{
}

bool CAct65RETURN::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65RETURN::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ROL.cpp -------------
#include "pch.h"

CAct65ROL::CAct65ROL()
{
}

CAct65ROL::~CAct65ROL()
{
}

bool CAct65ROL::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ROL::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65ROR.cpp -------------
#include "pch.h"

CAct65ROR::CAct65ROR()
{
}

CAct65ROR::~CAct65ROR()
{
}

bool CAct65ROR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65ROR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65RSH.cpp -------------
#include "pch.h"

CAct65RSH::CAct65RSH()
{
}

CAct65RSH::~CAct65RSH()
{
}

bool CAct65RSH::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65RSH::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65RTI.cpp -------------
#include "pch.h"

CAct65RTI::CAct65RTI()
{
}

CAct65RTI::~CAct65RTI()
{
}

bool CAct65RTI::Create()
{
    return false;
}

CValue* CAct65RTI::Process()
{
    return nullptr;
}

 ---------- Act65SecAtrbFALSE.cpp -------------
#include "pch.h"

CAct65SecAtrbFALSE::CAct65SecAtrbFALSE()
{
}

CAct65SecAtrbFALSE::~CAct65SecAtrbFALSE()
{
}

bool CAct65SecAtrbFALSE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbFALSE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SecAtrbMODE.cpp -------------
#include "pch.h"

CAct65SecAtrbMODE::CAct65SecAtrbMODE()
{
}

CAct65SecAtrbMODE::~CAct65SecAtrbMODE()
{
}

bool CAct65SecAtrbMODE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbMODE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SecAtrbREADONLY.cpp -------------
#include "pch.h"

CAct65SecAtrbREADONLY::CAct65SecAtrbREADONLY()
{
}

CAct65SecAtrbREADONLY::~CAct65SecAtrbREADONLY()
{
}

bool CAct65SecAtrbREADONLY::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbREADONLY::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SecAtrbREADWRITE.cpp -------------
#include "pch.h"

CAct65SecAtrbREADWRITE::CAct65SecAtrbREADWRITE()
{
}

CAct65SecAtrbREADWRITE::~CAct65SecAtrbREADWRITE()
{
}

bool CAct65SecAtrbREADWRITE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbREADWRITE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SecAtrbSIZE.cpp -------------
#include "pch.h"

CAct65SecAtrbSIZE::CAct65SecAtrbSIZE()
{
}

CAct65SecAtrbSIZE::~CAct65SecAtrbSIZE()
{
}

bool CAct65SecAtrbSIZE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbSIZE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SecAtrbSTART.cpp -------------
#include "pch.h"

CAct65SecAtrbSTART::CAct65SecAtrbSTART()
{
}

CAct65SecAtrbSTART::~CAct65SecAtrbSTART()
{
}

bool CAct65SecAtrbSTART::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbSTART::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SecAtrbZEROPAGE.cpp -------------
#include "pch.h"

CAct65SecAtrbZEROPAGE::CAct65SecAtrbZEROPAGE()
{

}

CAct65SecAtrbZEROPAGE::~CAct65SecAtrbZEROPAGE()
{
}

bool CAct65SecAtrbZEROPAGE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SecAtrbZEROPAGE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SECTION.cpp -------------
#include "pch.h"

CAct65SECTION::CAct65SECTION()
{
}

CAct65SECTION::~CAct65SECTION()
{
}

bool CAct65SECTION::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SECTION::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65SUB.cpp -------------
#include "pch.h"

CAct65SUB::CAct65SUB()
{
}

CAct65SUB::~CAct65SUB()
{
}

bool CAct65SUB::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65SUB::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65THEN.cpp -------------
#include "pch.h"

CAct65THEN::CAct65THEN()
{
}

CAct65THEN::~CAct65THEN()
{
}

bool CAct65THEN::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65THEN::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65TRUE.cpp -------------
#include "pch.h"

CAct65TRUE::CAct65TRUE()
{
}

CAct65TRUE::~CAct65TRUE()
{
}

bool CAct65TRUE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65TRUE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65TYPEDEF.cpp -------------
#include "pch.h"

CAct65tTYPEDEF::CAct65tTYPEDEF()
{
}

CAct65tTYPEDEF::~CAct65tTYPEDEF()
{
}

bool CAct65tTYPEDEF::Create(CAstNode* pChild, CAstNode* pNext)
{
    return false;
}

CValue* CAct65tTYPEDEF::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65UNTILL.cpp -------------
#include "pch.h"

CAct65UNTILL::CAct65UNTILL()
{
}

CAct65UNTILL::~CAct65UNTILL()
{
}

bool CAct65UNTILL::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65UNTILL::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65UpperPart.cpp -------------
#include "pch.h"

CAct65UpperPart::CAct65UpperPart()
{
}

CAct65UpperPart::~CAct65UpperPart()
{
}

bool CAct65UpperPart::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65UpperPart::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65VECTOR.cpp -------------
#include "pch.h"

CAct65VECTOR::CAct65VECTOR()
{
}

CAct65VECTOR::~CAct65VECTOR()
{
}

bool CAct65VECTOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65VECTOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65WHILE.cpp -------------
#include "pch.h"

CAct65WHILE::CAct65WHILE()
{
}

CAct65WHILE::~CAct65WHILE()
{
}

bool CAct65WHILE::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65WHILE::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65XOR.cpp -------------
#include "pch.h"

CAct65XOR::CAct65XOR()
{
}

CAct65XOR::~CAct65XOR()
{
}

bool CAct65XOR::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65XOR::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65XREG.cpp -------------
#include "pch.h"

CAct65XREG::CAct65XREG()
{
}

CAct65XREG::~CAct65XREG()
{
}

bool CAct65XREG::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65XREG::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- Act65YREG.cpp -------------
#include "pch.h"

CAct65YREG::CAct65YREG()
{
}

CAct65YREG::~CAct65YREG()
{
}

bool CAct65YREG::Create(CAstNode* pChild, CAstNode* pNext)
{
    SetNodeName(m_pNodeTyypeName);
    return CAstNode::CreateNode(pChild, pNext);
}

CValue* CAct65YREG::Process()
{
    CAstNode* pChild = 0, * pNext = 0;
    CValue* pValueChild = 0, * pValueNext = 0
        ;
    pChild = GetChild();
    if (pChild)
    {
        pNext = pChild->GetNext();
    }
    if (pChild)
    {
        pValueChild = pChild->Process();
    }
    if (pNext)
    {
        pValueNext = pNext->Process();
    }
    //-----------------------
    // Code Generation
    //-----------------------
    return pValueChild;
}

 ---------- ActionApp.cpp -------------
#include "pch.h"


CActionApp ActApp;

CActionApp* Act()
{
    return &ActApp;
}

int main(int argc, char* argv[])
{
    fprintf(stderr, "The Action! Compiler for the 6502 Ver 0.0.1\nNov 27, 2024\n");
    ActApp.Create(argc, argv);
    ActApp.Run();
    fprintf(stderr, "Done\n");
}

//--------------------------------------
// Action App Class
//--------------------------------------

CActionApp::CActionApp()
{
    m_pSourceFile = 0;
    m_pLogFile = 0;
    m_pObjectFile = 0;
    m_pBinaryFile = 0;
    m_pfSrc = 0;
    m_pfLog = 0;
    m_pfBin = 0;
    m_pfObj = 0;
}

CActionApp::~CActionApp()
{
    if (m_pSourceFile)delete[]m_pSourceFile;
    if (m_pLogFile)delete[]m_pLogFile;
    if (m_pObjectFile)delete[]m_pObjectFile;
    if (m_pBinaryFile)delete[]m_pBinaryFile;
    CloseAll();
}

bool CActionApp::Create(int argc, char* argv[])
{
    //--------------------------------
    // parse the command line
    // 
    // Command line format:
    // action65 <source file> options
    // 
    // options:
    // -L <log file name>
    // -O <object file output
    // -B <binary file output for burning rom>
    //--------------------------------

    int i;
    int l=0;

    if (argc == 1)
    {
        fprintf(stderr, "Usage:\n");
        fprintf(stderr, "action65 <source file> options\n");
        fprintf(stderr, "Options:\n");
        fprintf(stderr, "-L <Log File Name>\n");
        fprintf(stderr, "-B <Binary File Name>\n");
        fprintf(stderr, "-O <Object File Name>\n");
    }
    else
    {
        for (i = 1; i < argc; ++i)
        {
            if (i == 1)
            {
                //---------------------
                // this had better be
                // the input source
                // file
                //---------------------
                l = strlen(argv[i]) + 1;
                m_pSourceFile = new char[l];
                strcpy_s(m_pSourceFile, l, argv[i]);
            }
            else if (argv[i][0] == '-')
            {
                switch (argv[i][1])
                {
                case 'L':
                    ++i;
                    l = strlen(argv[i]) + 1;
                    m_pLogFile = new char[l];
                    strcpy_s(m_pLogFile, l, argv[i]);
                    break;
                case 'O':
                    ++i;
                    l = strlen(argv[i]) + 1;
                    m_pObjectFile = new char[l];
                    strcpy_s(m_pObjectFile, l, argv[i]);
                    break;
                case 'B':
                    ++i;
                    l = strlen(argv[i]) + 1;
                    m_pBinaryFile = new char[l];
                    strcpy_s(m_pBinaryFile, l, argv[i]);
                    break;
                }
            }
        }
    }
    return true;
}

bool CActionApp::Run()
{
    bool rV = false;
    OpenLog();
    m_ActParse.Create();
    m_ActParse.Run();
    return rV;
}

bool CActionApp::OpenSource()
{
    bool rV = false;
    errno_t err;

    if (m_pSourceFile)
    {
        err = fopen_s(&m_pfSrc, m_pSourceFile, "r");
        if (err == 0)
            rV = true;
        else
        {
            fprintf(stderr, "Could not open %s\n", m_pSourceFile);
            CloseAll();
            exit(1);
        }
    }
    return rV;
}

bool CActionApp::OpenLog()
{
    bool rV = false;
    errno_t err;

    if (m_pLogFile)
    {
        err = fopen_s(&m_pfLog, m_pLogFile, "w");
        if (err == 0)
            rV = true;
        else
        {
            fprintf(stderr, "Unable to open %s as the log file\n", m_pLogFile);
        }
    }
    return rV;
}

bool CActionApp::OpenObj()
{
    bool rV = false;
    errno_t err;

    if (m_pObjectFile)
    {
        err = fopen_s(&m_pfObj, m_pObjectFile, "wb");
        if (err == 0)
            rV = true;
    }
    return rV;
}

bool CActionApp::OpenBin()
{
    bool rV = false;
    errno_t err;

    if (m_pBinaryFile)
    {
        err = fopen_s(&m_pfBin, m_pBinaryFile, "wb");
        if (err == 0)
            rV = true;
    }
    return rV;
}

void CActionApp::CloseSource()
{
    if(m_pfSrc)
        fclose(m_pfSrc);
    m_pfSrc = 0;
}

void CActionApp::CloseLog()
{
    if(m_pfLog)
        fclose(m_pfLog);
    m_pfLog = 0;
}

void CActionApp::CloseObj()
{
    if(m_pfObj)
        fclose(m_pfObj);
    m_pfObj = 0;
}

void CActionApp::CloseBin()
{
    if(m_pfBin)
        fclose(m_pfBin);
    m_pfBin = 0;
}

void CActionApp::CloseAll()
{
    CloseSource();
    CloseLog();
    CloseBin();
    CloseObj();
}

char* CActionApp::IndentString(char* s, int Indent, int c)
{
    int i;

    for (i = 0; i < Indent;++i)
        s[i] = c;
    s[i] = 0;
    return s;
}


void CActionApp::Dump(
    FILE* pOut, 
    char* pMem, 
    unsigned StartAddress, 
    unsigned Size
)
{
    unsigned Loc = 0;
    bool bDone = false;
    char* s = new char[256];
    char strPad[64];
    int Pad;
    char Ascii[10];
    int l, i, c, n;

    Ascii[8] = 0;
    while (!bDone)
    {
        l = 0;
        l = sprintf_s(s, 256, "%04X ", Loc + StartAddress);
        if ((Size - Loc) <= 0)
        {
            bDone = true;
        }
        else
        {
            if ((Size - Loc) < 8)
                n = Size - Loc;
            else
                n = 8;
            for (i = 0; i < n; ++i)
            {
                l += sprintf_s(&s[l], 256 - l,
                    "%02X ", unsigned(pMem[Loc + i]) & 0x0ff);
            }
            if (n < 8)
            {
                Pad = (8 - n) * 3;
                Act()->IndentString(strPad, Pad, ' ');
                l += sprintf_s(&s[l], 256 - l, "%s", strPad);
            }
            for (i = 0; i < n; ++i)
            {
                c = pMem[Loc + i];
                if (c < 0x20)
                    c = '.';
                else if (c > 0x7f)
                    c = '.';
                Ascii[i] = c;
            }
            fprintf(pOut, "%s %s\n", s, Ascii);
            Loc += 8;
        }
    }
    delete[] s;
}

char* CActionApp::CreateIndentString(char* s, int n, int Indent, int c)
{
    int i;

    for (i = 0; (i < Indent) && (i < (n - 1)); ++i)
        s[i] = c;
    s[i] = 0;
    return s;
}

 ---------- ActionAstTree.cpp -------------
#include "pch.h"

CActionAstTree::CActionAstTree()
{
}

CActionAstTree::~CActionAstTree()
{
}

bool CActionAstTree::Create()
{
    return false;
}

CAstNode* CActionAstTree::MakeNewNode(
    int Type, 
    CAstNode* Child, 
    CAstNode* Next
)
{
    return nullptr;
}

 ---------- ActStatusFlags.cpp -------------
#include "pch.h"

CActStatusFlags::CActStatusFlags()
{
}

CActStatusFlags::~CActStatusFlags()
{
}

bool CActStatusFlags::Create()
{
    return false;
}

 ---------- Actt65DB.cpp -------------
#include "pch.h"

CAct65DB::CAct65DB()
{
}

CAct65DB::~CAct65DB()
{
}

bool CAct65DB::Create(CAstNode* pChild, CAstNode* pNext)
{
    return false;
}

CValue* CAct65DB::Process()
{
    return nullptr;
}

 ---------- Actt65DS.cpp -------------
#include "pch.h"

CAct65DS::CAct65DS()
{
}

CAct65DS::~CAct65DS()
{
}

bool CAct65DS::Create(CAstNode* pChild, CAstNode* pNext)
{
    return false;
}

CValue* CAct65DS::Process()
{
    return nullptr;
}

 ---------- AddressSizeStackItem.cpp -------------
#include "pch.h"

CAddressSizeStackItem::CAddressSizeStackItem()
{
    m_OpRandAdrSize = CSection::AddressSize::ADDRESSSIZE_WORD; //default
}

CAddressSizeStackItem::~CAddressSizeStackItem()
{
}

bool CAddressSizeStackItem::Create()
{
    return CStackItem::Create(CStackItem::ItemType::ADDRESSSIZE);
}

 ---------- AstNode.cpp -------------
#include "pch.h"

CAstNode::CAstNode()
{
    m_NodeID = ++m_NodeCount;
    m_NodeType = 0;
    m_pStart = 0;
    m_pNext = 0;
    m_pPrev = 0;
    m_pChild = 0;
    m_pParent = 0;
    m_pNodeName = 0;
    m_pValue = 0;
    m_pHead = 0;
    m_pTail = 0;
}

CAstNode::CAstNode(int NodeType)
{
    m_NodeID = ++m_NodeCount;
    m_NodeType = NodeType;
    m_pStart = 0;
    m_pNext = 0;
    m_pPrev = 0;
    m_pChild = 0;
    m_pParent = 0;
    m_pNodeName = 0;
    m_pValue = 0;
    m_pHead = 0;
    m_pTail = 0;
}

CAstNode::~CAstNode()
{
}

bool CAstNode::CreateNode(
    CAstNode* pChild,
    CAstNode* pNext
)
{
    SetChild(pChild);
    SetNext(pNext);
    SetChild(pChild);
    if (pChild)
    {
        pChild->AddToTail(pNext);
    }
    if(pNext)GetNext()->SetPrev(this);
    SetStart(Act()->GetParser()->GetAstTree()->GetRootNode());
    return true;
}

void CAstNode::Print(FILE* pOut, int Indent, char* s)
{
    int ChildID, NextID;
//    char* pIndentString;

//    pIndentString = new char[256];
//    Act()->IndentString(pIndentString, Indent, ' ');
    if (GetChild())
        ChildID = GetChild()->GetID();
    else
        ChildID = -1;
    if (GetNext())
        NextID = GetNext()->GetID();
    else
        NextID = -1;
    fprintf(
        pOut,
        ";\t %4d %4d %4d %s%s %s\n",
        GetID(),
        ChildID,
        NextID,
        s,
        this->GetNodeName(),
        GetSymbol()?GetSymbol()->GetName():"..."
    );
//    delete[] pIndentString;
}

void CAstNode::AddToHead(CAstNode* pN)
{
    if (GetHead())
    {
        GetHead()->SetPrev(pN);
        pN->SetNext(GetHead());
        SetHead(pN);
    }
    else
    {
        SetTail(pN);
        SetHead(pN);
    }
}


void CAstNode::AddToTail(CAstNode* pNode)
{
    if (GetHead())
    {
        GetTail()->SetNext(pNode);
        pNode->SetPrev(GetTail());
        SetTail(pNode);
    }
    else
    {
        SetTail(pNode);
        SetHead(pNode);
    }
}

 ---------- AstTree.cpp -------------
#include "pch.h"

CAstTree::CAstTree()
{
}

CAstTree::~CAstTree()
{
}

bool CAstTree::Create()
{
    return false;
}

void CAstTree::Print(FILE* pOut)
{
    char* s = 0;

    if (GetRootNode() && pOut)
    {
        s = new char[4096];
        memset(s, 0, 4096);
        fprintf(
            pOut,
            "\t NUMB DOWN NEXT\n"
        );
        TraverseTree(pOut, GetRootNode(), s);
        delete[] s;
    }
    if(Act()->LogFile())
        fprintf(Act()->LogFile(),"Root Node is NULL");
}

void CAstTree::TraverseTree(FILE* pOut, CAstNode* pNode, char* s)
{
    //-------------------------------
    // Navigate the Syntax Tree
    //-------------------------------
    static int Recursions = 0;

    if (++Recursions > 100)
    {
        fprintf(pOut, "Too Many Recursions\n");
        Act()->CloseAll();
        exit(2);
    }
    while (pNode->GetNext())    /*    while next pointer points to valid node    */
    {
        strcat_s(s, 4096, "+-");
        pNode->Print(pOut, 0,s);
        s[strlen(s) - 2] = 0;
        if (pNode->GetChild())
        {
            strcat_s(s, 4096, "| ");
            TraverseTree(pOut, pNode->GetChild(),s);
            s[strlen(s) - 2] = 0;
        }
        pNode = pNode->GetNext();
    }
    strcat_s(s, 4096, "+-");
    pNode->Print(pOut, 0,s);
    s[strlen(s) - 2] = 0;
    if (pNode->GetChild())
    {
        strcat_s(s, 4096, "  ");
        TraverseTree(pOut, pNode->GetChild(),s);
        s[strlen(s) - 2] = 0;
    }
}


 ---------- Bin.cpp -------------
#include "pch.h"

bool CBin::Compare(const char* name, int aux)
{
    bool rV = false;

    if (strcmp(GetName(), name) == 0)
        rV = true;
    return rV;
}

void CBin::Print(FILE* pOut, const char* s)
{
    fprintf(pOut, "CBin::%s\n", m_pName);
}

//-----------------------------------------------
// Sub list methods
//-----------------------------------------------

void CBin::Add(CBin* pSym)
{
    if (GetHead())
    {
        GetTail()->SetNext(pSym);
        pSym->SetPrev(GetTail());
        SetTail(pSym);
    }
    else
    {
        SetTail(pSym);
        SetHead(pSym);
    }
}

CBin* CBin::Find(const char* pName, CBin::BinType Type)
{
    CBin* pBin = 0;
    bool loop = true;

    pBin = GetHead();
    while (pBin && loop)
    {
        if (pBin->Compare(pName, Type))
            loop = false;
        else
            pBin = pBin->GetNext();
    }
    return pBin;
}

void CBin::Delete(CBin* pSym)
{
    Unlink(pSym);
    delete pSym;
}

void CBin::Unlink(CBin* pSym)
{
    if (GetHead() == pSym)
    {
        SetHead(pSym->GetNext());
        if (GetHead())
            GetHead()->SetPrev(0);
    }
    else if (GetTail() == pSym)
    {
        SetTail(pSym->GetPrev());
        if (GetTail())
            GetTail()->SetNext(0);
    }
    else
    {
        pSym->GetNext()->SetPrev(pSym->GetPrev());
        pSym->GetPrev()->SetNext(pSym->GetNext());
    }
}

 ---------- BinStackItem.cpp -------------
#include "pch.h"

CBinStackItem::CBinStackItem()
{
    m_pBin = 0;
}

CBinStackItem::~CBinStackItem()
{
}

bool CBinStackItem::Create()
{
    return CStackItem::Create(CStackItem::ItemType::BIN);
}

 ---------- Bucket.cpp -------------
#include "pch.h"


CBucket::~CBucket()
{
    CBin* pBin;

    pBin = m_pHead;

    while (pBin)
    {
        pBin->Print(stdout);
        m_pHead = pBin->GetNext();
        delete pBin;
        pBin = m_pHead;
    }
}

void CBucket::Add(CBin* pSym)
{
    if (m_pHead)
    {
        m_pTail->SetNext(pSym);
        pSym->SetPrev(m_pTail);
        m_pTail = pSym;
    }
    else
    {
        m_pTail = pSym;
        m_pHead = pSym;
    }
}

CBin* CBucket::Find(const char* pName, int scope)
{
    CBin* pBin = 0;
    bool loop = true;

    pBin = GetHead();
    while (pBin && loop)
    {
        if (pBin->Compare(pName, scope))
            loop = false;
        else
            pBin = pBin->GetNext();
    }
    return pBin;
}

void CBucket::Delete(CBin* pSym)
{
    Unlink(pSym);
    delete pSym;
}

void CBucket::Unlink(CBin* pSym)
{
    if (m_pHead == pSym)
    {
        m_pHead = pSym->GetNext();
        m_pHead->SetPrev(0);
    }
    else if (m_pTail == pSym)
    {
        m_pTail = pSym->GetPrev();
        m_pTail->SetNext(0);
    }
    else
    {
        pSym->GetNext()->SetPrev(pSym->GetPrev());
        pSym->GetPrev()->SetNext(pSym->GetNext());
    }
}


 ---------- DataSizeStackItem.cpp -------------
#include "pch.h"

CDataSizeStackItem::CDataSizeStackItem()
{
}

CDataSizeStackItem::~CDataSizeStackItem()
{
}

bool CDataSizeStackItem::Create()
{
    return CStackItem::Create(CStackItem::ItemType::DATA_SIZE);;
}

 ---------- Instruction.cpp -------------
#include "pch.h"

CInstruction::CInstruction()
{
    m_OpCode = 0;
    m_LowByte = 0;
    m_HighByte = 0;
    m_unused = 0;
    m_ByteCount = 0;
    m_OpCodeToken = Token::BRK;
    m_UnResolved = false;
}

CInstruction::~CInstruction()
{
    m_OpCodeToken = Token(0);
    m_OpCode = 0;
    m_LowByte = 0;
    m_HighByte = 0;
    m_unused = 0;
    m_ByteCount = 1;
}

bool CInstruction::Create()
{
    CStackItem::Create(CStackItem::ItemType::INSTRUCTION);
    return 0;
}

void CInstruction::AddToCurrentSection()
{
    CSection* pSec;
    unsigned short Address;

    pSec = Act()->GetParser()->GetCurrentSection();
    Address = (unsigned short)pSec->GetLocationCounter();
    pSec->AddData(1, GetOpCode());
    if (GetByteCount() == 1)
    {
//        fprintf(
//            Act()->LogFile(),
//            "Add Instruction %04x: %02x\n",
//            Address & 0x0ffff,
//            GetOpCode() & 0x0ff
//        );
    }
    else if (GetByteCount() == 2)
    {
        pSec->AddData(1, GetLowByte());
//        fprintf(
//            Act()->LogFile(), 
//            "Add Instruction %04hx: %02x,%02x\n", 
//            Address & 0x0ffff,
//            GetOpCode() & 0x0ff,
//            GetLowByte() & 0x0ff);
    }
    else 
    {
//        fprintf(
//            Act()->LogFile(), 
//            "Add Instruction %04hX: %02X, %04X\n", 
//            Address &0x0ffff, 
//            GetOpCode() & 0x0ff,
//            GetOperandW() & 0x0ffff
//        );
        pSec->AddData(2, GetOperandW());
    }
}

bool CInstruction::IsRelative()
{
    bool rV = false;

    switch (m_OpCodeToken)
    {
    case Token::BCC:
    case Token::BCS:
    case Token::BEQ:
    case Token::BMI:
    case Token::BNE:
    case Token::BPL:
    case Token::BVC:
    case Token::BVS:
        rV = true;
        break;
    }
    return rV;
}

 ---------- Lexer.cpp -------------
#include "pch.h"

CLexer::CLexer()
{
    int i;

    for (i = 0; i < 256; ++i)
        m_aLexBuff[i] = 0;
    m_UngetBuffer = 0;
    m_LexBuffIndex = 0;
    m_Line = 1;
    m_Col = 0;
    m_Number = 0;
    m_pLexSymbol = 0;
    m_pFileBuffeer = 0;
    m_FileIndex = 0;
    m_InFileSize = 0;
    m_bAsmMode = false;
}

CLexer::~CLexer()
{
     
}

bool CLexer::Create()
{
    struct _stat32 FileStats;
    unsigned BytesRead = 0;

    //---------------------------------
    // Open Input File
    //---------------------------------
    _stat32(Act()->GetSourceFileName(), &FileStats);
    m_InFileSize = FileStats.st_size;
    Act()->OpenSource();
    m_pFileBuffeer = new char[m_InFileSize + 1];
    if(m_pFileBuffeer && Act()->SrcFile())
        BytesRead = fread(m_pFileBuffeer, 1, m_InFileSize, Act()->SrcFile());
    Act()->CloseSource();
    if (BytesRead)
        m_InFileSize = BytesRead;
    //----------------------------
    // Create Symbol Table
    //----------------------------
    m_SymbolTable.Create(101);
    if(LogFile())
    fprintf(LogFile(), "File:%s has %d Bytes\n", Act()->GetSourceFileName(), m_InFileSize);
    return true;
}

FILE* CLexer::LogFile()
{
    return Act()->LogFile();
}

int CLexer::LexGet()
{
    int c = EOF;

    if (m_pFileBuffeer && (m_FileIndex < m_InFileSize))
        c = m_pFileBuffeer[m_FileIndex++];
    else if (m_FileIndex == m_InFileSize)
    {
        c = EOF;
    }
    m_Col++;
    return c;
}

int CLexer::LexLook(int index)
{
    int c = EOF;
    int i;

    i = index + m_FileIndex;
    if (m_pFileBuffeer && (i < m_InFileSize))
        c = m_pFileBuffeer[i];
    else if (m_FileIndex == m_InFileSize)
    {
        c = EOF;
    }
    return c;
}

void CLexer::LexUnGet(int c)
{
    if ((m_FileIndex > 0) && (c != EOF))
    {
        --m_FileIndex;
        if (m_Col > 0)
            m_Col--;
    }
}

bool CLexer::IsValidHexNumber(int c)
{
    bool IsValid = false;

    switch (c)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
        IsValid = true;
        break;
    }
    return IsValid;
}

bool CLexer::IsValidNumber(int c)
{
    bool IsValid = false;

    switch (c)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
        IsValid = true;
        break;
    }
    return IsValid;
}

bool CLexer::IsValidNameChar(int c)
{
    bool IsValid = false;

    if (isalnum(c) || c == '_')
        IsValid = true;
    return IsValid;;
}

bool CLexer::IsWhiteSpace(int c)
{
    bool IsValid = false;

    switch (c)
    {
    case '\n':
    case '\r':
    case '\t':
    case ' ':
        IsValid = true;
        break;;
    }
    return IsValid;
}

bool CLexer::IsValidAssignmentOperator(int c)
{
    bool IsValid = false;

    switch (c)
    {
    case '+':
    case '-':
    case '*':
    case '/':
    case 'M':
    case '&':
    case '%':
    case '!':
    case 'X':
    case 'L':
    case 'R':
        IsValid = true;
    }
    return IsValid;
}

Token CLexer::Lex()
{
    bool Loop = true;
    bool auxLoop = true;
    int c = 0,c1 = 0, c2 = 0;
    Token TokenValue = Token(0);

    m_LexBuffIndex = 0;
    while (Loop)
    {
        c = LexGet();
        switch (c)
        {
        case EOF:
            TokenValue = Token::ENDOFFILE;
            Loop = false;
            break;
        case '\n':    //white space
            m_Col = 0;
            m_Line++;
            break;
        case '\r':    //more white space
        case '\t':
        case ' ':
            break;
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            //Decimal Number
            m_aLexBuff[m_LexBuffIndex++] = c;
            auxLoop = true;
            while (auxLoop)
            {
                c = LexGet();
                if (IsValidNumber(c))
                    m_aLexBuff[m_LexBuffIndex++] = c;
                else
                    auxLoop = false;
            }
            m_aLexBuff[m_LexBuffIndex] = 0;
            m_Number = atoi(m_aLexBuff);
            LexUnGet(c);
            Loop = false;
            TokenValue = Token::NUMBER;
            break;
        case '$':    //Hexadecimal Number
            auxLoop = true;
            while (auxLoop)
            {
                c = LexGet();
                if (IsValidHexNumber(c))
                    m_aLexBuff[m_LexBuffIndex++] = c;
                else
                    auxLoop = false;
            }
            m_aLexBuff[m_LexBuffIndex] = 0;
            m_Number = strtol(m_aLexBuff, NULL, 16);
            LexUnGet(c);
            Loop = false;
            TokenValue = Token::NUMBER;
            break;
        case '=':    //assignment operators
            c = LexGet();
            if (IsWhiteSpace(c) || c != '=')
            {
                TokenValue = Token('=');
                Loop = false;
                LexUnGet(c);
            }
            else
            {
                c = LexGet();
                if (IsValidAssignmentOperator(c))
                {
                    switch (c)
                    {
                    case '+':
                        TokenValue = Token::ASSIGN_ADD;
                        break;
                    case '-':
                        TokenValue = Token::ASSIGN_SUB;
                        break;
                    case '*':
                        TokenValue = Token::ASSIGN_SUB;
                        break;
                    case '/':
                        TokenValue = Token::ASSIGN_DIV;
                        break;
                    case 'M':
                        //throw away next two characters
                        LexGet();
                        LexGet();
                        TokenValue = Token::ASSIGN_MOD;
                        break;
                    case '&':
                        TokenValue = Token::ASSIGN_AND;;
                        break;
                    case '%':
                        TokenValue = Token::ASSIGN_OR;
                        break;
                    case '!':
                        TokenValue = Token::ASSIGN_XOR;
                        break;
                    case 'X':
                        TokenValue = Token::ASSIGN_XOR;;
                        //throw away next two characters
                        LexGet();
                        LexGet();
                        break;
                    case 'L':
                        //throw away next two characters
                        LexGet();
                        LexGet();
                        TokenValue = Token::ASSIGN_LSH;
                        break;
                    case 'R':
                        //throw away next two characters
                        LexGet();
                        LexGet();
                        TokenValue = Token::ASSIGN_RSH;
                        break;
                    }
                }
            }
            Loop = false;
            break;
        case '[':
        case ']':
        case '(':
        case ')':
        case'{':
        case '}':
        case '+':    //add
        case '-':    //sub
        case '*':    //mul
        case '!':    //XOR
        case '&':    //Bitwise AND
        case '%':    //Bitwise OR
        case '#':    //Not Equal/Immediate Data
        case '@':    //Address of
        case '^':    //Pointer dereference
        case ',':
            TokenValue = Token(c);
            Loop = false;
            break;
        case '>':    //Greader Than
            c = LexGet();
            if (c == '=')
                TokenValue = Token::GTEQ;
            else
            {
                TokenValue = Token('>');
                LexUnGet(c);
            }
            Loop = false;
            break;
        case '<':    //Less Than
            c = LexGet();
            if (c == '>')
                TokenValue = Token('#');
            else if (c == '=')
                TokenValue = Token::LTEQ;
            else
            {
                TokenValue = Token('<');
                LexUnGet(c);
            }
            Loop = false;
            break;
        case '.':
            c1 = LexLook(1);
            c2 = LexLook(2);
            if (!IsValidNameChar(c2))
            {
                switch (c1)
                {
                case 'A':    //accumulator
                    TokenValue = Token::AREG;
                    m_LexBuffIndex++;
                    break;
                case 'P':    //proecssor status
                    TokenValue = Token::PSREG;
                    m_LexBuffIndex++;
                    break;
                case 'S':    // stack pointer
                    TokenValue = Token::SPREG;
                    m_LexBuffIndex++;
                    break;
                case 'X':    // X index register
                    TokenValue = Token::XREG;
                    m_LexBuffIndex++;
                    break;
                case 'Y':    // Y index register
                    TokenValue = Token::YREG;
                    m_LexBuffIndex++;
                    break;
                case 'C':    // carry flag
                    TokenValue = Token::CARRY;
                    m_LexBuffIndex++;
                    break;
                case 'D':
                    TokenValue = Token::DECIMAL_MODE;
                    m_LexBuffIndex++;
                    break;
                case 'I':    // interrupt flag
                    TokenValue = Token::IRQENABLE;
                    m_LexBuffIndex++;
                    break;
                case 'N':    // negative flag
                    TokenValue = Token::NEG;
                    m_LexBuffIndex++;
                    break;
                case 'O':
                    TokenValue = Token::OVERFLOW;
                    m_LexBuffIndex++;
                    break;
                default:
                    TokenValue = Token('.');
                    break;
                }
                Loop = false;
            }
            else
            {
                TokenValue = Token('.');
            }
            Loop = false;
            break;
        case '/':
            if (LexLook(1) == '/')    //comment?
            {
                auxLoop = true;
                while (auxLoop)
                {
                    c = LexGet();
                    if (c == '\n')
                    {
                        auxLoop = false;
                        m_Line++;
                        m_Col = 0;
                    }
                }
            }
            else
            {
                TokenValue = Token(c);
                Loop = false;
            }
            break;
        case ';':    // Comment
            auxLoop = true;
            while (auxLoop)
            {
                c = LexGet();
                if (c == '\n')
                {
                    auxLoop = false;
                    m_Line++;
                    m_Col = 0;
                }
            }
            break;
        default:    //Keywords and Identifiers
            m_aLexBuff[m_LexBuffIndex++] = c;
            auxLoop = true;
            while (auxLoop)
            {
                c = LexGet();
                if (IsValidNameChar(c))
                {
                    m_aLexBuff[m_LexBuffIndex++] = c;
                }
                else
                {
                    auxLoop = false;
                    m_aLexBuff[m_LexBuffIndex] = 0;
                    LexUnGet(c);
                }
            }    //END OF collecting characters for word
            //---------------------------------
            // First check to see if it is a
            // Keyword
            //---------------------------------
            TokenValue = LookupKeyword(m_aLexBuff);
            if (int(TokenValue))
            {
                //--------------------------
                // Keyword has matched
                //--------------------------
                Loop = 0;
            }
            else
            {
                //-------------------------------------
                // Is it a Identifier?
                //-------------------------------------
                m_pLexSymbol = (CSymbol*)LookupSymbol(m_aLexBuff);
                if (m_pLexSymbol)
                {
                    TokenValue = Token::IDENT;
                    Loop = false;
                }
                else
                {
                    //-------------------------------------
                    // Identifier is New/Undefined
                    //-------------------------------------
                    m_pLexSymbol = new CSymbol;
                    m_pLexSymbol->Create();
                    TokenValue = Token::IDENT;
                    m_pLexSymbol->SetIdentType(IdentType::NEW_SYMBOL);
                    m_pLexSymbol->SetName(GetLexBuffer());
                    Loop = false;
                }
            }
            break;    // end of default:
        }
    }
    return TokenValue;
}

CBin* CLexer::LookupSymbol(const char* pName)
{
    return GetSymTab()->FindSymbol(pName,1);
}

Token CLexer::LookupKeyword(const char* pKeyword)
{
    Token Toke;

    Toke = KeyWords->LookupToToken(pKeyword);
    return Toke;
}

CLexer::KeyWord* CLexer::FindKeyword(Token KeywordToken)
{
    return 0;
}

Processor CLexer::LookupProcessor(Token KeywordToken)
{
    Processor AppropriateProcessor = Processor::ALL;
    int i = 0;
    bool Loop = true;

    while (Loop)
    {
        if (KeyWords[i].m_TokenID == KeywordToken)
        {
            AppropriateProcessor = KeyWords[i].m_Processor;
            Loop = 0;
        }
        else
        {
            ++i;
            if (KeyWords[i].m_TokenID == Token::ENDOFTOKENS)
            {
                Loop = false;
            }
        }
    }
    return AppropriateProcessor;
}

int CLexer::LookupOpcode(Token OpcodeToken)
{
    int OpCode = 0;
    int i;
    bool Loop = true;

    for (i = 0; KeyWords[i].m_OpCode >= 0 && Loop; ++i)
    {
        if (KeyWords[i].m_TokenID == OpcodeToken)
        {
            Loop = false;
            OpCode = KeyWords[i].m_OpCode;
        }
    }
    return OpCode;
}

int CLexer::GetOpcode(Token OpCodeToken)
{
    int OpCode = -1;    //indicates error
    int i = 0;
    bool Loop = true;

    while (KeyWords[i].m_TokenID != Token::ENDOFTOKENS && Loop)
    {
        if (KeyWords[i].m_TokenID == OpCodeToken)
        {
            OpCode = KeyWords[i].m_OpCode;
            Loop = false;
        }
        else
            ++i;
    }
    return OpCode;
}

const char* CLexer::KeyWord::LookupToName(Token Toke)
{
    bool Loop = true;
    Token T = Token(0);
    int i = 0;
    const char* S =0;

    while (Loop)
    {
        T = KeyWords[i].m_TokenID;
        if (Toke == T)
        {
            Loop = false;
            S = KeyWords[i].m_Name;
        }
        else if (T == Token::ENDOFTOKENS)
        {
            Loop = false;
            S = 0;
        }
        else
        {
            ++i;
        }
    }
    return S;
}

Token CLexer::KeyWord::LookupToToken(const char* pName)
{
    int i = 0;
    bool Loop = true;

    while (Loop)
    {
        if (strcmp(pName, KeyWords[i].m_Name) == 0)
            Loop = false;
        else
            i++;
        if (KeyWords[i].m_TokenID == Token::ENDOFTOKENS)
        {
            Loop = false;
        }
    }
    return KeyWords[i].m_TokenID;
}

int CLexer::KeyWord::FindInc(AdrModeType AdrMode)
{
    int IncValue = -1;

    IncValue = m_pAddresModeLUT->GetInc(AdrMode);
    if (IncValue < 0)
    {
        sprintf_s(
            ThrownException.GetErrorString(),
            ThrownException.GetMaxStringLen(),
            "Houston, we have a problem Line:%d",
            Act()->GetParser()->GetLexer()->GetLineNumber()
        );
        ThrownException.SetXCeptType(Exception::ExceptionType::INTERNAL_ERROR);
        throw(ThrownException);
    }
    return IncValue;
}

 ---------- LHead.cpp -------------
#include "pch.h"

CLHead::CLHead()
{
    m_Token = Token(0);
    m_pNode = 0;
}

CLHead::~CLHead()
{
}

bool CLHead::Create()
{
    return false;
}

void CLHead::operator=(const CLHead& pLH)
{
    m_Token = pLH.m_Token;
    m_pNode = pLH.m_pNode;
}

 ---------- NumberStackItem.cpp -------------
#include "pch.h"

CNumberStackItem::CNumberStackItem()
{
    m_Value = 0;
}

CNumberStackItem::~CNumberStackItem()
{
}

bool CNumberStackItem::Create()
{
    return CStackItem::Create(CStackItem::ItemType::INTVALUE);
}

 ---------- ObjFormatCode.cpp -------------
#include "pch.h"

CObjFormatCode::CObjFormatCode()
{
    m_BlockSize = 0;
    m_pCode = 0;
    m_StartAddress = 0;
}

CObjFormatCode::~CObjFormatCode()
{
    if (m_pCode) delete m_pCode;
}

bool CObjFormatCode::Create(int StartAddress, int BlockSize, const char* pCode)
{
    m_pCode = new char[BlockSize];
    m_BlockSize = (unsigned short)BlockSize;
    m_StartAddress = (unsigned short)StartAddress;
    memcpy(m_pCode, pCode, BlockSize);
    return CObjFormatSectionItem::Create(CObjFormatSectionItem::FormatType::CODE);
}

void CObjFormatCode::Out(FILE* pOut)
{
}

void CObjFormatCode::Print(FILE* pO, int Indent)
{
}

 ---------- ObjFormatData.cpp -------------
#include "pch.h"

CObjFormatData::CObjFormatData()
{
    m_BlockSize = 0;
    m_Index = 0;
    m_pData = 0;
}

CObjFormatData::~CObjFormatData()
{
    if (m_pData) delete[] m_pData;
}

bool CObjFormatData::Create(int BlockSize)
{
    m_BlockSize = BlockSize;
    m_pData = new char[BlockSize];
    return CObjFormatSectionItem::Create(CObjFormatSectionItem::FormatType::DATA);
}

void CObjFormatData::Out(FILE* pOut)
{
}

void CObjFormatData::Print(FILE* pO, int Indent)
{
}

bool CObjFormatData::AddByte(char d)
{
    bool rV = true;
    if (m_Index + 1 < m_BlockSize)
    {
        m_pData[m_Index++] = d;
    }
    else
        rV = false;
    return 0;
}

 ---------- ObjFormatFile.cpp -------------
#include "pch.h"

CObjFormatFile::CObjFormatFile()
{
    int i;

    for (i = 0; i < 512; ++i)
    {
        m_strName[i] = 0;
    }
    m_pHead = 0;
    m_pTail = 0;
}

CObjFormatFile::~CObjFormatFile()
{
}

bool CObjFormatFile::Create(const char* pName)
{
    bool rV = true;
    int NumberOfSections;
    CSection** ppSections;
    int i;

    fprintf(Act()->GetParser()->LogFile(), "File:%s\n", pName);
    strcpy_s(m_strName, 512, pName);
    NumberOfSections = GetSymTab()->GetSectionCount();
    ppSections = new CSection * [NumberOfSections];
    GetSymTab()->FindAll(CBin::BinType::SECTION, GetSymTab()->GetSectionCount(),(CBin**) ppSections);
    for (i = 0; i < NumberOfSections; ++i)
    {
        AddSection(ppSections[i]);
    }
    Print(Act()->LogFile());
    return rV;
}

CSymTab* CObjFormatFile::GetSymTab()
{
    return Act()->GetParser()->GetLexer()->GetSymTab();
}

void CObjFormatFile::Out(FILE* pOut)
{
    FILE* pLog;

    pLog = Act()->LogFile();
    Print(pLog);
    fprintf(pLog, "Number of section:%d\n", GetSymTab()->GetSectionCount());
    fprintf(pLog,"Number of Symbols:%d", GetSymTab()->GetSymbolCount());
}

void CObjFormatFile::Print(FILE* pO)
{
    CObjFormatSection* pOFS;

    fprintf(pO, "Name:%s\n" ,m_strName);
    pOFS = GetHead();
    while (pOFS)
    {
        pOFS->Print(pO, 2);
        pOFS = pOFS->GetNext();
    }
}

void CObjFormatFile::AddSection(CSection* pSection)
{
    CObjFormatSection* pOFS;

    pOFS = new CObjFormatSection;
    pOFS->Create(pSection);
    AddObjFormatSection(pOFS);
}

void CObjFormatFile::AddObjFormatSection(CObjFormatSection* pOFS)
{
    if (GetHead())
    {
        GetTail()->SetNext(pOFS);
        pOFS->SetPrev(GetTail());
        SetTail(pOFS);
    }
    else
    {
        SetTail(pOFS);
        SetHead(pOFS);
    }
}

 ---------- ObjFormatRelocation.cpp -------------
#include "pch.h"

CObjFormatRelocation::CObjFormatRelocation()
{
}

CObjFormatRelocation::~CObjFormatRelocation()
{
}

bool CObjFormatRelocation::Create()
{
    return 0;
}

void CObjFormatRelocation::Out(FILE* pO)
{
}

void CObjFormatRelocation::Print(FILE* pO, int Indent)
{
}

 ---------- ObjFormatSection.cpp -------------
#include "pch.h"

CObjFormatSection::CObjFormatSection()
{
    m_pSection = 0;
    m_pNext = 0;
    m_pPrev = 0;
    m_pHead = 0;
    m_pTail = 0;
}

CObjFormatSection::~CObjFormatSection()
{
}

bool CObjFormatSection::Create(CSection* pSection)
{
    bool rV = true;

    m_pSection = pSection;
    //--------------------------------
    // Create a list of locations
    // that need to be updated in
    // this section
    //--------------------------------
    return rV;
}

void CObjFormatSection::AddItem(CObjFormatSectionItem* pItem)
{
    if (m_pHead)
    {
        m_pTail->SetNext(pItem);
        pItem->SetPrev(m_pTail);
        m_pTail = pItem;
    }
    else
    {
        m_pTail = pItem;
        m_pHead = pItem;
    }
}

void CObjFormatSection::Print(FILE* pO, int Indent)
{
    char* pStr = new char[256];

    fprintf(pO, "%sSection:%s\n",
        Act()->IndentString(pStr,Indent,' '),
        GetSection()->GetName()
    );
    delete[] pStr;
}

void CObjFormatSection::Out(FILE* pO)
{
}

 ---------- ObjFormatSectionItem.cpp -------------
#include "pch.h"

CObjFormatSectionItem::CObjFormatSectionItem()
{
    m_Type = FormatType::NONE;
    m_pNext = 0;
    m_pPrev = 0;
}

CObjFormatSectionItem::~CObjFormatSectionItem()
{
}

bool CObjFormatSectionItem::Create(FormatType Type)
{
    bool rV = true;
    m_Type = Type;
    return rV;
}

void CObjFormatSectionItem::Out(FILE* pOut)
{
}

void CObjFormatSectionItem::Print(FILE* pO, int Indent)
{
}

const char* CObjFormatSectionItem::LookupFormatSectionType(FormatType Type)
{
    const char* pStr = 0;;
    int i;
    bool Loop = true;

    for (i = 0; FormatStringLUT[i].m_pLutString && Loop; ++i)
    {
        if (Type == FormatStringLUT[i].m_LutType)
        {
            pStr = FormatStringLUT[i].m_pLutString;
            Loop = false;
        }
    }
    return pStr;
}

CObjFormatSectionItem::FormatType CObjFormatSectionItem::LookupFormatSectionType(const char* pName)
{    
    FormatType Type = FormatType::NONE;
    int i;
    bool Loop = true;

    for (i = 0; FormatStringLUT[i].m_pLutString && Loop; ++i)
    {
        if (strcmp(FormatStringLUT[i].m_pLutString, pName) == 0)
        {
            Type = FormatStringLUT[i].m_LutType;
            Loop = false;
        }
    }
    return Type;
}

 ---------- ObjFormatSymbolItem.cpp -------------
#include "pch.h"

CObjFormatSymbolItem::CObjFormatSymbolItem()
{
    int i;

    m_DefinedAddress = 0;
    for (i = 0; i < MAX_SYMBOL_NAME_LEN; ++i)
        m_strName[i] = 0;
}

CObjFormatSymbolItem::~CObjFormatSymbolItem()
{
}

bool CObjFormatSymbolItem::Create(CSymbol* pSym)
{
    return 0;
}

void CObjFormatSymbolItem::Out(FILE* pOut)
{
}

void CObjFormatSymbolItem::Print(FILE* pO)
{
}

 ---------- ObjFormatSymbols.cpp -------------
#include "pch.h"

CObjFormatSymbols::CObjFormatSymbols()
{
}

CObjFormatSymbols::~CObjFormatSymbols()
{
}

bool CObjFormatSymbols::Create()
{
    return 0;
}

void CObjFormatSymbols::Print(FILE* pO, int Indent)
{
}

void CObjFormatSymbols::Out(FILE* pO)
{
}

void CObjFormatSymbols::Add(CObjFormatSymbolItem pSym)
{
}

 ---------- ObjType.cpp -------------
#include "pch.h"

CObjType::CObjType()
{
}

CObjType::~CObjType()
{
}

bool CObjType::Create()
{
    return false;
}

 ---------- Parser.cpp -------------
#include "pch.h"

CParser::CParser()
{
    m_Phase = PHASE::NONE;
    m_pLex = 0;
    m_Processor = Processor::R6502;
    m_pCurrentSection = 0;
    m_Recursion = 0;
    m_Bump = 0;
}

CParser::~CParser()
{
    if (m_pLex)
        delete m_pLex;
}

bool CParser::Create()
{
    bool rV = true;
    m_pLex = new CLexer;
    m_pLex->Create();
    if (LogFile())
        fprintf(LogFile(), "Parser Created\n");
    
    return true;
}

FILE* CParser::LogFile()
{
    return Act()->LogFile();
}

CLHead CParser::Run()
{
    CLHead LookaHead = CLHead(Token(0),0);
    FILE* ErrorDest = 0;

    if (LogFile())
        ErrorDest = LogFile();
    else
        ErrorDest = stderr;
    try {
        LookaHead.m_Token = GetLexer()->Lex();
        LookaHead = Action65(LookaHead);
        GetLexer()->GetSymTab()->PrintTable(LogFile());
//        GetAstTree()->Print(LogFile());
        fprintf(LogFile(), "Lines Compiled:%d\n", GetLexer()->GetLineNumber());
    }
    catch (Exception& BooBoo)
    {
        char* s = new char[256];
        Exception::ExceptionType ExcptType;

        ExcptType = BooBoo.GetXCeptType();
        switch (ExcptType)
        {
        case Exception::ExceptionType::WHOKNOWS:
            fprintf(ErrorDest,
                "%s Line=%d  Col=%d\n",
                BooBoo.GetExceptionTypeString(BooBoo.GetXCeptType()),
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm()
            );
            break;
        case Exception::ExceptionType::UNEXPECTED_TOKEN:
            fprintf(ErrorDest,
                "%s %d:%s  Line:%d Col:%d\n",
                BooBoo.GetExceptionTypeString(BooBoo.GetXCeptType()),
                int(BooBoo.GetGotToken()),
                GetLexer()->GetKeyWords()->LookupToName(BooBoo.GetGotToken()),
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm()
            );
            break;
        case Exception::ExceptionType::SECTION_ADDRES_RANGE_EXCEEDED:
            fprintf(ErrorDest,
                "Section:Address Range Exceeded %d:%s\n%s\n  Line:%d Col:%d\n",
                int(BooBoo.GetGotToken()),
                GetLexer()->GetKeyWords()->LookupToName(BooBoo.GetGotToken()),
                BooBoo.GetErrorString(),
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm()
            );
            break;
        case Exception::ExceptionType::SECTION_UNDEFINED:
            fprintf(ErrorDest,
                "Section Undefined %d:%s  Line:%d Col:%d\n",
                int(BooBoo.GetGotToken()),
                GetLexer()->GetKeyWords()->LookupToName(BooBoo.GetGotToken()),
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm()
            );
            break;
        case Exception::ExceptionType::NOSECTION_DEFINED:
            fprintf(ErrorDest,
                "No Section Defined %d:%s  Line:%d Col:%d\n",
                int(BooBoo.GetGotToken()),
                GetLexer()->GetKeyWords()->LookupToName(BooBoo.GetGotToken()),
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm()
            );
            break;
        case Exception::ExceptionType::LEXER_STUMPTED:
            fprintf(
                ErrorDest,
                "%s",
                BooBoo.GetErrorString()
            );
            break;
        case Exception::ExceptionType::ILLEGAL_ADDRESSING_MODE:
            fprintf(ErrorDest,
                "%s",
                BooBoo.GetErrorString()
            );
            break;
        case Exception::ExceptionType::INTERNAL_ERROR:
            fprintf(
                ErrorDest,
                "Internal Error:%s Line:%d  Col:%d\n",
                BooBoo.GetErrorString(),
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm()
            );
            break;
        case Exception::ExceptionType::STACK:
            fprintf(
                ErrorDest,
                "Error:%s\n",
                BooBoo.GetErrorString()
            );
            break;
        default:
            fprintf(ErrorDest, "Unknown Exception\n");
            break;
        }
        Act()->CloseAll();
        exit(1);
    }
    return LookaHead;
}


//**********************************************
// Expect
//
// This function is used to check that we get
// the token that we Expect.
//
// parameters:
//    Lookahead..Current lookahead token
//    token....this is the token we Expect
// return value:
//    reutns the next Lookahead token (>0)
//    reutnrs 0 or negative if we did not get what we Expected
//*********************************************

Token CParser::Expect(Token LookaHeadToken, Token Expected)
{
    char* pExpectedToken = 0;
    char* pLookaheadToken = 0;
    int number = 0;

    if (LogFile())
    {
        switch (LookaHeadToken)
        {
        case Token::IDENT:
            pLookaheadToken = GetLexer()->GetLexSymbol()->GetName();
            if (LookaHeadToken == Expected)
            {
                pExpectedToken = pLookaheadToken;
            }
            else
                pExpectedToken = (char*)"Unexpected";
            fprintf(LogFile(), "%d::Expected CLHead: %s  Lookahead = %s Line:%d\n",
                m_Recursion,
                pExpectedToken,
                pLookaheadToken,
                GetLexer()->GetLineNumber()
            );
            break;
        case Token::NUMBER:
            number = GetLexer()->GetNumber();;
            pExpectedToken = (char*)GetLexer()->GetKeyWords()->LookupToName(Expected);
            fprintf(LogFile(), "%d::Expected CLHead: %s  Lookahead = %d Line:%d\n",
                m_Recursion,
                pExpectedToken,
                number,
                GetLexer()->GetLineNumber()
            );
            break;
        default:
            pLookaheadToken = (char*)GetLexer()->GetKeyWords()->LookupToName(LookaHeadToken);
            pExpectedToken = (char*)GetLexer()->GetKeyWords()->LookupToName(Expected);
            fprintf(LogFile(), "%d::Expected CLHead: %s  LookaHeadToken = %s Line:%d\n",
                m_Recursion,
                pExpectedToken,
                pLookaheadToken,
                GetLexer()->GetLineNumber()
            );
            break;
        }
    }
    if (Accept(LookaHeadToken, Expected))
        LookaHeadToken = GetLexer()->Lex();
    else
    {
        ThrownException.SetXCeptType(Exception::ExceptionType::UNEXPECTED_TOKEN);
        sprintf_s(
            ThrownException.GetErrorString(),
            ThrownException.GetMaxStringLen(),
            "Line %d: Unexpected CLHead:Got %d Expected %d\n",
            GetLexer()->GetLineNumber(),
            LookaHeadToken,
            Expected
        );
        throw(ThrownException);
    }
    return LookaHeadToken;
}

//********************************************
// Accept
//
// This function compares the token you want
// versus the token that is current.  If they
// match, then we get another token.
// If not, then just return.
//
// parameter:
//    Lookahead..The current lookahead token
//    token.....this is the token we want
//
// return value:
//    returns the new token value (>0)
//    returns 0 or negative if we don't get the token we want
//**********************************************

bool CParser::Accept(Token LookaheadToken, Token Expected)
{
    bool rv = false;

    if (Expected == LookaheadToken)
        rv = true;
    return rv;
}


void CParser::PrepareInstruction(CInstruction** ppInst, Token Op)
{
    *ppInst = new CInstruction;
    (*ppInst)->Create();
    (*ppInst)->SetOpCodeToken(Op);
    (*ppInst)->SetOpcode(
        GetLexer()->LookupOpcode(Op)
    );
    (*ppInst)->SetByteCount(
        GetLexer()->FindKeyword(Op)->m_MaxBytes
    );
}


//---------------------------------
// Parsing Methods
//---------------------------------
// Program Structure
//---------------------------------

CLHead CParser::Action65(CLHead LookaHead)
{
    //--------------------------------------------
    //    Action65->Modules;
    // 
    //--------------------------------------------
    PrintLookahead(LogFile(), LookaHead, "Enter Action65", ++m_Recursion);
    LookaHead = Modules(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit Action65", --m_Recursion);
    return LookaHead;
}

CLHead CParser::Modules(CLHead LookaHead)
{
    //--------------------------------------------
    //    Modules        -> Vector Modules_1;
    //--------------------------------------------
    //    Modules_1    -> 'MODULE' Vector Modules_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Modules", ++m_Recursion);
    LHChild = Vector(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::MODULE:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::MODULE);
            LHNext = Vector(LHNext);
            pN = new CAct65Module;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token::EOL:
            Loop = false;
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Module", --m_Recursion);
    return LHChild;
}

CLHead CParser::Vector(CLHead LookaHead)
{
    //--------------------------------------------
    //    Vector        ->SysDecl Vector_1;
    //    Vector_1    -> 'VECTOR' VectorAddress SysDecl Vector_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Vector", ++m_Recursion);
    LHChild = SysDecl(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::VECTOR:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::VECTOR);
            LHNext = VectorAddress(LHNext);
            pN = new CAct65VECTOR;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //--------------------------------------
            LHChild = SysDecl(LHChild);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Vector", --m_Recursion);
    return LHChild;
}

CLHead CParser::VectorAddress(CLHead LookaHead)
{
    //--------------------------------------------
    //    VectorAddress    -> '(' CompConst ')' VectorData;
    //    VectorData        -> '=' CompConst;
    //--------------------------------------------
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter VectorAddress", ++m_Recursion);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
    LHChild = CompConst(LookaHead);    // Vector Address
    LHNext.m_Token = Expect(LHChild.GetToken(), Token(')'));
    LHNext.m_Token = Expect(LHNext.GetToken(), Token('='));
    LHNext = CompConst(LHNext);    // Vector Data
    pN = new CAct65VECTOR;
    pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
    LHChild.m_pNode = pN;
    LHChild.m_Token = LHNext.GetToken();
    PrintLookahead(LogFile(), LookaHead, "Exit VectorAddress", --m_Recursion);
    return LHChild;
}

//------------------------------------------
// Statements
//------------------------------------------

CLHead CParser::Statements(CLHead LookaHead)
{
    //--------------------------------------------
    // Statements        ->ForStmt ProcCall_1;
    //--------------------------------------------
    // ProcCall_1        -> 'PROC_IDENT' ProcParams ForStmt ProcCall_1
    //                    -> 'FUNC_IDENT' ProcParams ForStmt ProcCall_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Statements", ++m_Recursion,1);
    LHChild = ForStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::PROC_IDENT:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::PROC_IDENT);
            LHNext = ProcParams(LHNext);
            pN = new CAct65ProcCall;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //--------------------------------------------
            LHChild = ForStmt(LHChild);
            break;
        case Token::FUNC_IDENT:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::FUNC_IDENT);
            LHNext = ProcParams(LookaHead);
            pN = new CAct65FuncCall;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //-----------------------------------------
            LookaHead = ForStmt(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Statements", --m_Recursion,-1);
    return LHChild;
}

CLHead CParser::ProcParams(CLHead LookaHead)
{
    //--------------------------------------------
    //    ProcParams    -> '(' ValueList ')'
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ProcParams", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token('('):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LHNext = MemContents(LookaHead);
        pN = new CAct65FuncCall;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        LHChild.m_Token = Expect(LHNext.GetToken(), Token(')'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit ProcParams", --m_Recursion);
    return LHChild;
}

CLHead CParser::ForStmt(CLHead LookaHead)
{
    //--------------------------------------------
    //    ForStmt        -> IfStmt ForStmt_1;
    //    ForStmt_1    -> 'FOR' STEPoption DoStmt ForStmt_1
    //        -        > .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ForStmt", ++m_Recursion);
    LHChild = IfStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::FOR:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::FOR);
            LookaHead = STEPoption(LookaHead);
            LookaHead = DoStmt(LookaHead);
            pN = new CAct65FOR;;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //-------------------------------------------------
            LHChild = IfStmt(LHChild);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit ForStmt", --m_Recursion);
    return LHChild;
}

CLHead CParser::STEPoption(CLHead LookaHead)
{
    //--------------------------------------------
    //    STEPoption        ->ForTO STEPoption_1;
    //    STEPoption_1    -> 'STEP' ArithExpr
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Step", ++m_Recursion);
    LHChild = ForTO(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::STEP:
        LHNext.m_Token = Expect(LHChild.GetToken(), Token::STEP);
        LHNext = ArithExpr(LHNext);
        pN = new CAct65ForSTEP;;;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit Step", --m_Recursion);
    return LHChild;
}

CLHead CParser::ForTO(CLHead LookaHead)
{
    //--------------------------------------------
    //    ForTO        ->Itterrator ForTO_1;
    //    ForTO_1    -> 'TO' ArithExpr
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Finish", ++m_Recursion);
    LHChild = Iterator(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::TO:
        LookaHead.m_Token = Expect(LHChild.GetToken(), Token::TO);
        LHNext = ArithExpr(LHChild);
        pN = new CAct65ForTO;;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Finish", --m_Recursion);
    return LookaHead;
}

CLHead CParser::Iterator(CLHead LookaHead)
{
    //--------------------------------------------
    //    Itterrator        ->MemContentsType Itterrator_1;
    //    Itterrator_1    -> '=' ArithExpr
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Iterator", ++m_Recursion);
    LHChild = MemContentsType(LHChild);
    switch (LHChild.GetToken())
    {
    case Token('='):
        LHChild.m_Token = Expect(LHChild.GetToken(), Token('='));
        LHNext = ArithExpr(LHChild);
        pN = new CAct65Assignment;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit Itterator", --m_Recursion);
    return LHChild;
}

//-----------------------------------------------
// If Statement
//-----------------------------------------------

CLHead CParser::IfStmt(CLHead LookaHead)
{
    //--------------------------------------------
    //    IfStmt        -> Iff IfStmt_1;
    //    IfStmt_1    -> 'IF' EndIF Iff IfStmt_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IfStmt", ++m_Recursion);
    LHChild = IffStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::IF:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::IF);
            LHNext = EndIf(LHNext);
            pN = new CAct65IF;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //-------------------------------------------
            LHChild = IffStmt(LHChild);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit IfStmt", --m_Recursion);
    return LHChild;
}

CLHead CParser::EndIf(CLHead LookaHead)
{
    //--------------------------------------------
    //    EndIF    ->ElsePart EndIF_1;
    //    EndIF_1    -> 'FI';
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter EndIf", ++m_Recursion);
    LHChild = ElsePart(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::FI:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::FI);
            pN = new CAct65FI;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //------------------------------------------------
            Loop = false;
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit EndIf(FI)", --m_Recursion);
    return LHChild;
}

CLHead CParser::ElsePart(CLHead LookaHead)
{
    //--------------------------------------------
    //    ElsePart    ->ElseIfPart ElsePart_1;
    //    ElsePart_1    -> 'ELSE' Statements
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ElsePart", ++m_Recursion);
    LHChild = ElseIfPart(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::ELSE:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::ELSE);
            LHNext = Statements(LHNext);
            pN = new CAct65ELSE;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit ElsePart", --m_Recursion);
    return LHChild;
}
CLHead CParser::ElseIfPart(CLHead LookaHead)
{
    //--------------------------------------------
    //ElseIfPart    ->ThenPart ElseIfPart_1;
    //ElseIfPart_1    -> 'ELSEIF' ThenPart ElseIfPart_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ElseIfPart", ++m_Recursion);
    LHChild = ThenPart(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::ELSEIF:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::THEN);
            LHNext = ThenPart(LHNext);
            pN = new CAct65ELSEIF;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //----------------------------------------------------
            LHChild = ElsePart(LHChild);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit ElseIfPart", --m_Recursion);
    return LHChild;
}


CLHead CParser::ThenPart(CLHead LookaHead)
{
    //--------------------------------------------
    //    ThenPart    ->RelOperation ThenPart_1;
    //    ThenPart_1    -> 'THEN' Statements
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Then Part", ++m_Recursion);
    LHChild = RelOperation(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::THEN:
        LHNext.m_Token = Expect(LHChild.GetToken(), Token::THEN);
        LHNext = Statements(LHNext);
        pN = new CAct65THEN;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit Then Part", --m_Recursion);
    return LHChild;
}

//------------------------------------------------
// IFF Statement
//------------------------------------------------
CLHead CParser::IffStmt(CLHead LookaHead)
{
    //--------------------------------------------
    //    Iff        ->WhileStmt Iff_1;
    //    Iff_1    -> 'IFF' IFFend WhileStmt Iff_1
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IFFStmt", ++m_Recursion);
    LHChild = WhileStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::IFF:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::IFF);
            LHNext = IFFend(LHNext);
            pN = new CAct65IFF;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            //-------------------------------------------
            LHChild = WhileStmt(LHChild);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit IFFStmt", --m_Recursion);
    return LHChild;
}

CLHead CParser::IFFend(CLHead LookaHead)
{
    //--------------------------------------------
    //    IFFend        ->IFFelse IFFend_1;
    //    IFFend_1    -> 'FFI';
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IFFend", ++m_Recursion);
    LHChild = IFFelse(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::FFI:
        LHNext.m_Token = Expect(LHChild.GetToken(), Token::FFI);
        pN = new CAct65IFF;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        Loop = false;
        break;
    default:
        Loop = false;
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit IFFend", --m_Recursion);
    return LHChild;

}

CLHead CParser::IFFelse(CLHead LookaHead)
{
    //--------------------------------------------
    //    IFFelse        ->IFFthenpart IFFelse_1;
    //    IFFelse_1    -> 'ELSE' Statements
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IFFelse", ++m_Recursion);
    LHChild = IFFthenpart(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::ELSE:
        LHNext.m_Token = Expect(LHChild.GetToken(), Token::ELSE);
        LHNext = Statements(LHNext);
        pN = new CAct65ELSE;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit IFFelse", --m_Recursion);
    return LHChild;

}

CLHead CParser::IFFthenpart(CLHead LookaHead)
{
    //--------------------------------------------
    //    IFFthenpart        ->IffConditional IFFthenpart_1;
    //    IFFthenpart_1    -> 'THEN' Statements
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IFFthenpart", ++m_Recursion);
    LHChild = IffConditional(LookaHead);
    switch (LHChild.GetToken())
    {
        case Token::THEN:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::THEN);
        LookaHead = Statements(LookaHead);
        pN = new CAct65THEN;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        //---------------------------------------------
        LHChild = Statements(LHChild);
        break;
        default:
            break;
        }
    PrintLookahead(LogFile(), LHChild, "Exit IFFthenpart", --m_Recursion);
    return LHChild;

}

CLHead CParser::IffConditional(CLHead LookaHead)
{
    //--------------------------------------------
    //    IffConditional        ->Bits IffConditional_1;
    //    IffConditional_1    -> 'AREG' RelOper
    //                        -> 'XREG' RelOper
    //                        -> 'YREG' RelOper
    //                        -> .
    //                        ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IffConditional", ++m_Recursion);
    LHChild = Bits(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::AREG:
        LHNext.m_Token = Expect(LHChild.GetToken(), Token::AREG);
        LHNext = RelOper(LHNext);
        pN = new CAct65ACC;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    case Token::XREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::XREG);
        LHNext = RelOper(LHNext);
        pN = new CAct65XREG;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    case Token::YREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::YREG);
        LHNext = RelOper(LHNext);
        pN = new CAct65YREG;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit IffConditional", --m_Recursion);
    return LHChild;

}

CLHead CParser::RelOper(CLHead LookaHead)
{
    //--------------------------------------------
    //    RelOper    -> '<' Value
    //            -> 'GTEQ' Value
    //            -> '=' Value
    //            -> .
    //            ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter RelOper", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token('<'):
        LHNext.m_Token = Expect(LHChild.GetToken(), Token('<'));
        LHNext = Value(LHNext);
        pN = new CAct65LessTHAN;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
        case Token::GTEQ:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::GTEQ);
        LHNext = Value(LHNext);
        pN = new CAct65GTEQ;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    case Token('='):
        LHNext.m_Token = Expect(LHChild.GetToken(), Token('='));
        LHNext = Value(LHNext);
        pN = new CAct65EqualTO;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LHChild.m_pNode = pN;
        LHChild.SetToken(LHNext.GetToken());
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit RelOper", --m_Recursion);
    return LHChild;

}

CLHead CParser::Bits(CLHead LookaHead)
{
    //--------------------------------------------
    //    Bits    ->StatusFlags Bits_1;
    //    Bits_1    -> 'BITS' BitValue
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Bits", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::BITS:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BITS);
        LookaHead = BitValue(LookaHead);
        break;
    default:
        Loop = false;
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Bits", --m_Recursion);
    return LHChild;

}

CLHead CParser::BitValue(CLHead LookaHead)
{
    //--------------------------------------------
    //    BitValue    -> '[' ArithExpr ']';
    //--------------------------------------------
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter BitValue", ++m_Recursion);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('['));
    LHChild = ArithExpr(LookaHead);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(']'));
    PrintLookahead(LogFile(), LookaHead, "Exit BitValue", --m_Recursion);
    return LHChild;

}

CLHead CParser::StatusFlags(CLHead LookaHead)
{
    //--------------------------------------------
    //    StatusFlags        ->OptNot StatusFlags_1;
    //    StatusFlags_1    -> 'NEG'        //negative flag
    //                    -> 'CARRY'        //Carry flag
    //                    -> 'ZERO'        //Zero
    //                    -> 'OVERFLOW'        //Overflow
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter StatusFlags", ++m_Recursion);
    LHChild = OptNot(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::NEG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::NEG);
        break;
    case Token::ZERO:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ZERO);
        break;
    case Token::CARRY:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CARRY);
        break;
    case Token::OVERFLOW:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::OVERFLOW);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit StatusFlags", --m_Recursion);
    return LHChild;

}

CLHead CParser::OptNot(CLHead LookaHead)
{
    //--------------------------------------------
    //    OptNot    -> '^'
    //            -> .
    //            ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptNot", ++m_Recursion);
    switch (LookaHead.GetToken())
    {
    case Token('^'):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('^'));
        pN = new CAct65OptNOT;
        pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
        LookaHead.m_pNode = pN;
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit OptNot", --m_Recursion);
    return LookaHead;

}


//-------------------------------------------------
// WHILE Statement
//-------------------------------------------------

CLHead CParser::WhileStmt(CLHead LookaHead)
{
    //--------------------------------------------
    // WhileStmt        -> DoStmt WhileStmt_1;
    // WhileStmt_1        -> 'WHILE' RelOperation  DoStmt WhileStmt_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter WhileStmt", ++m_Recursion);
    LHChild = DoStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::WHILE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::WHILE);
            LookaHead = RelOperation(LookaHead);
            LookaHead = DoStmt(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit WhileStmt", --m_Recursion);
    return LookaHead;
}

//------------------------------------------------
// DO Statement
//------------------------------------------------

CLHead CParser::DoStmt(CLHead LookaHead)
{
    //--------------------------------------------
    //    DoStmt        ->EXITstmt DoStmt_1;
    //    DoStmt_1    -> 'DO' DoEnd EXITstmt DoStmt_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter DO Stmt", ++m_Recursion);
    LHChild = EXITstmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::DO:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DO);
            LookaHead = Statements(LookaHead);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::OD);
            LookaHead = EXITstmt(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit DoStmt", --m_Recursion);
    return LookaHead;
}

CLHead CParser::DoEND(CLHead LookaHead)
{
    //--------------------------------------------
    //    DoEnd        ->Statements DoEnd_1;
    //    DoEnd_1        -> 'OD'
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter DoEND", ++m_Recursion);
    LHChild = Statements(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::OD:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::OD);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit DoEND", --m_Recursion);
    return LHChild;

}

//---------------------------------------------------
// EXIT Statement
//---------------------------------------------------

CLHead CParser::EXITstmt(CLHead LookaHead)
{
    //--------------------------------------------
    // EXITstmt        -> RetStmt EXITstmt_1;
    // EXITstmt_1    -> 'EXIT' EXITstmt_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter EXITstmt", ++m_Recursion);
    LHChild = RetStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::EXIT:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::EXIT);
            LookaHead = RetStmt(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit EXITstmt", --m_Recursion);
    return LookaHead;
}

//-----------------------------------------------
// RETURN statement
//-----------------------------------------------
CLHead CParser::RetStmt(CLHead LookaHead)
{
    //--------------------------------------------
    // RetStmt        -> InlineAssembly RetStmt_1;
    // RetStmt_1    -> 'RETURN' OptReturnValue  InlineAssembly RetStmt_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter RetStmt", ++m_Recursion);
    LHChild = InlineAssembly(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::RETURN:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::RETURN);
            LookaHead = OptReturnValue(LookaHead);
            LookaHead = InlineAssembly(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit RetStmt", --m_Recursion);
    return LHChild;
}

CLHead CParser::OptReturnValue(CLHead LookaHead)
{
    //--------------------------------------------
    // OptReturnValue    -> '(' ArithExpr OptReturnValue
    //                    -> ')'
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptRetValue", ++m_Recursion);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
    LookaHead = ArithExpr(LookaHead);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
    PrintLookahead(LogFile(), LookaHead, "Exit OptReturnValue", --m_Recursion);
    return LookaHead;
}

//---------------------------------------------
// Inline Assembly Code
//---------------------------------------------

CLHead CParser::InlineAssembly(CLHead LookaHead)
{
    //--------------------------------------------
    //    InlineAssembly        ->CodeBlock InlineAssembly_1;
    //    InlineAssembly_1    -> 'ASM' InlineAssBlock CodeBlock InlineAssembly_1
    //                        -> .
    //                        ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter InLineAssembly", ++m_Recursion);
    LHChild = CodeBlock(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::ASM:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASM);
            LookaHead = InlineAssBlock(LookaHead);
            LookaHead = CodeBlock(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit InLineAssembly", --m_Recursion);
    return LHChild;
}

CLHead CParser::InlineAssBlock(CLHead LookaHead)
{
    //--------------------------------------------
    //    InlineAssBlock        ->EndAsmBlock InlineAssBlock_1;
    //    InlineAssBlock_1    -> '{'  EndAsmBlock InlineAssBlock_1
    //                        -> .
    //                        ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter InLineAsmBlock", ++m_Recursion);
    LHChild = EndAsmBlock(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('{'):
            GetLexer()->SetAsmMode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('{'));
            GetLexer()->SetAsmMode();
            LookaHead = EndAsmBlock(LookaHead);
            break;
        default:
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit InLineAsmBlock", --m_Recursion);
    return LHChild;
}

CLHead CParser::EndAsmBlock(CLHead LookaHead)
{
    //--------------------------------------------
    //    EndAsmBlock        ->AsmStmt EndAsmBlock_1;
    //    EndAsmBlock_1    -> '}'
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter EndAsmBlock", ++m_Recursion);
    LHChild = AsmStmt(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token('}'):
        GetLexer()->SetActionMode();
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('}'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit EndAsmBlock", --m_Recursion);
    return LHChild;

}

//-----------------------------------------------
// CODE (Kluge) BLOCK statement
//-----------------------------------------------

CLHead CParser::CodeBlock(CLHead LookaHead)
{
    //--------------------------------------------
    //    CodeBlock        ->UntillStmt CodeBlock_1;
    //    CodeBlock_1        -> '[' CodeBlockEnd UntillStmt CodeBlock_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter CodeBlock", ++m_Recursion);
    LHChild = UntillStmt(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('['):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('['));
            LookaHead = CodeBlockEnd(LookaHead);
            LookaHead = UntillStmt(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit CodeBlock", --m_Recursion);
    return LHChild;
}

CLHead CParser::CodeBlockEnd(CLHead LookaHead)
{
    //--------------------------------------------
    //    CodeBlockEnd    ->ConstList CodeBlockEnd_1;
    //    CodeBlockEnd_1    -> ']'
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter CodeBlockEnd", ++m_Recursion);
    LHChild = ConstList(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token(']'):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(']'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit CodeBlockEnd", --m_Recursion);
    return LHChild;

}

//---------------------------------------------------
// UNTILE Statement
//---------------------------------------------------

CLHead CParser::UntillStmt(CLHead LookaHead)
{
    //--------------------------------------------
    //    UntillStmt        ->Push UntillStmt_1;
    //    UntillStmt_1    -> 'UNTILL' RelOperation Push UntillStmt_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter UntillStmt", ++m_Recursion);
    LHChild = Push(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::UNTIL:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::UNTIL);
            LookaHead = RelOperation(LookaHead);
            LookaHead = Push(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit UntilStmt", --m_Recursion);
    return LHChild;
}

//-------------------------------------------------
// PUSH statment
//-------------------------------------------------
CLHead CParser::Push(CLHead LookaHead)
{
    //--------------------------------------------
    //    Push    ->Pop Push_1;
    //    Push_1    -> 'PUSH' PushSourceList Pop Push_1
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Push", ++m_Recursion);
    LHChild = Pop(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::PUSH:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PUSH);
            LookaHead = PushSourceList(LookaHead);
            LookaHead = Pop(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Push", --m_Recursion);
    return LHChild;

}

CLHead CParser::PushSourceList(CLHead LookaHead)
{
    //--------------------------------------------
    //    PushSourceList        ->PushSource PushSourceList_1;
    //    PushSourceList_1    -> ',' PushSource PushSourceList_1
    //                        -> .
    //                        ;
    //--------------------------------------------
        bool Loop = true;
        CAstNode* pN= 0;
        CLHead LHChild, LHNext;

        PrintLookahead(LogFile(), LookaHead, "Enter PushSourceList", ++m_Recursion);
        LHChild = PushSource(LookaHead);
        while (Loop)
        {
            switch (LHChild.GetToken())
            {
            case Token(','):
                LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
                LookaHead = PushSource(LookaHead);
                break;
            default:
                Loop = false;
                break;
            }
        }
        PrintLookahead(LogFile(), LookaHead, "Exit PushSourceList", --m_Recursion);
        return LHChild;

}

CLHead CParser::PushSource(CLHead LookaHead)
{
    //--------------------------------------------
    //    PushSource        ->ArithExpr PushSource_1;
    //    PushSource_1    -> 'AREG'
    //                    -> 'XREG'
    //                    -> 'YREG'
    //                    -> 'SR'
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter PushSource", ++m_Recursion);
    LHChild = ArithExpr(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::AREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::AREG);
        break;
    case Token::XREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::XREG);
        break;
    case Token::YREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::YREG);
        break;
    case Token::PSREG:    //processor status register
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PSREG);
        break;
    default:
        Loop = false;
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit PushSource", --m_Recursion);
    return LHChild;

}

//--------------------------------------------------
// POP Statement
//--------------------------------------------------

CLHead CParser::Pop(CLHead LookaHead)
{
    //--------------------------------------------
    //    Pop        ->Break Pop_1;
    //    Pop_1    -> 'POP' PopDestList Break Pop_1
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Pop", ++m_Recursion);
    LHChild = Break(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::POP:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::POP);
            LookaHead = PopDestList(LookaHead);
            LookaHead = Break(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Pop", --m_Recursion);
    return LHChild;

}

CLHead CParser::PopDestList(CLHead LookaHead)
{
    //--------------------------------------------
    //    PopDestList        ->PopDest PopDestList_1;
    //    PopDestList_1    -> ',' PopDest PopDestList_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter PopDestList", ++m_Recursion);
    LHChild = PopDest(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            LookaHead = PopDest(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit PopDestList", --m_Recursion);
    return LHChild;

}

CLHead CParser::PopDest(CLHead LookaHead)
{
    //--------------------------------------------
    //    PopDest        ->MemContentsType PopDest_1;
    //    PopDest_1    -> 'AREG'
    //                -> 'XREG'
    //                -> 'YREG'
    //                -> 'PSREG'
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter PopDest", ++m_Recursion);
    LHChild = MemContentsType(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::AREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::AREG);
        break;
    case Token::XREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::XREG);
        break;
    case Token::YREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::YREG);
        break;
    case Token::PSREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PSREG);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit PopDest", --m_Recursion);
    return LHChild;

}

//--------------------------------------------------
// BREAK Statement
//--------------------------------------------------

CLHead CParser::Break(CLHead LookaHead)
{
    //--------------------------------------------
    //    Break    ->Rti Break_1;
    //    Break_1    -> 'BREAK' Rti Break_1
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Break", ++m_Recursion);
    LHChild = Rti(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::BREAK:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BREAK);
            LookaHead = Rti(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Break", --m_Recursion);
    return LHChild;

}

//--------------------------------------------------
// RTI Statement
//--------------------------------------------------

CLHead CParser::Rti(CLHead LookaHead)
{
    //--------------------------------------------
    //    Rti        ->Assignment Rti_1;
    //    Rti_1    -> 'RTI' Assignment Rti_1
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Rti", ++m_Recursion);
    LHChild = Assignment(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::RTI:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::RTI);
            LookaHead = Assignment(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Rti", --m_Recursion);
    return LHChild;

}

//---------------------------------------------------
// Assignment Statements
//---------------------------------------------------

CLHead CParser::Assignment(CLHead LookaHead)
{
    //--------------------------------------------
    // Assignment    -> MemContents Assignment_1;
    //--------------------------------------------
    // Assignment_1    ->  '=' ArithExpr Assignment_1
    //                -> '==+' ArithExpr Assignment_1
    //                ->  '==-' ArithExpr Assignment_1
    //                ->  '==*' ArithExpr Assignment_1
    //                ->  '==/' ArithExpr Assignment_1
    //                ->  '==MOD' ArithExpr Assignment_1
    //                ->  '==&' ArithExpr Assignment_1
    //                ->  '==!' ArithExpr Assignment_1     //XOR
    //                ->  '==%' ArithExpr Assignment_1     //OR
    //                ->  '==LSH' ArithExpr Assignment_1
    //                ->  '==RSH' ArithExpr Assignment_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;
    CAstNode* pChildNode = 0, * pNextNode = 0;
    union NodeTypes {
        CAstNode* m_pAstNode;
        CAct65AssignADD* m_pAssAdd;
        CAct65AssignAND* m_pAssAnd;
        CAct65AssignDIV* m_pASSDiv;
        CAct65AssignLSh* m_pAssLSH;
        CAct65Assignment* m_pAssignment;
        CAct65AssignMOD* m_pAssMod;
        CAct65AssignMULT* m_pAssMult;
        CAct65AssignOR* m_pAssOr;
        CAct65AssignRSH* m_pAssRSH;
        CAct65AssignSUB* m_pAssSub;
        CAct65AssignXOR* m_pAssXor;
    }Nodes = NodeTypes(0);


    PrintLookahead(LogFile(), LookaHead, "Enter Assignment", ++m_Recursion);
    LHChild = MemContents(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('='):
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssignment = new CAct65Assignment;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_ADD:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_ADD);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssAdd = new CAct65AssignADD;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_AND:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_AND);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssAnd = new CAct65AssignAND;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_DIV:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_DIV);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pASSDiv = new CAct65AssignDIV;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_LSH:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_LSH);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssLSH = new CAct65AssignLSh;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_MOD:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_MOD);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssMod = new CAct65AssignMOD;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_MUL:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_MUL);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssMult = new CAct65AssignMULT;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_OR:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_OR);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssOr = new CAct65AssignOR;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_RSH:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_RSH);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssRSH = new CAct65AssignRSH;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_SUB:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_SUB);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssSub = new CAct65AssignSUB;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        case Token::ASSIGN_XOR:
            pChildNode = LookaHead.GetNode();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ASSIGN_XOR);
            LookaHead = ArithExpr(LookaHead);
            Nodes.m_pAssXor = new CAct65AssignXOR;
            pNextNode = LookaHead.GetNode();
            Nodes.m_pAssignment->CreateNode(pChildNode, pNextNode);
            LookaHead.SetNode(Nodes.m_pAstNode);
            LookaHead = MemContents(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Assignment", --m_Recursion);
    return LHChild;
}

//----------------------------------------------
// Relation Operations
//----------------------------------------------

CLHead CParser::RelOperation(CLHead LookaHead)
{
    //--------------------------------------------
    // RelOperation    -> LogicalOR RelOperation_1;
    // RelOperation_1    -> '>' LogicalOR RelOperation_1
    //                    -> '<' LogicalOR RelOperation_1
    //                    -> 'GTEQ' LogicalOR RelOperation_1
    //                    -> 'LTEQ' LogicalOR RelOperation_1
    //                    -> '=' LogicalOR RelEquals_1
    //                    -> '#' LogicalOR RelEquals_1    //not equal
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter RelOperations", ++m_Recursion);
    LHChild = LogicalOR(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::GTEQ:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::GTEQ);
            LHNext = LogicalOR(LHNext);
            pN = new CAct65GTEQ;;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token::LTEQ:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::LTEQ);
            LHNext = LogicalOR(LHNext);
            pN = new CAct65LTEQ;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token('<'):
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('<'));
            LHNext = LogicalOR(LHNext);
            pN = new CAct65LessTHAN;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token('>'):
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('>'));
            LHNext = LogicalOR(LHNext);
            pN = new CAct65GreaterTHAN;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token('='):
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('='));
            LHNext = LogicalOR(LHNext);
            pN = new CAct65EqualTO;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
        case Token('#'):    // not equals
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('#'));
            LHNext = LogicalOR(LHNext);
            pN = new CAct65NotEquelTO;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
                break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit RelOperations", --m_Recursion);
    return LHChild;
}

CLHead CParser::LogicalOR(CLHead LookaHead)
{
    //--------------------------------------------
    // LogicalOR    -> LogicalAND LogicalOR_1;
    // LogicalOR_1    -> 'OR' LogicalAND LogicalOR_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LogicalOR", ++m_Recursion);
    LHChild = LogicalAND(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::OR:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::OR);
            LHNext = LogicalOR(LHNext);
            pN = new CAct65GreaterTHAN;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LogicalOR", --m_Recursion);
    return LHChild;
}

CLHead CParser::LogicalAND(CLHead LookaHead)
{
    //--------------------------------------------
    // LogicalAND        -> RelOperation LogicalAND_1;
    // LogicalAND_1    -> 'AND' RelOperation LogicalAND_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LogicalAND", ++m_Recursion);
    LHChild = ArithExpr(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::AND:
            LHNext.m_Token = Expect(LookaHead.GetToken(), Token::AND);
            LHNext = ArithExpr(LookaHead);
            pN = new CAct65LogicalAND;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LogicalAND", --m_Recursion);
    return LHChild;
}

//--------------------------------------
// Arithmetic Expressions
//--------------------------------------


CLHead CParser::ArithExpr(CLHead LookaHead)
{
    //--------------------------------------------
    // ArithExpr    -> BitwiseAND BitwiseOR_1;
    // BitwiseOR_1    -> '%' BitwiseAND BitwiseOR_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ArithExpr/BitwiseOR", ++m_Recursion);
    LHChild = BitwiseAND(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('%'):    
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('%'));
            LHNext = BitwiseAND(LHNext);
            pN = new CAct65BitWiseOR;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ArithExpr/BitwiseOR", --m_Recursion);
    return LHChild;
}

CLHead CParser::BitwiseAND(CLHead LookaHead)
{
    //--------------------------------------------
    // BitwiseAND        -> BitwiseXOR BitwiseAND_1;
    // BitwiseAND_1    -> '&' BitwiseXOR BitwiseAND_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter BitwiseAND", ++m_Recursion);
    LHChild = BitwiseXOR(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('&'):    // not equals
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('&'));
            LHNext = BitwiseXOR(LHNext);
            pN = new CAct65BitWiseAND;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit BitwiseAND", --m_Recursion);
    return LHChild;
}

CLHead CParser::BitwiseXOR(CLHead LookaHead)
{
    //--------------------------------------------
    // BitwiseXOR    -> AddExpr BitwiseXOR_1;
    // BitwiseXOR_1    -> '!' AddExpr BitwiseXOR_1
    //                -> 'XOR' AddExpr BitwiseXOR_1
    //                -> 'EOR' AddExpr BitwiseXOR_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter BitwiseXOR", ++m_Recursion);
    LHChild = AddExpr(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('!'):
        case Token::EOR:
        case Token::XOR:    
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::XOR);
            LHNext = AddExpr(LHNext);
            pN = new CAct65XOR;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit BitwiseXOR", --m_Recursion);
    return LHChild;
}

CLHead CParser::AddExpr(CLHead LookaHead)
{
    //--------------------------------------------
    // AddExpr    -> ShifExpr AddExpr_1;
    // AddExpr_1    -> '+' ShifExpr AddExpr_1
    //                -> '-' ShifExpr AddExpr_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AddExpr", ++m_Recursion);
    LHChild = ShifExpr(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('+'):    
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('+'));
            LHNext = ShifExpr(LHNext);
            pN = new CAct65ADD;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token('-'):    
            LHNext.m_Token = Expect(LHChild.GetToken(), Token('-'));
            LHNext = ShifExpr(LookaHead);
            pN = new CAct65SUB;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit AddExpr", --m_Recursion);
    return LHChild;
}

CLHead CParser::ShifExpr(CLHead LookaHead)
{
    //--------------------------------------------
    // ShifExpr    -> MultExpr ShiftExpr_1;
    // ShiftExpr_1    -> 'LSH' MultExpr ShiftExpr_1
    //                -> 'RSH' MultExpr ShiftExpr_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN = 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ShiftExpr", ++m_Recursion);
    LHChild = MultExpr(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::LSH:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::LSH);
            LHNext = MultExpr(LHNext);
            pN = new CAct65LSH;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        case Token::RSH:
            LHNext.m_Token = Expect(LHChild.GetToken(), Token::RSH);
            LHNext = MultExpr(LookaHead);
            pN = new CAct65RSH;
            pN->CreateNode(LHChild.GetNode(), LHNext.GetNode());
            LHChild.m_pNode = pN;
            LHChild.SetToken(LHNext.GetToken());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ShiftExpr", --m_Recursion);
    return LHChild;
}

CLHead CParser::MultExpr(CLHead LookaHead)
{
    //--------------------------------------------
    // MultExpr    -> Unary MultExpr_1;
    // MultExpr_1    -> '*' Unary MultExpr_1
    //                -> '/' Unary MultExpr_1
    //                -> 'MOD' Unary MultExpr_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter MultExpr", ++m_Recursion);
    LHChild = Unary(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('*'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('*'));
            LookaHead = Unary(LookaHead);
            break;
        case Token('/'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('/'));
            LookaHead = Unary(LookaHead);
        case Token::MOD:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::MOD);
            LookaHead = Unary(LookaHead);
            break;

        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit MultExpr", --m_Recursion);
    return LHChild;
}


CLHead CParser::Unary(CLHead LookaHead)
{
    //--------------------------------------------
    // Unary    -> '-' Unary
    //            -> Factor
    //            ;
    // I really wanted to call this Urinary
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Urnary", ++m_Recursion);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('-'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('-'));
            break;
        default:
            Loop = false;
            break;
        }
    }
    LookaHead = Factor(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit Unary", --m_Recursion);
    return LookaHead;
}

CLHead CParser::Factor(CLHead LookaHead)
{
    //--------------------------------------------
    //    Factor        ->Value Factor_1;
    //    Factor_1    -> '(' ArithExpr ')'
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Factor", ++m_Recursion);
    LHChild = MemContents(LookaHead);
    switch (LHChild.GetToken())
    {
        case Token::FUNC_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::FUNC_IDENT);
        LookaHead = ProcParams(LookaHead);
        break;
    case Token('('):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LookaHead = RelOperation(LookaHead);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
        break;
    default:
        Loop = false;
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Factor", --m_Recursion);
    return LHChild;
}

//--------------------------------------------
// Fundemental Declarations.  These are the
// base types that every thing is based on
//--------------------------------------------


//-------------------------------------------
// Declarations
//-------------------------------------------

CLHead CParser::SysDecl(CLHead LookaHead)
{
    //--------------------------------------------
    // SysDecl    -> TypeDefDecl Define;
    // Define    -> 'DEFINE' DefList TypeDefDecl Define
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter SysDecl", ++m_Recursion);
    LHChild = TypeDefDecl(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::DEFINE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DEFINE);
            LookaHead = DefList(LookaHead);
            LookaHead = TypeDefDecl(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit SysDecl", --m_Recursion);
    return LHChild;
}

CLHead CParser::DefList(CLHead LookaHead)
{
    //--------------------------------------------
    // DefList    -> Def DefList_1;
    // DefList_1    -> ',' Def DefList_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter DefList", ++m_Recursion);
    LHChild = Def(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            LookaHead = Def(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit DefList", --m_Recursion);
    return LHChild;
}

CLHead CParser::Def(CLHead LookaHead)
{
    //--------------------------------------------
    // Def        -> IDENT '=' CompConst;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter DEF", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = CompConst(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit DEF", --m_Recursion);
    return LHChild;
}

//--------------------------------------
// TYPE Definition
//--------------------------------------

CLHead CParser::TypeDefDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    TypeDefDecl        ->FundDecl TypeDefDecl_1;
    //    TypeDefDecl_1    -> 'TYPE' EndTypeDef FundDecl TypeDefDecl_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter TypeDefDecl", ++m_Recursion);
    LHChild = FundDecl(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::TYPE :
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::TYPE);
            LookaHead = EndTypeDef(LookaHead);
            LookaHead = FundDecl(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit TypeDefDecl", --m_Recursion);
    return LHChild;
}

CLHead CParser::EndTypeDef(CLHead LookaHead)
{
    //--------------------------------------------
    //    EndTypeDef        ->RecDefField EndTypeDef_1;
    //    EndTypeDef_1    -> ']'
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter EndTypeDef", ++m_Recursion);
    LHChild = RecDefField(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token(']'):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(']'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit EndTypeDef", --m_Recursion);
    return LHChild;

}

CLHead CParser::RecDefField(CLHead LookaHead)
{
    //--------------------------------------------
    //    RecDefField        ->Ident RecDefField_1;
    //    RecDefField_1    -> '=' '[' LocalDecls
    //                    -> '[' LocalDecls
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter RecDefField", ++m_Recursion);
    LHChild = Ident(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token('='):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('['));
        LookaHead = LocalDecls(LookaHead);
        break;
    case Token('['):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('['));
        LookaHead = LocalDecls(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit RecDefField", --m_Recursion);
    return LHChild;

}

//--------------------------------------------
// Fundemental Declarations.  These are the
// base types that every thing is based on
//--------------------------------------------

CLHead CParser::FundDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    FundDecl    ->FundPointerDecl FundDecl_1;
    //    FundDecl_1    -> 'BOOL' FundPointerDecl FundDecl_1
    //                -> 'CHAR' FundPointerDecl FundDecl_1
    //                -> 'BYTE' FundPointerDecl FundDecl_1
    //                -> 'INT' FundPointerDecl FundDecl_1
    //                -> 'CARD' FundPointerDecl FundDecl_1
    //                -> 'RECORDTYPE' FundPointerDecl FundDecl_1
    //                -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter FundDecl", ++m_Recursion);
    LHChild = FundPointerDecl(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::RECORDTYPE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::RECORDTYPE);
            LookaHead = FundPointerDecl(LookaHead);
            break;
        case Token::CHAR:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CHAR);
            LookaHead = FundPointerDecl(LookaHead);
            break;
        case Token::BYTE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BYTE);
            LookaHead = FundPointerDecl(LookaHead);
            break;
        case Token::CARD:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CARD);
            LookaHead = FundPointerDecl(LookaHead);
            break;
        case Token::INT:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::INT);
            LookaHead = FundPointerDecl(LookaHead);
            break;
        case Token::BOOL:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BOOL);
            LookaHead = FundPointerDecl(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit FundDecl", --m_Recursion);
    return LHChild;
}

CLHead CParser::FundPointerDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    FundPointerDecl        ->FundArrayDecl FundPointerDecl_1;
    //    FundPointerDecl_1    -> 'POINTER' FundArrayDecl
    //                        -> .
    //                        ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter FundPointerDecl", ++m_Recursion);
    LHChild = FundArrayDecl(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::POINTER:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::POINTER);
        LookaHead = FundArrayDecl(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit FundPointerDecl", --m_Recursion);
    return LHChild;

}

CLHead CParser::FundArrayDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    FundArrayDecl    ->FunctionDecl FundArrayDecl_1;
    //    FundArrayDecl_1    -> 'ARRAY' FunctionDecl
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter FundArrayDecl", ++m_Recursion);
    LHChild = FunctionDecl(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::ARRAY:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ARRAY);
        LookaHead = FunctionDecl(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit FundArrayDecl", --m_Recursion);
    return LHChild;
}

CLHead CParser::FunctionDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    FunctionDecl    ->IdentList FunctionDecl_1;;
    //    FunctionDecl_1    -> 'FUNC' FuncDef
    //                    -> 'PROC' ProcDef
    //                    -> 'INTERRUPT' IrqDef
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter FunctionDecl", ++m_Recursion);
    LHChild = IdentList(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::FUNC:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::FUNC);
        LookaHead = FuncDef(LookaHead);
        break;
    case Token::PROC:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PROC);
        LookaHead = ProcDef(LookaHead);
        break;
    case Token::INTERRUPT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::INTERRUPT);
        LookaHead = IrqDef(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit FunctionDecl", --m_Recursion);
    return LHChild;

}

CLHead CParser::IrqDef(CLHead LookaHead)
{
    //--------------------------------------------
    //    IrqDef->IrqDecl IrqBody;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IrqDef", ++m_Recursion);
    LookaHead = IrqDecl(LookaHead);
    LookaHead = IrqBody(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit IrqDef", --m_Recursion);
    return LHChild;
}


CLHead CParser::ProcDef(CLHead LookaHead)
{
    //--------------------------------------------
    //    ProcDef->ProcDecl ProcBody;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ProcDef", ++m_Recursion);
    LookaHead = ProcDecl(LookaHead);
    LookaHead = ProcBody(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit ProcDef", --m_Recursion);
    return LookaHead;
}

CLHead CParser::FuncDef(CLHead LookaHead)
{
    //--------------------------------------------
    //    FuncDef->FuncDecl FuncBody;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter FuncDef", ++m_Recursion);
    LookaHead = FuncDecl(LookaHead);
    LookaHead = FuncBody(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit FuncDef", --m_Recursion);
    return LookaHead;
}

CLHead CParser::IrqDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    IrqDecl        -> 'IDENT' OptInit '(' ')';
    //--------------------------------------------

    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IrqDecl", ++m_Recursion);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
    LookaHead = OptInit(LookaHead);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
    PrintLookahead(LogFile(), LookaHead, "Exit IrqDecl", --m_Recursion);
    return LHChild;

}

CLHead CParser::ProcDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    ProcDecl    -> 'IDENT' OptInit '(' ParamList ')';
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ProcDecl", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
        LookaHead = OptInit(LookaHead);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LookaHead = ParamList(LookaHead);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ProcDecl", --m_Recursion);
    return LHChild;

}

CLHead CParser::FuncDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    FuncDecl    -> 'IDENT' OptInit '(' ParamList ')';
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter FuncDecl", ++m_Recursion);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
    LookaHead = OptInit(LookaHead);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
    LookaHead = ParamList(LookaHead);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
    PrintLookahead(LogFile(), LookaHead, "Exit FuncDecl", --m_Recursion);
    return LHChild;

}

CLHead CParser::OptInit(CLHead LookaHead)
{
    //--------------------------------------------
    // OptInit        -> '=' CompConst
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptInit", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token('='):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = CompConst(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit OptInit", --m_Recursion);
    return LookaHead;
}


CLHead CParser::IrqBody(CLHead LookaHead)
{
    //--------------------------------------------
    //    IrqBody->LocalDecls Statements;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IrqBody", ++m_Recursion);
    LookaHead = LocalDecls(LookaHead);
    LookaHead = Statements(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit IrqBody", --m_Recursion);
    return LHChild;

}
CLHead CParser::ProcBody(CLHead LookaHead)
{
    //--------------------------------------------
    // ProcBody    -> LocalDecls Statements;
    //--------------------------------------------
    PrintLookahead(LogFile(), LookaHead, "Enter ProcBody", ++m_Recursion);
    LookaHead = LocalDecls(LookaHead);
    LookaHead = Statements(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit ProcBody", --m_Recursion);
    return LookaHead;
}

CLHead CParser::FuncBody(CLHead LookaHead)
{
    //--------------------------------------------
    // FuncBody    -> LocalDecls Statements;
    //--------------------------------------------
    PrintLookahead(LogFile(), LookaHead, "Enter FuncBodt", ++m_Recursion);
    LookaHead = LocalDecls(LookaHead);
    LookaHead = Statements(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Exit FuncBody", --m_Recursion);
    return LookaHead;
}

//----------------------------------
// Identifiers
//----------------------------------
CLHead CParser::IdentList(CLHead LookaHead)
{
    //--------------------------------------------
    // IdentList    -> Ident IdentList_1;
    // IdentList_1    -> ',' Ident IdentList_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IdentList", ++m_Recursion);
    LHChild = Ident(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            LookaHead = Ident(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit IdenrtList", --m_Recursion);
    return LHChild;
}

CLHead CParser::Ident(CLHead LookaHead)
{
    //--------------------------------------------
    //    Ident        ->IdentInit Ident_1;
    //    Ident_1        -> 'IDENT' IdentInit
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Ident", ++m_Recursion);
    LHChild = IdentInit(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
        LookaHead = IdentInit(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Ident", --m_Recursion);
    return LHChild;
}

CLHead CParser::IdentInit(CLHead LookaHead)
{
    //--------------------------------------------
    //    IdentInit    ->ArrayDim IdentInit_1;
    //    IdentInit_1    -> '=' Address
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IdentInit", ++m_Recursion);
    LHChild = ArrayDim(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token('='):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = Address(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit IdentInit", --m_Recursion);
    return LHChild;
}

CLHead CParser::Address(CLHead LookaHead)
{
    //--------------------------------------------
    //    Address        ->CompConst Address_1;
    //    Address_1    -> '[' Data ']'
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Address", ++m_Recursion);
    LHChild = CompConst(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token('['):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('['));
        LookaHead = Data(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Address", --m_Recursion);
    return LHChild;

}

CLHead CParser::Data(CLHead LookaHead)
{
    //--------------------------------------------
    //    Data        ->ConstList Data_1;
    //    Data_1        -> 'STRING'
    //                -> .
    //                ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Data", ++m_Recursion);
    LHChild = ConstList(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::STRING:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STRING);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Data", --m_Recursion);
    return LHChild;

}

CLHead CParser::ArrayDim(CLHead LookaHead)
{
    //--------------------------------------------
    //    ArrayDim    ->ArrayDim_1;
    //    ArrayDim_1    -> '(' CompConst ')'
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ArrayDim", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token('('):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LookaHead = CompConst(LookaHead);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ArrayDim", --m_Recursion);
    return LHChild;

}

//-------------------------------------------
// Function Parameters Declarations
//-------------------------------------------

CLHead CParser::ParamList(CLHead LookaHead)
{
    //--------------------------------------------
    //    ParamList    ->PramPointer Param_1;
    //    Param_1        -> 'RECORDTYPE' PramPointer Param_1
    //                -> 'CHAR' PramPointer Param_1
    //                -> 'BYTE' PramPointer Param_1
    //                -> 'INT' PramPointer Param_1
    //                -> 'CARD' PramPointer Param_1
    //                -> 'BOOL' PramPointer Param_1
    //                -> ',' Param_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ParamList", ++m_Recursion);
    LHChild = PramPointer(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::RECORDTYPE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::RECORDTYPE);
            LookaHead = PramPointer(LookaHead);
            break;
        case Token::CHAR:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CHAR);
            LookaHead = PramPointer(LookaHead);
            break;
        case Token::BYTE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BYTE);
            LookaHead = PramPointer(LookaHead);
            break;
        case Token::CARD:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CARD);
            LookaHead = PramPointer(LookaHead);
            break;
        case Token::INT:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::INT);
            LookaHead = PramPointer(LookaHead);
            break;
        case Token::BOOL:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BOOL);
            LookaHead = PramPointer(LookaHead);
            break;
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ParamList", --m_Recursion);
    return LHChild;
}

CLHead CParser::PramPointer(CLHead LookaHead)
{
    //--------------------------------------------
    //    PramPointer        ->ParamArray ParamPointer_1;
    //    ParamPointer_1    -> 'POINTER'  ParamArray
    //        -> .
    //        ;
    //-------------------------------------------    
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter PramPointer", ++m_Recursion);
    LHChild = ParamArray(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::POINTER:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::POINTER);
        LookaHead = ParamArray(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit PramPointer", --m_Recursion);
    return LHChild;

}

CLHead CParser::ParamArray(CLHead LookaHead)
{
    //--------------------------------------------
    //    ParamArray        ->IdentList ParamArray_1;
    //    ParamArray_1    -> 'ARRAY' IdentList
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ParamArray", ++m_Recursion);
    LHChild = IdentList(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::ARRAY:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ARRAY);
        LookaHead = IdentList(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ParamArray", --m_Recursion);
    return LHChild;
}



//-----------------------------------------------
// Local Variableas
//-----------------------------------------------


CLHead CParser::LocalDecls(CLHead LookaHead)
{
    //--------------------------------------------
    //    LocalDecls        ->LocalPointerDecl LocalDecls_1;
    //    LocalDecls_1    -> 'CHAR' LocalPointerDecl  LocalDecls_1
    //                    -> 'BYTE' LocalPointerDecl  LocalDecls_1
    //                    -> 'INT' LocalPointerDecl  LocalDecls_1
    //                    -> 'CARD' LocalPointerDecl  LocalDecls_1
    //                    -> 'BOOL' LocalPointerDecl LocalDecls_1
    //                    -> 'RECORDTYPE' LocalPointerDecl LocalDecls_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LocalDecls", ++m_Recursion);
    LHChild = LocalPointerDecl(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::CHAR:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CHAR);
            LookaHead = LocalPointerDecl(LookaHead);
            break;
        case Token::BYTE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BYTE);
            LookaHead = LocalPointerDecl(LookaHead);
            break;
        case Token::CARD:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CARD);
            LookaHead = LocalPointerDecl(LookaHead);
            break;
        case Token::INT:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::INT);
            LookaHead = LocalPointerDecl(LookaHead);
            break;
        case Token::BOOL:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BOOL);
            LookaHead = LocalPointerDecl(LookaHead);
            break;
        case Token::RECORDTYPE:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::RECORDTYPE);
            LookaHead = LocalPointerDecl(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LocalDecls", --m_Recursion);
    return LHChild;
}

CLHead CParser::LocalPointerDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    LocalPointerDecl    ->LocalArrayDecl LocalPointerDecl_1;
    //    LocalPointerDecl_1    -> 'POINTER' LocalArrayDecl
    //                        -> .
    //                        ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LocalPointerDecl", ++m_Recursion);
    LHChild = LocalArrayDecl(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::POINTER:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::POINTER);
        LookaHead = LocalArrayDecl(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LocalPointerDecl", --m_Recursion);
    return LHChild;

}

CLHead CParser::LocalArrayDecl(CLHead LookaHead)
{
    //--------------------------------------------
    //    LocalArrayDecl        ->IdentList LocalArrayDecl_1;
    //    LocalArrayDecl_1    -> 'ARRAY' IdentList
    //                        -> .
    //                        ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LocalArrayDecl", ++m_Recursion);
    LHChild = IdentList(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::ARRAY:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ARRAY);
        LookaHead = IdentList(LookaHead);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LocalArrayDecl", --m_Recursion);
    return LHChild;
}

//-------------------------------
// Compiler Constants
//-------------------------------


CLHead CParser::ConstList(CLHead LookaHead)
{
    //--------------------------------------------
    // CompConstList    -> CompConst CompConstList_1;
    // CompConstList_1    -> ',' CompConst CompConstList_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ConstList", ++m_Recursion);
    LHChild = CompConst(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            LookaHead = CompConst(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ConstList", --m_Recursion);
    return LHChild;
}

CLHead CParser::CompConst(CLHead LookaHead)
{
    //--------------------------------------------
    // CompConst        -> BaseCompConst CompConst_1;
    // CompConst_1        -> '+' BaseCompConst CompConst_1
    //                    -> '-' BaseCompConst CompConst_1
    //                    -> .
    //                    ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter CompConst", ++m_Recursion);
    LHChild = BaseCompConst(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('+'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('+'));
            LookaHead = BaseCompConst(LookaHead);
            break;
        case Token('-'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('-'));
            LookaHead = BaseCompConst(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit CompConst", --m_Recursion);
    return LHChild;
}

CLHead CParser::BaseCompConst(CLHead LookaHead)
{
    //--------------------------------------------
    //    BaseCompConst    -> 'NUMBER'
    //                    -> '*'
    //                    -> '@' MemContentsType
    //                    -> 'INTERUPT_IDENT'
    //                    -> 'FUNC_IDENT'
    //                    -> 'PROC_IDENT'
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter BaseCompConst", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::NUMBER:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::NUMBER);
        break;
    case Token('*'):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('*'));
        break;
    case Token('@'):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('@'));
        LookaHead = MemContents(LookaHead);
        break;
    case Token::INTERRUPT_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::INTERRUPT_IDENT);
        break;
    case Token::FUNC_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::FUNC_IDENT);
        break;
    case Token::PROC_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PROC_IDENT);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit BaseCompConst", --m_Recursion);
    return LHChild;
}


//----------------------------------
//    Variable References
//    Memory References
//----------------------------------

CLHead CParser::ValueList(CLHead LookaHead)
{
    //--------------------------------------------
    //    ValueList    ->Value ValueList_1;
    //    ValueList_1    -> ',' Value ValueList_1
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ValueList", ++m_Recursion);
    LHChild = Value(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            LookaHead = Value(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ValueList", --m_Recursion);
    return LHChild;

}

CLHead CParser::Value(CLHead LookaHead)
{
    //--------------------------------------------
    //    Value    ->MemContentsType Value_1;
    //    Value_1    -> 'NUMBER'
    //            -> '*'        // current memroy location
    //            -> '@' AddressOf
    //            -> .
    //            ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Value", ++m_Recursion);
    LHChild = MemContentsType(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::NUMBER:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::NUMBER);
            break;
        case Token('*'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('*'));
            break;
        case Token('@'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('@'));
            LookaHead = MemContents(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Value", --m_Recursion);
    return LHChild;

}

CLHead CParser::AddressOf(CLHead LookaHead)
{
    //--------------------------------------------
    //    AddressOf    ->MemContentsType AddressOf_1;
    //    AddressOf_1    ->'PROC_IDENT'//
    //                -> 'FUNC_IDENT'
    //                -> 'INTERRUPT_IDENT'
    //                -> .
    //                ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AddressOf", ++m_Recursion);
    LHChild = MemContentsType(LookaHead);
    switch (LHChild.GetToken())
    {
    case Token::INTERRUPT_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::INTERRUPT_IDENT);
        break;
    case Token::FUNC_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::FUNC_IDENT);
        break;
    case Token::PROC_IDENT:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PROC_IDENT);
        break;
    default:
        Loop = false;
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit AddressOf", --m_Recursion);
    return LHChild;

}

CLHead CParser::MemContentsType(CLHead LookaHead)
{
    //--------------------------------------------
    //    MemContentsType        ->MemContents MemContentsType_1;
    //    MemContentsType_1     -> '(' ArithExpr ')'    //array ref
    //                        -> '^'                    // Pointer Dereference
    //                        -> '.' MemContents MemContentsType_1        //record ref
    //                        -> .
    //                        ;
    //--------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter MemContentsType", ++m_Recursion);
    LHChild = MemContents(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('('):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
            LookaHead = ArithExpr(LookaHead);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
            Loop = false;
            break;
        case Token('^'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('^'));
            Loop = false;
            break;
        case Token('.'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('.'));
            LookaHead = MemContents(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit MemcontentsType", --m_Recursion);
    return LookaHead;
}


CLHead CParser::MemContents(CLHead LookaHead)
{
    //--------------------------------------------
    //    MemContents        -> 'IDENT'
    //                    -> .
    //                    ;
    //--------------------------------------------
    CAstNode* pN = 0;

    PrintLookahead(LogFile(), LookaHead, "Enter MemContents", ++m_Recursion);
    pN = new CAct65IDENT;
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
    LookaHead.SetNode(pN);
    PrintLookahead(LogFile(), LookaHead, "Exit MemCoontents", --m_Recursion);
    return LookaHead;
}


//-----------------------------------------------------------
// Inline Assembler Methods
//-----------------------------------------------------------
CLHead CParser::AsmStmt(CLHead LookaHead)
{
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AsmStmt", ++m_Recursion);
    LookaHead = Section(LookaHead);
    LookaHead = Processor_1(LookaHead);
    PrintLookahead(LogFile(), LookaHead, "Enter AsmStmt", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::Processor_1(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Processor    ->PROCESSOR ProcessorType Processor
    //                -> .
    //                ;
    //--------------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Processor_1", ++m_Recursion);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::PROCESSOR:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PROCESSOR);
            LookaHead = ProcessorType(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Enter Processor_1", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::ProcessorType(CLHead LookaHead)
{
    //--------------------------------------------------
    //    ProcessorType    -> R6502
    //                    -> WD65C02
    //                    -> WD65C816
    //                    ;
    //--------------------------------------------------
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ProcessorType", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::R6502:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::R6502);
        break;
    case Token::WD65C02:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::WD65C02);
        break;
    case Token::WD65C816:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::WD65C816);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Enter ProcessorType", ++m_Recursion);
    return LookaHead;
}

//--------------------------------------------------
// SECTION statment
//--------------------------------------------------

CLHead CParser::Section(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Section        -> Org Section_1;
    //    Section_1    -> 'SECTION' SectionName Org Section_1
    //                -> .
    //                ;
    //--------------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Section", ++m_Recursion);
    LHChild = Org(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::SECTION:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::SECTION);
            LookaHead = SectionName(LookaHead);
            LookaHead = Org(LookaHead);
            break;
        default:
            printf("Line%d Col:%d  %s",
                GetLexer()->GetLineNumber(),
                GetLexer()->GetColunm(),
                GetLexer()->GetLexBuffer()
            );
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Section", ++m_Recursion);
    return LHChild;
}

CLHead CParser::SectionName(CLHead LookaHead)
{
    //--------------------------------------------------
    //    SectionName        ->SectionDef SectionName_1;
    //    SectionName_1    -> 'IDENT' SectionDef
    //                    -> .
    //                    ;
    //--------------------------------------------------

    PrintLookahead(LogFile(), LookaHead, "Enter SectionName", ++m_Recursion);
    PrintLookahead(LogFile(), LookaHead, "Exit SectionName", ++m_Recursion);
    return CLHead();
}

CLHead CParser::SectionDef(CLHead LookaHead)
{
    //--------------------------------------------------
    //    SectionDef    -> '[' SectionAttributesList ']'
    //                -> .
    //                ;
    //--------------------------------------------------
    PrintLookahead(LogFile(), LookaHead, "Enter SectionDef", ++m_Recursion);
    PrintLookahead(LogFile(), LookaHead, "Exit SectionDef", ++m_Recursion);
    return CLHead();
}

CLHead CParser::SectionAttributesList(CLHead LookaHead)
{
    //--------------------------------------------------
    //    SectionAttributesList    ->SectionAtribute SectionAttributesList_1;
    //    SectionAttributesList_1    -> ',' SectionAtribute SectionAttributesList_1
    //                            -> .
    //                            ;
    //--------------------------------------------------
    PrintLookahead(LogFile(), LookaHead, "Enter SectionAttributesList", ++m_Recursion);
    PrintLookahead(LogFile(), LookaHead, "Exit SectionAttributesList", ++m_Recursion);
    return CLHead();
}


CLHead CParser::SectionAtribute(CLHead LookaHead)
{
    //--------------------------------------------------
    //    SectionAtribute    -> START '=' AsmConstant
    //                    -> SIZE '=' AsmConstant
    //                    -> MODE '=' Modes
    //                    -> .
    //                    ;
    //--------------------------------------------------
    CNumberStackItem* pNSI;
    CAccessModeStackItem* pAMS;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter SectionAtribute", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::START:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::START);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        if (pNSI->GetValue() == 0x0ff00)
        {
            printf("PieBug\n");
        }
        //        fprintf(Act()->LogFile(), "Set Start Address to %04x\n", pNSI->GetValue());
        GetCurrentSection()->SetStartAddress(pNSI->GetValue());
        break;
    case Token::SIZE:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::SIZE);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        GetCurrentSection()->SetSectionSize(pNSI->GetValue());
        break;
    case Token::MODE:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::MODE);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = Modes(LookaHead);
        pAMS = (CAccessModeStackItem*)GetValueStack()->Pop(CStackItem::ItemType::ACCESS_MODE);
        GetCurrentSection()->SetAccessMode(pAMS->GetAccessMode());
        break;
    case Token::ZEROPAGE:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ZEROPAGE);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('='));
        LookaHead = TrueFalse(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        if (pNSI->GetValue())
        {
            GetCurrentSection()->SetZeroPageFlag(CSection::AddressSize::ADDRESSSIZE_ZEROPAGE);
        }
        else
        {
            GetCurrentSection()->SetZeroPageFlag(CSection::AddressSize::ADDRESSSIZE_WORD);
        }
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit SectionAtribute", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::Modes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Modes    ->READ_ONLY
    //            ->READ_WRITE
    //            ;
    //--------------------------------------------------
    CAccessModeStackItem* pAMSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Modes", ++m_Recursion);
    pAMSI = new CAccessModeStackItem;
    pAMSI->Create();

    switch (LHChild.GetToken())
    {
    case Token::READ_ONLY:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::READ_ONLY);
        pAMSI->SetAccessMode(CSection::Mode::MODE_READ_ONLY);
        GetValueStack()->Push(pAMSI);
        break;
    case Token::READ_WRTE:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::READ_WRTE);
        pAMSI->SetAccessMode(CSection::Mode::MODE_READ_WRITE);
        GetValueStack()->Push(pAMSI);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Modes", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::TrueFalse(CLHead LookaHead)
{
    CNumberStackItem* pNumber;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter TrueFalse", ++m_Recursion);
    pNumber = new CNumberStackItem;
    pNumber->Create();
    switch (LHChild.GetToken())
    {
    case Token::True:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::True);
        pNumber->SetValue(1);
        GetValueStack()->Push(pNumber);
        break;
    case Token::False:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::False);
        pNumber->SetValue(0);
        GetValueStack()->Push(pNumber);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit TrueFalse", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::Org(CLHead LookaHead)
{
    //-----------------------------------------
    //    Org        ->DefineMemory Org1;
    //    Org1    -> 'ORG' 'NUMBER' DefineMemory Org1
    //            -> .
    //            ;
    //-----------------------------------------
    bool Loop = true;
    CNumberStackItem* pNSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Org", ++m_Recursion);
    LHChild = DefineMemory(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::ORG:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::ORG);
            LookaHead = AsmConstant(LookaHead);
            pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
            GetCurrentSection()->SetLocationCounter(pNSI->GetValue());
            LookaHead = DefineMemory(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Org", ++m_Recursion);
    return LHChild;
}

CLHead CParser::DefineMemory(CLHead LookaHead)
{
    //--------------------------------------------------
    //    DefineMemory    -> DefineStorage DefineMemory1;
    //    DefineMemory1    -> DB AsmConstList DefineStorage DefineMemory1
    //                    -> DW AsmConstList DefineStorage DefineMemory1
    //                    -> DL AsmConstList DefineStorage DefineMemory1
    //                    -> DAS STRING DefineStorage DefineMemory1
    //                    -> DCS STRING DefineStorage DefineMemory1
    //                    -> .
    //                    ;
    //--------------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;
    CDataSizeStackItem* pDSI;
    int i, l, c;

    PrintLookahead(LogFile(), LookaHead, "Enter DefineMemory", ++m_Recursion);
    LHChild = DefineStorage(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::DB:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DB);
            pDSI = new CDataSizeStackItem;
            pDSI->Create();
            pDSI->SetSize(1);    //Byte Size
            GetValueStack()->Push(pDSI);
            LookaHead = AsmConstList(LookaHead);
            LookaHead = DefineStorage(LookaHead);
            break;
        case Token::DW:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DW);
            pDSI = new CDataSizeStackItem;
            pDSI->Create();
            pDSI->SetSize(2);    //Word Size
            GetValueStack()->Push(pDSI);
            LookaHead = AsmConstList(LookaHead);
            LookaHead = DefineStorage(LookaHead);
            break;
        case Token::DL:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DL);
            pDSI = new CDataSizeStackItem;
            pDSI->Create();
            pDSI->SetSize(4);    //Long Size
            GetValueStack()->Push(pDSI);
            LookaHead = AsmConstList(LookaHead);
            LookaHead = DefineStorage(LookaHead);
            break;
        case Token::DAS:    //define action string
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DAS);
            l = strlen(GetLexer()->GetLexBuffer());
            GetCurrentSection()->AddData(1, l);
            for (i = 0; i < l; ++i)
            {
                c = GetLexer()->GetLexBuffer()[i];
                GetCurrentSection()->AddData(1, c);
            }
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STRING);
            break;
        case Token::DCS:    //define 'C' string
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DCS);
            l = strlen(GetLexer()->GetLexBuffer());
            for (i = 0; i < l; ++i)
            {
                c = GetLexer()->GetLexBuffer()[i];
                GetCurrentSection()->AddData(1, c);
            }
            GetCurrentSection()->AddData(1, 0);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STRING);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit DefineMemory", ++m_Recursion);
    return LHChild;
}

CLHead CParser::DefineStorage(CLHead LookaHead)
{
    //--------------------------------------------------
    //    DefineStorage    -> Proceedure DefineStorage_1;
    //    DefineStorage_1    -> DS AsmConstant Proceedure DefineStorage_1
    //                    -> .
    //                    ;
    //--------------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;
    CNumberStackItem* pNSI;
    int BlockSize;

    PrintLookahead(LogFile(), LookaHead, "Exit DefineStorage", ++m_Recursion);
    LHChild = Proceedure(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::DS:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::DS);
            LookaHead = AsmConstant(LookaHead);
            pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
            BlockSize = pNSI->GetValue();
            GetCurrentSection()->AllocateDataBlock(BlockSize);
            LookaHead = Proceedure(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit DefineStorage", ++m_Recursion);
    return LHChild;
}

CLHead CParser::Proceedure(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Procedure    -> Instruction Proceedure_1;
    //    Procedure_1    -> PROC Section EPROC Instruction Proceedure_1
    //                    -> .
    //                    ;
    //--------------------------------------------------
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter PRO|C", ++m_Recursion);
    LHChild = Instruction(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token::PROC:
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::PROC);
            LookaHead = Section(LookaHead);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::EPROC);
            LookaHead = Instruction(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit PROC", --m_Recursion);
    return LHChild;
}

CLHead CParser::Instruction(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Instruction        -> Labels Instruction_1
    //    Instruction_1    -> ADC  AluAdrModes Labels Instruction_1            //ALU Opcodes
    //                    -> AND  AluAdrModes Labels Instruction_1    
    //                    ->EOR  AluAdrModes Labels Instruction_1    
    //                    ->ORA  AluAdrModes Labels Instruction_1    
    //                    ->CMP  AluAdrModes Labels Instruction_1    
    //                    ->SBC  AluAdrModes Labels Instruction_1    
    //                    ->LDA  AluAdrModes Labels Instruction_1    
    //                    ->STA  StaAddressingModes Labels Instruction_1    
    //                    ->ASL ShiftAddressingModes Labels Instruction_1                //shift addressing modes
    //                    -> ROL ShiftAddressingModes Labels Instruction_1    
    //                    ->LSR ShiftAddressingModes Labels Instruction_1    
    //                    ->ROR ShiftAddressingModes Labels Instruction_1    
    //                    ->BCC RelAddressingMode Labels Instruction_1                    // Branch Op Codes
    //                    -> BCS RelAddressingMode Labels Instruction_1    
    //                    ->BEQ RelAddressingMode Labels Instruction_1    
    //                    ->BMI RelAddressingMode Labels Instruction_1    
    //                    ->BNE RelAddressingMode Labels Instruction_1    
    //                    ->BPL RelAddressingMode Labels Instruction_1    
    //                    ->BVC RelAddressingMode Labels Instruction_1    
    //                    ->BVS RelAddressingMode Labels Instruction_1    
    //                    ->BIT BitAddressModes Labels Instruction_1                //BIT opcode
    //                    -> BRK Labels Instruction_1    //Implied Addressing Mode 
    //                    -> CLC Labels Instruction_1    
    //                    ->CLD Labels Instruction_1    
    //                    ->CLI Labels Instruction_1    
    //                    ->CLV Labels Instruction_1    
    //                    ->DEX Labels Instruction_1    
    //                    ->DEY Labels Instruction_1    
    //                    ->INX Labels Instruction_1    
    //                    ->INY Labels Instruction_1    
    //                    ->NOP Labels Instruction_1    
    //                    ->PHA Labels Instruction_1    
    //                    ->PLA Labels Instruction_1    
    //                    ->PHP Labels Instruction_1    
    //                    ->PLP Labels Instruction_1    
    //                    ->RTI Labels Instruction_1    
    //                    ->RTS Labels Instruction_1    
    //                    ->SEC Labels Instruction_1    
    //                    ->SED Labels Instruction_1    
    //                    ->SEI Labels Instruction_1    
    //                    ->TAX Labels Instruction_1    
    //                    ->TAY Labels Instruction_1    
    //                    ->TXA Labels Instruction_1    
    //                    ->TYA Labels Instruction_1    
    //                    ->TXS Labels Instruction_1    
    //                    ->TSX Labels Instruction_1    
    //                    ->INC IncAddressingMOdes Labels Instruction_1                //Inc/Dec Addressing Modes
    //                    -> DEC IncAddressingMOdes Labels Instruction_1    
    //                    ->JMP JumpAddressingModes Labels Instruction_1            // Jump
    //                    -> JSR CallAddressingMode Labels Instruction_1                // Jump To Subroutine
    //                    -> CPX  CPXAddressingMode Labels Instruction_1    
    //                    ->CPY  CPXAddressingMode Labels Instruction_1    
    //                    ->LDX LdxAddressingMode Labels Instruction_1    
    //                    ->LDY LdyAddressingMode Labels Instruction_1    
    //                    ->STX StxAddressingMode Labels Instruction_1    
    //                    ->STY StyAddressingMode Labels Instruction_1    
    //                    -> .
    //                    ;
    //--------------------------------------------------
    CInstruction* pInstruct;
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Instruction", ++m_Recursion);
    LHChild = Labels(LookaHead);
    while (Loop)
    {
        switch(LHChild.GetToken())
        {
        case Token::ADC:    //ALU addressing
        case Token::AND:
        case Token::CMP:
        case Token::EOR:
        case Token::LDA:
        case Token::ORA:
        case Token::SBC:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), LookaHead.GetToken());
            LookaHead = AluAdrModes(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::STA:    //store accumalator 
            PrepareInstruction(&pInstruct, Token::STA);
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STA);
            LookaHead = StaAddressingModes(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::ASL:    //shift addressing modes
        case Token::LSR:
        case Token::ROL:
        case Token::ROR:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), LookaHead.GetToken());
            LookaHead = ShiftAddressingModes(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::BCC:    //relative addressing
        case Token::BCS:
        case Token::BEQ:
        case Token::BMI:
        case Token::BNE:
        case Token::BPL:
        case Token::BVC:
        case Token::BVS:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), LookaHead.GetToken());
            LookaHead = RelAddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::BIT:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::BIT);
            LookaHead = BitAddressModes(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::BRK:    //implicit addressing
        case Token::CLC:
        case Token::CLD:
        case Token::CLI:
        case Token::CLV:
        case Token::DEX:
        case Token::DEY:
        case Token::INX:
        case Token::INY:
        case Token::NOP:
        case Token::PHA:
        case Token::PLA:
        case Token::PHP:
        case Token::PLP:
        case Token::RTI:
        case Token::RTS:
        case Token::SEC:
        case Token::SED:
        case Token::SEI:
        case Token::TAX:
        case Token::TAY:
        case Token::TXA:
        case Token::TYA:
        case Token::TXS:
        case Token::TSX:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            pInstruct->AddToCurrentSection();
            LookaHead.m_Token = Expect(LookaHead.GetToken(), LookaHead.GetToken());
            LookaHead = Labels(LookaHead);
            break;
        case Token::CPX:    //compare index registers
        case Token::CPY:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), LookaHead.GetToken());
            LookaHead = CPX_CPY_AddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::DEC:    //inc/dec
        case Token::INC:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), LookaHead.GetToken());
            LookaHead = IncAddressingMOdes(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::JMP:    //jump addressing modes
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::JMP);
            LookaHead = JumpAddressingModes(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::JSR:    //jsr addressing modes
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::JSR);
            LookaHead = CallAddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::LDX:    //load index register
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::LDX);
            LookaHead = LdxAddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::LDY:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::LDY);
            LookaHead = LdyAddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::STX:    //store index registers
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STX);
            LookaHead = StxAddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        case Token::STY:
            PrepareInstruction(&pInstruct, LookaHead.GetToken());
            GetValueStack()->Push(pInstruct);
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STY);
            LookaHead = StyAddressingMode(LookaHead);
            GetValueStack()->Pop(CStackItem::ItemType::INSTRUCTION);
            pInstruct->AddToCurrentSection();
            LookaHead = Labels(LookaHead);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit Instruction", ++m_Recursion);
    return LHChild;
}

CLHead CParser::Labels(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Labels    -> IDENT LocalGlobal
    //            -> .
    //            ;
    //--------------------------------------------------
    CSymbol* pSym;
    CStackSymbolItem* pSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    int Address = 0;

    PrintLookahead(LogFile(), LookaHead, "Enter Labels", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::IDENT:
        if (GetLexer()->GetLexSymbol() == NULL)
        {
            pSym = new CSymbol();
            pSym->Create();
            pSym->SetName(GetLexer()->GetLexBuffer());
            pSym->SetResolved();
            Address = GetCurrentSection()->GetLocationCounter();
            pSym->SetAddress(Address);
            GetLexer()->GetSymTab()->AddSymbol(pSym);
            pSym->SetSection(GetCurrentSection());
        }
        else
        {
            pSym = (CSymbol*)GetLexer()->GetLexSymbol();
            Address = GetCurrentSection()->GetLocationCounter();
            pSym->SetAddress(Address);
            pSym->SetResolved();
            pSym->SetSection(GetCurrentSection());
            pSym->BackFillUnresolved();
        }
        pSI = new CStackSymbolItem;
        pSI->Create(pSym);
        GetValueStack()->Push(pSI);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
        LookaHead = LocalGlobal(LookaHead);
        GetValueStack()->Pop(CStackItem::ItemType::SYMBOL);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit Labels", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::LocalGlobal(CLHead LookaHead)
{
    //--------------------------------------------------
    //    LocalGlobal    -> ':'        //Local
    //                -> .        //Global
    //                ;
    //--------------------------------------------------
    CStackSymbolItem* pSSI = 0;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LocalGlobal", ++m_Recursion);
    if (GetValueStack()->GetHead())
    {
        pSSI = (CStackSymbolItem*)GetValueStack()->Look(0, CStackItem::ItemType::SYMBOL);
        if (!pSSI)
            ThrownException.SetXCeptType(Exception::ExceptionType::INTERNAL_ERROR);
    }
    else
    {
        ThrownException.SetXCeptType(Exception::ExceptionType::INTERNAL_ERROR);
    }
    switch (LHChild.GetToken())
    {
    case Token(':'):
        pSSI->GetSymbol()->SetToken(Token::LOCAL_LABEL);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(':'));
        break;
    default:
        pSSI->GetSymbol()->SetToken(Token::GLOBAL_LABLE);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LocalGlobal", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::AluAdrModes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    AluAdrModes        -> '#' ConstUpperLower
    //                    -> '(' Indirect
    //                    -> AsmConstant OptIndexReg
    //                    ;
    //--------------------------------------------------
    CInstruction* pInst;
    CNumberStackItem* pIntValue;
    int Address;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AluAdrModes", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token('#'):
        LookaHead = Immediate(LookaHead, pInst);
        break;
    case Token('('):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LookaHead = Indirect(LookaHead);
        pInst->SetByteCount(2);
        break;
    default:    //absolute, Zero Page and Indexed
        LookaHead = AsmConstant(LookaHead);
        pIntValue = (CNumberStackItem*)GetValueStack()->Pop(
            CStackItem::ItemType::INTVALUE
        );
        Address = pIntValue->GetValue();
        LookaHead = OptIndexReg(LookaHead);
        pRSI = (CRegisterStackItem*)GetValueStack()->Pop(
            CStackItem::ItemType::REGTYPE
        );
        switch (pRSI->GetRegType())
        {
        case CRegisterStackItem::RegType::NONE:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
            break;
        case CRegisterStackItem::RegType::X:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_X_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_X_ADR);
            break;
        case CRegisterStackItem::RegType::Y:
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_Y_ADR);
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit AluAdrModes", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::Indirect(CLHead LookaHead)
{
    //--------------------------------------------------
    //    Indirect    -> AsmConstant  Indirect_1;
    //    Indirect_1    -> ')' ',' YREG
    //                -> ',' XREG ')'
    //                -> .
    //                ;
    //--------------------------------------------------
    int Address = 0;
    int OpCodeInc = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Indirect", ++m_Recursion);
    LHChild = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    Address = pNSI->GetValue();
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    pInst->SetOperandW(Address);
    switch (LHChild.GetToken())
    {
    case Token(')'):    //indirect Y xxx (vv),Y
        CheckZeroPageAddress(Address);
        OpCodeInc = GetLexer()->
            FindKeyword(pInst->GetOpCodeToken())->
            FindInc(AdrModeType::INDIRECT_Y_ADR);
        pInst->AddToOpCode(OpCodeInc);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::YREG);
        break;
    case Token(','):    //indirect X xxx (vv,X)
        CheckZeroPageAddress(Address);
        OpCodeInc = GetLexer()->
            FindKeyword(pInst->GetOpCodeToken())->
            FindInc(AdrModeType::INDIRECT_X_ADR);
        pInst->AddToOpCode(OpCodeInc);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::XREG);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit Indirect", ++m_Recursion);
    return LHChild;
}


CLHead CParser::StaAddressingModes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    StaAddressingModes    -> AsmConstant OptIndexReg
    //                        -> '(' Indirect
    //                        ;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst = 0;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter StaAddressingModes", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token('('):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LookaHead = Indirect(LookaHead);
        pInst->SetByteCount(2);
        break;
    default:
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        LookaHead = OptIndexReg(LookaHead);
        pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
        switch (pRSI->GetRegType())
        {
        case CRegisterStackItem::RegType::NONE:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
            break;
        case CRegisterStackItem::RegType::X:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_X_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_X_ADR);
            break;
        case CRegisterStackItem::RegType::Y:
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_Y_ADR);
            break;
        }
    }
    PrintLookahead(LogFile(), LookaHead, "Exit StaAddressingModes", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::ShiftAddressingModes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    ShiftAddressingModes    -> AREG
    //                            -> AsmConstant OptXReg
    //                            ;
    //--------------------------------------------------
    int Address = 0;
    int OpCodeInc;
    CInstruction* pInst;
    CNumberStackItem* pNSI;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter ShiftAddressingModes", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token::AREG:
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::AREG);
        pInst->SetByteCount(1);
        OpCodeInc = GetLexer()->
            FindKeyword(pInst->GetOpCodeToken())->
            FindInc(AdrModeType::ACCUMULATOR);
        pInst->AddToOpCode(OpCodeInc);
        break;
    default:
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        LookaHead = OptXReg(LookaHead);
        pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
        switch (pRSI->GetRegType())
        {
        case CRegisterStackItem::RegType::NONE:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
            break;
        case CRegisterStackItem::RegType::X:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_X_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_X_ADR);
            break;
        }
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit ShiftAddressingModes", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::RelAddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    RelAddressingMode    -> AsmConstant;
    //--------------------------------------------------
    int Address = 0;
    unsigned DestAddress = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter RelAddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    LHChild = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    if (pInst->IsUnResolved())
    {
        Address = 0;
    }
    else
    {
        DestAddress = pNSI->GetValue();
        Address = GetCurrentSection()->GetLocationCounter() + 2;
        Address = DestAddress - Address;
    }
    if (Address > 127 || Address < -128)
    {
        //-----------------------------------
        // Address has exceeded it's boundry
        // throw an exception.
        //-----------------------------------
        printf("Rel Address Boo-boo\n");
    }
    else
    {
        pInst->SetLowByte(Address);
    }
    PrintLookahead(LogFile(), LHChild, "Exit RelAddressingMode", ++m_Recursion);
    return LHChild;
}

CLHead CParser::BitAddressModes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    BitAddressModes    -> AsmConstant;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter BitAddressModes", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    LookaHead = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    if (pInst->IsUnResolved())
        Address = 0;
    else
        Address = pNSI->GetValue();
    if (Address < 0x100 && pInst->IsResolved())
    {
        //---------------------
        // Zero Page Absolute
        //---------------------
        PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
    }
    else
    {
        //---------------------
        // Absolute
        //---------------------
        Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
    }
    PrintLookahead(LogFile(), LookaHead, "Exit BitAddressModes", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::IncAddressingMOdes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    IncAddressingMOdes    -> AsmConstant OptXReg;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter IncAddressingMOdes", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    LHChild = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    Address = pNSI->GetValue();
    LookaHead = OptXReg(LookaHead);
    pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
    switch (pRSI->GetRegType())
    {
    case CRegisterStackItem::RegType::X:
        if (Address < 0x100 && pInst->IsResolved())
            PageZero(pInst, Address, AdrModeType::ZERO_PAGE_X_ADR);
        else
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_X_ADR);
        break;
    case CRegisterStackItem::RegType::NONE:
        if (Address < 0x100 && pInst->IsResolved())
            PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
        else
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit IncAddressingMOdes", ++m_Recursion);
    return LHChild;
}

CLHead CParser::JumpAddressingModes(CLHead LookaHead)
{
    //--------------------------------------------------
    //    JumpAddressingModes    -> AsmConstant
    //                        -> '(' AsmConstant ')'
    //                        ;
    //--------------------------------------------------
    int Address = 0;
    int OpCodeInc;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter JumpAddressingModes", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token('('):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('('));
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(')'));
        OpCodeInc = GetLexer()->
            FindKeyword(pInst->GetOpCodeToken())->FindInc(
                AdrModeType::INDIRECT_ADR
            );
        pInst->AddToOpCode(OpCodeInc);
        pInst->SetOperandW(Address);
        pInst->SetByteCount(3);
        break;
    default:
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit JumpAddressingModes", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::CallAddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    CallAddressingMode    -> AsmConstant;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter CallAddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    LookaHead = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    Address = pNSI->GetValue();
    Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
    PrintLookahead(LogFile(), LookaHead, "Exit CallAddressingMode", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::LdxAddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    LdxAddressingMode    -> AsmConstant OptYReg
    //                        -> '#' AsmConstant
    //                        ;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LdxAddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token('#'):
        LookaHead = Immediate(LookaHead, pInst);
        break;
    default:
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        LookaHead = OptYReg(LookaHead);
        pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
        switch (pRSI->GetRegType())
        {
        case CRegisterStackItem::RegType::Y:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_Y_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_Y_ADR);
            break;
        case CRegisterStackItem::RegType::NONE:
            Address = pNSI->GetValue();
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
            break;
        }
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LdxAddressingMode", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::CPX_CPY_AddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    CPX_CPY_AddressingMode    -> AsmConstant
    //                        -> '#' AsmConstant
    //                        ;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter CPX_CPY_AddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token('#'):
        LookaHead = Immediate(LookaHead, pInst);
        break;
    default:
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        if (Address < 0x100 && pInst->IsResolved())
            PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
        else
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit CPX_CPY_AddressingMode", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::StxAddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    StxAddressingMode    -> AsmConstant OptYReg;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI = 0;
    CInstruction* pInst;
    CRegisterStackItem* pRSI = 0;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter StxAddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    LHChild = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    Address = pNSI->GetValue();
    LookaHead = OptYReg(LookaHead);
    pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
    switch (pRSI->GetRegType())
    {
    case CRegisterStackItem::RegType::Y:
        if (Address >= 0x100)
        {
            fprintf(stderr, "Warning:STX Zero page: Truncated %04X\n",
                Address & 0x0ffff
            );
        }
        PageZero(pInst, Address, AdrModeType::ZERO_PAGE_Y_ADR);
        break;
    case CRegisterStackItem::RegType::NONE:
        if (Address < 0x100 && pInst->IsResolved())
            PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
        else
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit StxAddressingMode", ++m_Recursion);
    return LHChild;
}

CLHead CParser::LdyAddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    LdyAddressingMode    -> AsmConstant OptXReg
    //                        -> '#' AsmConstant
    //                        ;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter LdyAddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    switch (LHChild.GetToken())
    {
    case Token('#'):
        LookaHead = Immediate(LookaHead, pInst);
        break;
    default:
        LookaHead = AsmConstant(LookaHead);
        pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
        Address = pNSI->GetValue();
        LookaHead = OptXReg(LookaHead);
        pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
        switch (pRSI->GetRegType())
        {
        case CRegisterStackItem::RegType::X:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_X_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_X_ADR);
            break;
        case CRegisterStackItem::RegType::NONE:
            if (Address < 0x100 && pInst->IsResolved())
                PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
            else
                Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
            break;
        }
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit LdyAddressingMode", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::StyAddressingMode(CLHead LookaHead)
{
    //--------------------------------------------------
    //    StyAddressingMode    -> AsmConstant OptXReg;
    //--------------------------------------------------
    int Address = 0;
    CNumberStackItem* pNSI;
    CInstruction* pInst;
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter StyAddressingMode", ++m_Recursion);
    pInst = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
    LHChild = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    Address = pNSI->GetValue();
    LookaHead = OptXReg(LookaHead);
    pRSI = (CRegisterStackItem*)GetValueStack()->Pop(CStackItem::ItemType::REGTYPE);
    switch (pRSI->GetRegType())
    {
    case CRegisterStackItem::RegType::X:
        if (Address >= 0x100)
        {
            fprintf(stderr, "Warning:STY Zero page: Truncated %04X\n",
                Address & 0x0ffff
            );
        }
        PageZero(pInst, Address, AdrModeType::ZERO_PAGE_X_ADR);
        break;
    case CRegisterStackItem::RegType::NONE:
        if (Address < 0x100 && pInst->IsResolved())
            PageZero(pInst, Address, AdrModeType::ZERO_PAGE_ADR);
        else
            Absolute(pInst, Address, AdrModeType::ABSOLUTE_ADR);
        break;
    }
    PrintLookahead(LogFile(), LHChild, "Exit StyAddressingMode", ++m_Recursion);
    return LHChild;
}

CLHead CParser::OptIndexReg(CLHead LookaHead)
{
    //--------------------------------------------------
    //    OptIndexReg        -> ',' OptIndexReg_1
    //                    -> .
    //                    ;
    //--------------------------------------------------
    CRegisterStackItem* pRSI = 0;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptIndexReg", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token(','):
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
        LookaHead = OptIndexReg_1(LookaHead);
        break;
    default:
        pRSI = new CRegisterStackItem;
        pRSI->Create();
        pRSI->SetRegType(CRegisterStackItem::RegType::NONE);
        GetValueStack()->Push(pRSI);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit OptIndexReg", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::OptIndexReg_1(CLHead LookaHead)
{
    //--------------------------------------------------
    //    OptIndexReg_1    -> XREG
    //                    -> YREG
    //                    ;
    //--------------------------------------------------
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptIndexReg_1", ++m_Recursion);
    pRSI = new CRegisterStackItem;
    pRSI->Create();
    switch (LHChild.GetToken())
    {
    case Token::XREG:
        pRSI->SetRegType(CRegisterStackItem::RegType::X);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::XREG);
        GetValueStack()->Push(pRSI);
        break;
    case Token::YREG:
        pRSI->SetRegType(CRegisterStackItem::RegType::Y);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::YREG);
        GetValueStack()->Push(pRSI);
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit OptIndexReg_1", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::OptXReg(CLHead LookaHead)
{
    //--------------------------------------------------
    //    OptXReg    -> ',' XREG
    //            -> .
    //            ;
    //--------------------------------------------------
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptXReg", ++m_Recursion);
    pRSI = new CRegisterStackItem;
    pRSI->Create();
    GetValueStack()->Push(pRSI);
    switch (LHChild.GetToken())
    {
    case Token(','):
        pRSI->SetRegType(CRegisterStackItem::RegType::X);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::XREG);
        break;
    default:
        pRSI->SetRegType(CRegisterStackItem::RegType::NONE);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit OptXReg", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::OptYReg(CLHead LookaHead)
{
    //--------------------------------------------------
    //    OptYReg    -> ',' YREG
    //            -> .
    //            ;
    //--------------------------------------------------
    CRegisterStackItem* pRSI;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter OptYReg", ++m_Recursion);
    pRSI = new CRegisterStackItem;
    pRSI->Create();
    GetValueStack()->Push(pRSI);
    switch (LHChild.GetToken())
    {
    case Token(','):
        pRSI->SetRegType(CRegisterStackItem::RegType::Y);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::YREG);
        break;
    default:
        pRSI->SetRegType(CRegisterStackItem::RegType::NONE);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit OptYReg", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::AsmConstList(CLHead LookaHead)
{
    //--------------------------------------------------
    //    AsmConstList    ->STRING
    //                    ->AsmConstList_1
    //--------------------------------------------------
    int l, i;
    int c;
    int ObjectSize;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    CDataSizeStackItem* pDSSI;

    PrintLookahead(LogFile(), LookaHead, "Enter AsmConstList", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::STRING:
        pDSSI = (CDataSizeStackItem*)GetValueStack()->Pop(CStackItem::ItemType::DATA_SIZE);
        ObjectSize = pDSSI->GetSize();
        l = strlen(GetLexer()->GetLexBuffer());
        for (i = 0; i < l; ++i)
        {
            c = GetLexer()->GetLexBuffer()[i];
            GetCurrentSection()->AddData(ObjectSize, c);
        }
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::STRING);
        break;
    default:
        LookaHead = AsmConstList_1(LookaHead);
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit AsmConstList", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::AsmConstList_1(CLHead LookaHead)
{
    //---------------------------------------------------
    //    AsmConstList_1    -> AsmConstant AsmConstList_2
    //    AsmConstList_2    -> ',' AsmConstant AsmConstList_2
    //                    -> .
    //                    ;
    //---------------------------------------------------
    bool Loop = true;
    CDataSizeStackItem* pDSSI;
    CNumberStackItem* pNSI;
    int ObjectSize;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AsmConstList_1", ++m_Recursion);
    pDSSI = (CDataSizeStackItem*)GetValueStack()->Pop(CStackItem::ItemType::DATA_SIZE);
    ObjectSize = pDSSI->GetSize();
    LHChild = AsmConstant(LookaHead);
    pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    GetCurrentSection()->AddData(ObjectSize, pNSI->GetValue());
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token(','):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token(','));
            LookaHead = AsmConstant(LookaHead);
            pNSI = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
            GetCurrentSection()->AddData(ObjectSize, pNSI->GetValue());
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit AsmConstList_1", ++m_Recursion);
    return LHChild;
}

CLHead CParser::AsmConstant(CLHead LookaHead)
{
    //--------------------------------------------------
    //    AsmCpmstamt        -> '>' AsmConstAddSub
    //                    -> '<' AsmConstAddSub
    //                    -> AsmConstAddSub
    //                    ;
    //--------------------------------------------------
    CNumberStackItem* pNSI = 0;
    int v;
    bool Loop = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AsmConstant", ++m_Recursion);
    LHChild = AsmConstAddSub(LookaHead);
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('>'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('>'));
            LookaHead = AsmConstAddSub(LookaHead);
            pNSI = (CNumberStackItem*)GetValueStack()->Look(0, CStackItem::ItemType::INTVALUE);
            //Lower half of word
            v = pNSI->GetValue();
            v &= 0x0ff;
            pNSI->SetValue(v);
            break;
        case Token('<'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('<'));
            LookaHead = AsmConstAddSub(LookaHead);
            pNSI = (CNumberStackItem*)GetValueStack()->Look(0, CStackItem::ItemType::INTVALUE);
            //Upper half of word
            v = pNSI->GetValue();
            v &= 0x0ff00;
            v >>= 8;
            pNSI->SetValue(v);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit AsmConstant", ++m_Recursion);
    return LHChild;
}

CLHead CParser::AsmConstAddSub(CLHead LookaHead)
{
    //--------------------------------------------------
    //    AsmConstAddSub    -> BaseAsmConstant AsmConstAddSub_1;
    //    AsmConstAddSub_1-> '+' BaseAsmConstant AsmConstAddSub_1
    //                    -> '-' BaseAsmConstant AsmConstAddSub_1
    //                -> .
    //                ;
    //--------------------------------------------------
    bool Loop = true;
    CNumberStackItem* pNSI_1;
    CNumberStackItem* pNSI_2;
    int Value;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter AsmConstAddSub", ++m_Recursion);
    LHChild = BaseAsmConstant(LookaHead);
    pNSI_1 = (CNumberStackItem*)GetValueStack()->Look(0, CStackItem::ItemType::INTVALUE);
    // AsmConstAddSub_1
    while (Loop)
    {
        switch (LHChild.GetToken())
        {
        case Token('+'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('+'));
            LookaHead = BaseAsmConstant(LookaHead);
            pNSI_2 = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
            Value = pNSI_1->GetValue();
            Value += pNSI_2->GetValue();
            pNSI_1->SetValue(Value);
            break;
        case Token('-'):
            LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('-'));
            LookaHead = BaseAsmConstant(LookaHead);
            pNSI_2 = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
            Value = pNSI_1->GetValue();
            Value -= pNSI_2->GetValue();
            pNSI_1->SetValue(Value);
            break;
        default:
            Loop = false;
            break;
        }
    }
    PrintLookahead(LogFile(), LHChild, "Exit AsmConstAddSub", ++m_Recursion);
    return LHChild;
}

CLHead CParser::BaseAsmConstant(CLHead LookaHead)
{
    //--------------------------------------------------
    //    BaseAsmConstant    -> LOCAL_LABLE
    //                    -> GLOBAL_LABLE
    //                    -> IDENT
    //                    -> NUMBER
    //                    -> CHAR_CONSTANT
    //                    -> '*'                //current location counter
    //                    ;
    //--------------------------------------------------
    CNumberStackItem* pNum;
    CSymbol* pSym;
    CWhereSymbolIsUsed* pSymUsed;
    CInstruction* pInstruction;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter BaseAsmConstant", ++m_Recursion);
    switch (LHChild.GetToken())
    {
    case Token::LOCAL_LABEL:
        pNum = new CNumberStackItem;
        pNum->Create();
        pNum->SetValue(((CSymbol*)GetLexer()->GetLexSymbol())->GetAddress());
        pNum->SetSymbol(((CSymbol*)GetLexer()->GetLexSymbol()));
        GetValueStack()->Push(pNum);
        pSymUsed = new CWhereSymbolIsUsed;
        pSymUsed->Create();
        pSymUsed->SetAddress(GetCurrentSection()->GetLocationCounter());
        GetLexer()->GetLexSymbol()->Add((CBin*)pSymUsed);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::LOCAL_LABEL);
        break;
    case Token::GLOBAL_LABLE:
        pNum = new CNumberStackItem;
        pNum->Create();
        pNum->SetValue(((CSymbol*)GetLexer()->GetLexSymbol())->GetAddress());
        pNum->SetSymbol(((CSymbol*)GetLexer()->GetLexSymbol()));
        GetValueStack()->Push(pNum);
        pSymUsed = new CWhereSymbolIsUsed;
        pSymUsed->Create();
        pSymUsed->SetAddress(GetCurrentSection()->GetLocationCounter());
        GetLexer()->GetLexSymbol()->Add((CBin*)pSymUsed);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::GLOBAL_LABLE);
        break;
    case Token::IDENT:
        //-----------------------------------------
        // This is complicated...
        // If this token is returned, it means that
        // this symbol has not yet been defined.
        // That means it will not be possible to
        // resolve what the address in the operand
        // needs to be.  If the lex symbol is NULL,
        // then this is the first time it has been
        // used.  That means it needs to be 
        // created.
        //-----------------------------------------
        pSymUsed = new CWhereSymbolIsUsed;
        pSymUsed->Create();
        pSymUsed->SetSection(GetCurrentSection());
        pNum = new CNumberStackItem;
        pNum->Create();
        pInstruction = (CInstruction*)GetValueStack()->Look(0, CStackItem::ItemType::INSTRUCTION);
        if (pInstruction)
        {
            //--------------------------------
            // Kind of klugy, but if this is
            // an instruction, the data is 
            // one byte beyound the location
            // counter
            //--------------------------------
            pSymUsed->SetAddress(GetCurrentSection()->GetLocationCounter() + 1);
            pInstruction->SetUnResolved();
            if (pInstruction->IsRelative())
                pSymUsed->SetUnResType(CWhereSymbolIsUsed::UnResolvedType::RELATIVE_REFERENCE);
            else
                pSymUsed->SetUnResType(CWhereSymbolIsUsed::UnResolvedType::ABSOLUTE_REFERENCE);
        }
        else
        {
            //--------------------------------
            // Kind of klugy, but if this is
            // a data declaration, then the
            // location is the same as the
            // location counter
            //--------------------------------
            pSymUsed->SetAddress(GetCurrentSection()->GetLocationCounter());
        }
        if (GetLexer()->GetLexSymbol())
        {
            pNum->SetSymbol((CSymbol*)GetLexer()->GetLexSymbol());
            GetLexer()->GetLexSymbol()->Add((CBin*)pSymUsed);
        }
        else
        {
            //-----------------------------------
            // No symbol exists, so create on
            //-----------------------------------
            pSym = new CSymbol;
            pSym->Create();
            pSym->SetName(GetLexer()->GetLexBuffer());
            pSym->SetToken(Token::IDENT);
            pSym->SetUnResolved();
            pSym->Add((CBin*)pSymUsed);
            GetLexer()->GetSymTab()->AddSymbol(pSym);
            pNum->SetSymbol(pSym);
        }
        GetValueStack()->Push(pNum);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::IDENT);
        break;
    case Token::NUMBER:
        pNum = new CNumberStackItem;
        pNum->Create();
        pNum->SetValue(GetLexer()->GetNumber());
        GetValueStack()->Push(pNum);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::NUMBER);
        break;
    case Token::CHAR_CONSTANT:
        pNum = new CNumberStackItem;
        pNum->Create();
        pNum->SetValue(GetLexer()->GetNumber());
        GetValueStack()->Push(pNum);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token::CHAR_CONSTANT);
        break;
    case Token('*'):
        pNum = new CNumberStackItem;
        pNum->Create();
        pNum->SetValue(GetCurrentSection()->GetLocationCounter());
        GetValueStack()->Push(pNum);
        LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('*'));
        break;
    default:
        break;
    }
    PrintLookahead(LogFile(), LookaHead, "Exit BaseAsmConstant", ++m_Recursion);
    return LookaHead;
}

CLHead CParser::Immediate(CLHead LookaHead, CInstruction* pInst)
{
    CNumberStackItem* pIntValue;
    int OpCodeInc;
    int Address;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    PrintLookahead(LogFile(), LookaHead, "Enter Immediate", ++m_Recursion);
    LookaHead.m_Token = Expect(LookaHead.GetToken(), Token('#'));
    LookaHead = AsmConstant(LookaHead);
    pIntValue = (CNumberStackItem*)GetValueStack()->Pop(CStackItem::ItemType::INTVALUE);
    OpCodeInc = GetLexer()->
        FindKeyword(pInst->GetOpCodeToken())->
        FindInc(AdrModeType::IMMEDIATE_ADR);
    pInst->AddToOpCode(OpCodeInc);
    Address = pIntValue->GetValue();
    pInst->SetLowByte(Address);
    pInst->SetByteCount(2);
    PrintLookahead(LogFile(), LookaHead, "Exit Immediate", ++m_Recursion);
    return LookaHead;
}

void CParser::PageZero(
    CInstruction* pInst,
    int Address,
    AdrModeType ModeType
)
{
    int OpCodeInc;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    pInst->SetByteCount(2);
    OpCodeInc = GetLexer()->
        FindKeyword(pInst->GetOpCodeToken())->
        FindInc(ModeType);
    pInst->SetLowByte(Address);
    pInst->AddToOpCode(OpCodeInc);
}

void CParser::Absolute(
    CInstruction* pInst,
    int Address,
    AdrModeType ModeType
)
{
    int OpCodeInc;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    pInst->SetByteCount(3);
    OpCodeInc = GetLexer()->
        FindKeyword(pInst->GetOpCodeToken())->
        FindInc(ModeType);
    pInst->SetOperandW(Address);
    pInst->AddToOpCode(OpCodeInc);
}

bool CParser::CheckZeroPageAddress(int A)
{
    bool rV = true;
    CAstNode* pN= 0;
    CLHead LHChild, LHNext;

    if (A > 255||A<0)
    {
        ThrownException.SetXCeptType(Exception::ExceptionType::VALUE_EXCEEDS_RANGE);
        sprintf_s(
            ThrownException.GetErrorString(),
            ThrownException.GetMaxStringLen(),
            "Zero Page Address:$%x Must be <= $ff",
            A
        );
        throw(ThrownException);
    }
    return rV;
}

void CParser::PrintLookahead(
    FILE* pLog,
    CLHead token,
    const char* pS,
    int RecursionLevel,
    int bump
)
{
    char* pLookaheadToken;
    int TokenValue;
    char* pLexBuff;

    if (pLog)
    {
        if (bump)
            m_Bump += bump;
        pLexBuff = GetLexer()->GetLexBuffer();
        switch (token.GetToken())
        {
        case Token::IDENT:
            pLookaheadToken = GetLexer()->GetLexSymbol()->GetName();
            fprintf(LogFile(), "  %5d.%d::%s  Lookahead = %s LexBuffer \'%s\'\n",
                RecursionLevel,
                m_Bump,
                pS,
                pLookaheadToken,
                pLexBuff
            );
            break;
        case Token::NUMBER:
            TokenValue = GetLexer()->GetNumber();;
            fprintf(LogFile(), "  %5d.%d::%s TokenValue: = %d LexBuffer \'%s\'\n",
                RecursionLevel,
                m_Bump,
                pS,
                TokenValue,
                pLexBuff
            );
            break;
        default:
            pLookaheadToken = (char*)GetLexer()->GetKeyWords()->LookupToName(token.m_Token);
            if (token.GetNode() == 0)
            {
                fprintf(LogFile(), "  %5d.%d::%s Lookahead CLHead: %s LexBuffer \'%s\' \n",
                    RecursionLevel,
                    m_Bump,
                    pS,
                    pLookaheadToken,
                    pLexBuff
                );
            }
            else
            {
                fprintf(LogFile(), "  %5d.%d::%s TOKEN:%s LexBuffer:\'%s\' AST node:%s\n",
                    RecursionLevel,
                    m_Bump,
                    pS,
                    pLookaheadToken,
                    pLexBuff,
                    token.m_pNode->GetNodeName() ? token.m_pNode->GetNodeName() : "Name is NULL"
                );
            }
            break;
        }
    }
    if (token.GetNode())
        token.GetNode()->Print(LogFile(), 0,(char*) "");
}

const char* CParser::PHASE_LUT::LookupPhaseName(PHASE phase)
{
    return nullptr;
}

CParser::PHASE CParser::PHASE_LUT::LookupPhaseToken(const char* pName)
{
    return PHASE();
}

 ---------- pch.cpp -------------
#include "pch.h"


Exception ThrownException;

const char* Exception::GetExceptionTypeString(ExceptionType xType)
{
    const char* pName = 0;
    int i;
    bool Loop = true;

    for (i = 0; Loop && ExceptionTypesLUT[i].m_Name; ++i)
    {
        if (ExceptionTypesLUT[i].m_Type == xType)
        {
            pName = ExceptionTypesLUT[i].m_Name;
            Loop = false;
        }
    }
    return pName;
}

const char* Exception::ExcepTypeToString::FindString(ExceptionType Type)
{
    const char* pString = 0;
    int i;
    bool Loop = true;

    for (i = 0; Loop && (ExceptionTypesLUT[i].m_Name != 0 ); ++i)
    {
        if (ExceptionTypesLUT[i].m_Type == Type)
        {
            pString = ExceptionTypesLUT[i].m_Name;
            Loop = false;
        }
    }
    return pString;
}

const char* Exception::ExceptionSubTypeStrings::FindSubTypeString(ExceptionSubType Type)
{
    const char* pString = 0;
    int i;
    bool Loop = true;

    for (i = 0; Loop && (XcepSubTypesLUT[i].m_Name != 0); ++i)
    {
        if (XcepSubTypesLUT[i].m_Type == Type)
        {
            pString = XcepSubTypesLUT[i].m_Name;
            Loop = false;
        }
    }
    return pString;
}

 ---------- RegisterStackItem.cpp -------------
#include "pch.h"

CRegisterStackItem::CRegisterStackItem()
{
    m_RegType = RegType::NONE;
}

CRegisterStackItem::~CRegisterStackItem()
{
}

bool CRegisterStackItem::Create()
{
    CStackItem::Create(CStackItem::ItemType::REGTYPE);
    return true;
}

 ---------- Section.cpp -------------
#include "pch.h"

CSection::CSection():CBin(BinType::SECTION)
{
    m_StartAddress = 0;
    m_Size = 0;
    m_LocationCounter = 0;
    m_pSectionData = 0;
    m_AccessMode = Mode::MODE_READ_ONLY;
    m_ZeroPageAddressSize = AddressSize::ADDRESSSIZE_WORD;
}

CSection::~CSection()
{
    if (m_pSectionData) delete[] m_pSectionData;
}

bool CSection::Create()
{
    bool rV = true;
    CBin::Create();
    return rV;
}

void CSection::SetStartAddress(unsigned Start)
{
    if ((Start + m_Size) <= 0x010000u)
    {
        m_LocationCounter = Start;
        m_StartAddress = Start;
        if (m_Size > 0)
        {
            unsigned i;

            m_pSectionData = new char[m_Size];
            for (i = 0; i < m_Size; ++i)
                m_pSectionData[i] = 0;
        }
    }
    else
    {
        ThrownException.SetXCeptType(Exception::ExceptionType::SECTION_ADDRES_RANGE_EXCEEDED);
        ThrownException.SetSymbol(this);
        ThrownException.SetGotToken(Token::NUMBER);
        sprintf_s(
            ThrownException.GetErrorString(),
            ThrownException.GetMaxStringLen(),
            "Section:%s  Start Address:$%04x  Size:$%04x Over By:$%04x\n",
            GetName(),
            Start,
            m_Size,
            Start + m_Size - 0x10000
        );
        throw(ThrownException);
    }
}

void CSection::SetSectionSize(unsigned Size)
{
    if (m_StartAddress + Size <= 0x10000)
    {
        m_Size = Size;
        if (m_Size > 0)
        {
            unsigned i;

            m_pSectionData = new char[m_Size];
            for (i = 0; i < m_Size; ++i)
                m_pSectionData[i] = 0;
        }
    }
    else
    {
        ThrownException.SetXCeptType(Exception::ExceptionType::SECTION_ADDRES_RANGE_EXCEEDED);
        ThrownException.SetSymbol(this);
        ThrownException.SetGotToken(Token::NUMBER);
        sprintf_s(
            ThrownException.GetErrorString(),
            ThrownException.GetMaxStringLen(),
            "Section:%s  Start Address:$%04x  Size:$%04x Over By:$%04x\n",
            GetName(),
            m_StartAddress,
            Size,
            m_StartAddress + Size - 0x10000
        );
        throw(ThrownException);
    }
}

void CSection::SetLocationCounter(unsigned short NewAddress)
{
    if ((NewAddress < (m_StartAddress + m_Size)) &&
        (NewAddress >= m_StartAddress)
        )
    {
        m_LocationCounter = NewAddress;
    }
    else
    {
        ThrownException.SetXCeptType(Exception::ExceptionType::SECTION_ADDRES_RANGE_EXCEEDED);
        ThrownException.SetSymbol(this);
        ThrownException.SetGotToken(Token::NUMBER);
        sprintf_s(
            ThrownException.GetErrorString(),
            ThrownException.GetMaxStringLen(),
            "Section:%s  Start Address:$%04x  Size:$%04x Over By:$%04x\n",
            GetName(),
            0,
            m_Size,
            NewAddress
        );
        throw(ThrownException);
    }
}

unsigned short CSection::AddData(unsigned ObjectSize, int Value)
{
    char* b;
    short* s;
    long* l;

    Info();
    switch (ObjectSize)
    {
    case 1:
        b = (char*)&m_pSectionData[m_LocationCounter - m_StartAddress];
        m_LocationCounter += 1;
        *b = char(Value);
        break;
    case 2:
        s = (short*)&m_pSectionData[m_LocationCounter - m_StartAddress];
        m_LocationCounter += 2;
        *s = short(Value);
        break;
    case 4:
        l = (long*)&m_pSectionData[m_LocationCounter - m_StartAddress];
        m_LocationCounter += 4;
        *l = long(Value);
        break;
    }
    return m_LocationCounter;
}

void CSection::AddDataAt(
    unsigned Address, 
    unsigned ObjectSize, 
    int Value
)
{
    char* b;
    short* s;
    long* l;

    Info();
    switch (ObjectSize)
    {
    case 1:
        b = (char*)&m_pSectionData[Address - m_StartAddress];
        *b = char(Value) + *b;
        break;
    case 2:
        s = (short*)&m_pSectionData[Address - m_StartAddress];
        *s = short(Value) + *s;
        break;
    case 4:
        l = (long*)&m_pSectionData[Address - m_StartAddress];
        *l = long(Value) + *l;
        break;
    }
}

unsigned short CSection::AllocateDataBlock(unsigned short size)
{
    m_LocationCounter += size;
    return m_LocationCounter;
}

void CSection::Print(FILE* pOut, const char* s)
{
    fprintf(pOut, "Section:%s:Size:$%04X MODE:%s\n",
        GetName(),
        m_Size,
        int(m_AccessMode) ? "Read/Write" : "Read Only"
    );
    CActionApp::Dump(
        pOut,
        m_pSectionData,
        GetStartAddress(),
        GetSectionSize()
    );
}

void CSection::Info()
{
//    fprintf(
//        Act()->LogFile(),
//        "%s Loc Cntr:%04x\n",
//        GetName(),
//    );
}

 ---------- Stack.cpp -------------
#include "pch.h"

CStack::CStack()
{
    m_pHead = 0;
    m_ItemCount = 0;
    m_pName = 0;
}

CStack::~CStack()
{
    CStackItem* pSI;

//    fprintf(
//        stderr,
//        "Stack Size = %d\n", m_ItemCount
//    );
    while (m_pHead)
    {
        pSI = m_pHead->GetNext();
        delete m_pHead;
        m_pHead = pSI;
    }
}

bool CStack::Create(const char* pName)
{
    m_pName = pName;
    return true;
}

void CStack::Push(CStackItem* pItem)
{
    if (pItem)
    {
        ++m_ItemCount;
        pItem->SetNext(GetHead());
        SetHead(pItem);
        if (m_ItemCount > 100)
            printf("Is Stack Overflowing? %d\n", m_ItemCount);
        Print(Act()->LogFile(), "PUSH", 4, pItem);
    }
}

CStackItem* CStack::Pop(CStackItem::ItemType Type)
{
    CStackItem* pRV = 0;

    if (m_ItemCount)
    {
        --m_ItemCount;
        if (GetHead())
        {
            if (IsTopOfType(Type))
            {
                pRV = GetHead();
                SetHead(GetHead()->GetNext());
                Print(Act()->LogFile(), "POP", 4, pRV);
            }
            else
            {
                sprintf_s(
                    m_sExceptionString,
                    MAX_STRING_LEN,
                    "Got Stack Item Type:%s\nWanted Stack Item Type:%s\n",
                    GetHead()->LookupItemName(GetHead()->GetStackItemType()),
                    GetHead()->LookupItemName(Type)
                );
                StackException(
                    m_sExceptionString,
                    Exception::ExceptionSubType::STACK_ITEM_MISMATCH
                );
            }
        }
        else
        {
            StackException(
                "Stack Emptyh:Count wrong", 
                Exception::ExceptionSubType::STACK_UNEXPECTED_NULL
            );
        }
    }
    else
    {
        StackException(
            "Cannot Pop an Empty Stack",
            Exception::ExceptionSubType::STACK_EMPTY
        );

    }
    return pRV;
}

CStackItem* CStack::Look(int Depth, CStackItem::ItemType Type)
{
    int i = 0;
    CStackItem* pRV = 0;;
    bool Loop = true;

    if (GetHead())
    {
        for (i = 0, pRV = GetHead(); i < Depth && Loop; ++i)
        {
            if (pRV == 0)
            {
                Loop = false;
            }
            else
            {
                pRV = pRV->GetNext();
            }
        }
        if (!pRV->Verify(Type))
        {
            ThrownException.SetXCeptType(Exception::ExceptionType::INTERNAL_ERROR);
            sprintf_s(
                ThrownException.GetErrorString(),
                ThrownException.GetMaxStringLen(),
                "Look:%s Stack:Look:Got %s Expected %s--Line %d Col %d",
                GetStackName(),
                CStackItem::LookupItemName(pRV->GetStackItemType()),
                CStackItem::LookupItemName(Type),
                Act()->GetParser()->GetLexer()->GetLineNumber(),
                Act()->GetParser()->GetLexer()->GetColunm()
            );
            throw(ThrownException);
        }
    }
    return pRV;
}

bool CStack::IsTopOfType(CStackItem::ItemType Type)
{
    bool rV = false;

    if (GetHead())
    {
        if (GetHead()->GetStackItemType() == Type)
            rV = true;
    }
    else
    {
        fprintf(stderr,
            "Stack %s Is Empty Line:%d\n",
            GetStackName(),
            Act()->GetParser()->GetLexer()->GetLineNumber()
        );
    }
    return rV;
}

void CStack::Print(
    FILE* pLog,  
    const char* pOperation,
    int Indent,
    CStackItem* pRV
)
{
    char* IndentString = new char[256];
    const char* pItemTypeName;

    Act()->CreateIndentString(IndentString, 256, Indent);
    if (pLog)
    {
        if (pRV)
        {
            pItemTypeName =pRV->LookupItemName(pRV->GetStackItemType());
        }
        else
            pItemTypeName = "";
        fprintf(pLog, "\n%s------------------\n", IndentString);
        fprintf(pLog, 
            "%sStack:%s:%s:TYPE:%s Line:%d\n", 
            IndentString,
            GetStackName(), 
            pOperation,
            pItemTypeName,
            Act()->GetParser()->GetLexer()->GetLineNumber()
        );
        fprintf(pLog, "%sItemCount:%d\n", IndentString,GetItemCount());
        fprintf(pLog, "%s------------------\n\n", IndentString);
    }
    delete[]IndentString;
}

void CStack::StackException(const char* pDesc, Exception::ExceptionSubType SubType)
{
    ThrownException.SetXCeptType(Exception::ExceptionType::STACK);
    sprintf_s(
        ThrownException.GetErrorString(),
        ThrownException.GetMaxStringLen(),
        "Stack:%s::%s\n--Line: %d Col: %d",
        GetStackName(),
        pDesc,
        Act()->GetParser()->GetLexer()->GetLineNumber(),
        Act()->GetParser()->GetLexer()->GetColunm()
    );
    throw(ThrownException);
}

 ---------- StackItem.cpp -------------
#include "pch.h"

CStackItem::CStackItem()
{
    m_pNext = 0;
    m_Type = ItemType::NONE;
}

CStackItem::~CStackItem()
{
}

bool CStackItem::Create(ItemType Type)
{
    bool rV = true;

    m_Type = Type;
    return rV;
}

bool CStackItem::Verify(CStackItem::ItemType Type)
{
    bool rV = false;

    if (Type == GetStackItemType())
        rV = true;
    return rV;
}

const char* CStackItem::LookupItemName(CStackItem::ItemType Type)
{
    return CStackItem::ItemTypeLUT::FindItemName( Type);
}


const char* CStackItem::ItemTypeLUT::FindItemName(CStackItem::ItemType Type)
{
    const char* pName = 0;
    int i;
    bool Loop = true;

    for (i = 0;Loop && TypeString[i].m_pName; ++i)
    {
        if (Type == TypeString[i].m_Type)
        {
            pName = TypeString[i].m_pName;
            Loop = false;
        }
    }
    return pName;
}

 ---------- StackNodeItem.cpp -------------
#include "pch.h"

CStackNodeItem::CStackNodeItem()
{
    m_pAstNode = 0;
}

CStackNodeItem::~CStackNodeItem()
{
}

bool CStackNodeItem::Create(CAstNode* pNode)
{
    bool rV = true;
    CStackItem::Create(CStackItem::ItemType::NODE);
    SetNode(pNode);
    return rV;
}

 ---------- StackSectionItem.cpp -------------
#include "pch.h"

CStackSectionItem::CStackSectionItem()
{
}

CStackSectionItem::~CStackSectionItem()
{
}

bool CStackSectionItem::Create(CSection* pSect)
{
    bool rV = true;
    CStackItem::Create(CStackItem::ItemType::SECTION);
    SetSection(pSect);
    return true;
}

 ---------- StackSymbolItem.cpp -------------
#include "pch.h"

CStackSymbolItem::CStackSymbolItem()
{
    m_pSymbol = 0;
}

CStackSymbolItem::~CStackSymbolItem()
{
}

bool CStackSymbolItem::Create(CSymbol* pSym)
{
    bool rV = true;

    CStackItem::Create(CStackItem::ItemType::SYMBOL);
    SetSymbol(pSym);
    return rV;
}

 ---------- Symbol.cpp -------------
#include "pch.h"

bool CSymbol::Compare(const char* name, int scope)
{
    bool rV = false;

    if (strcmp(GetName(), name) == 0)
    {
        if (scope > 0)
        {
            if (scope == GetScope())
                rV = true;
        }
        else
            rV = true;
    }
    return rV;
}


void CSymbol::BackFillUnresolved()
{
    CWhereSymbolIsUsed* pWSIU;
    int Address;
    int URLocation; //unresolved location

    Address = GetAddress();
    //    fprintf(
    //        As65App.LogFile(),
    //        "Back Fill %s @ 0x%4x\n",
    //        GetName(),
    //        Address
    //    );
    pWSIU = (CWhereSymbolIsUsed*)GetHead();
    while (pWSIU)
    {
        URLocation = pWSIU->GetAddress();
        //        fprintf(
        //            As65App.LogFile(),
        //            "Unresolved: @0x%04x\n",
        //            URLocatioon
        //        );
        if (pWSIU->GetUnResType() == CWhereSymbolIsUsed::UnResolvedType::ABSOLUTE_REFERENCE)
        {
            //------------------------------------------
            // Get the location of an unresolved value,
            // and then put the data defined by this
            // symbol in there.
            //------------------------------------------
            pWSIU->GetSection()->AddDataAt(
                pWSIU->GetAddress(),    //address of data
                2,                        // size of object
                Address                    // object value
            );
        }
        else
        {
            //------------------------------------------
            // for relative address, subtract the
            // location of the unresoved symbol from
            // the value of this object.
            //------------------------------------------
            unsigned WhereSymIsUsedAddress = pWSIU->GetAddress();
            unsigned RelAddress = Address - WhereSymIsUsedAddress;

            RelAddress--;
            pWSIU->GetSection()->AddDataAt(
                WhereSymIsUsedAddress,
                1,
                RelAddress
            );
        }
        pWSIU = (CWhereSymbolIsUsed*)pWSIU->GetNext();
    }
    SetResolved();
}

void CSymbol::AddAtHead(CObjType* pObjType)
{
    if (GetHead())
    {
        GetTcHead()->SetPrev(pObjType);
        pObjType->SetNext(GetTcTail());
        SetTcHead(pObjType);
    }
    else
    {
        SetTcTail(pObjType);
        SetTcHead(pObjType);
    }
}

void CSymbol::AddAtTail(CObjType* pObjType)
{
    if (GetHead())
    {
        GetTcTail()->SetNext(pObjType);
        pObjType->SetPrev(GetTcTail());
        SetTcTail(pObjType);
    }
    else
    {
        SetTcTail(pObjType);
        SetTcHead(pObjType);
    }
}

void CSymbol::Delete(CObjType* pObjType)
{
    Unlink(pObjType);
    delete pObjType;
}

void CSymbol::Unlink(CObjType* pObjType)
{
    if (GetTcHead() == pObjType)
    {
        SetTcHead(pObjType->GetNext());
        if (GetTcHead())
            GetTcHead()->SetPrev(0);
    }
    else if (GetTcTail() == pObjType)
    {
        SetTcTail(pObjType->GetPrev());
        if (GetTcTail())
            GetTcTail()->SetNext(0);
    }
    else
    {
        pObjType->GetNext()->SetPrev(pObjType->GetPrev());
        pObjType->GetPrev()->SetNext(pObjType->GetNext());
    }
}

void CSymbol::Print(FILE* pOut, const char* s)
{
    fprintf(pOut, "%s:Address=%08lx  Value=%04x  Scope=%d\n",
        GetName(),
        GetAddress(),
        GetValue(),
        GetScope()
    );
}

 ---------- SymTab.cpp -------------
#include "pch.h"

//***************************************
// Implementation of Hash Table Member
// Functions
//***************************************

//-------------------------------------------
// Constructor
//
// parameter:
//    size......number of Bins in the table
//
// Now, don't ask me why, but I heard that
// it is best to use a prime number for the
// number of bins.  I suspect the reason why
// is that we are doing a MOD opertion in
// the hashing function to make sure the
// index ends up in the table.
//
// And if you are like me, you can't
// remember what the prime number are.
// So, here is a list form 0 to 200.
// 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
//  31, 37, 41, 43, 47, 53, 59, 61, 67
// 71, 73, 79, 83, 89, 97, 101, 103, 107,
// 109, 113, 127, 131, 137, 139, 149,
// 151, 157, 163, 167, 173, 179, 181,
// 191, 193, 197, 199
//--------------------------------------------

//*****************************************************
// Destructor
//
// destroy HashTab and all of its components
//*****************************************************

CSymTab::~CSymTab()
{
    CBucket* pBucket;
    int i = 0;

    for (i = 0; i < m_tSize; ++i)
    {
        pBucket = m_ppTab[i];
        delete pBucket;
    }
    
    if (m_ppTab) delete[] m_ppTab;
}

bool CSymTab::Create(int TableDepth)
{
    m_ppTab = new CBucket * [TableDepth];
    m_tSize = TableDepth;
    for (int i = 0; i < m_tSize; ++i)
        m_ppTab[i] = 0;
    m_nElements = 0;
    return true;
}

//*****************************************************
// FindSym
//
// parameter:
//    name....name of object to find
//
//******************************************************

CBin* CSymTab::FindSymbol(const char* name, int scope)
{
    CBin* pRV = NULL;

    int Index = Hash(name);    //get index from hash of name
    if(m_ppTab[Index] != 0)
        pRV = m_ppTab[Index]->Find(name, scope);
    return pRV;
}

//***********************************************************
// AddSym
//
// parameter:
//    pSym....pointer to Bin to add to table
//
//***********************************************************

void CSymTab::AddSymbol(CBin* pSym)
{
    int Index = Hash(pSym->GetName());    //generate index
    
    if (m_ppTab[Index] == NULL)    //there is NO bucket here
    {
        m_ppTab[Index] = new CBucket;
        m_ppTab[Index]->Create();
    }

    if (m_ppTab[Index]->GetHead() == NULL)    //nobody home
    {
        m_ppTab[Index]->SetHead(pSym);
        m_ppTab[Index]->SetTail(pSym);
    }
    else
    {
        CBucket* pB = m_ppTab[Index];
        pB->GetTail()->SetNext(pSym);
        pSym->SetPrev(pB->GetTail());
        pB->SetTail(pSym);
    }
    ++m_nElements;    //increment number of symbols
}

//*****************************************************
// DelSym
//
// parameter:
//    pSym.....pointer to symbol to remove
//*****************************************************

void CSymTab::DelSymbol(CBin* pSym)
{
    int HashValue = Hash(pSym->GetName());
    m_ppTab[HashValue]->Delete(pSym);
}

//*********************************************************
// Hash
//
// parameter
//    name.....pointer to name to Hash
//
//**********************************************************

int CSymTab::Hash(const char* name)
{
    unsigned HashVal = 0;
    unsigned TopBits;
    unsigned char* n;

    n = (unsigned char*)name;
    while (*n)
    {
        HashVal = (HashVal << 12) + *n;
        if ((TopBits = HashVal & 0xff000000) != 0)
            HashVal = ((TopBits >> 24) ^ HashVal) & 0x00ffffff;
        ++n;    //next char please...
    }
    return HashVal % m_tSize;    //returns index in table
}


//***************************************************
// PrinTable
//
// paramter:
//    pOut.....output file stream
//
//*****************************************************

void CSymTab::PrintTable(FILE* pOut)
{
    char* s = new char[512];
    CBin* pB;
    int i;
    int maxStringLen = 0;
    int l;

    //------------------------------
    // Scan table to find longest
    // name
    //------------------------------
    for (i = 0; i < m_tSize; ++i)
    {
        if (m_ppTab[i] == NULL)
        {
            pB = NULL;
        }
        else
            pB = m_ppTab[i]->GetHead();
        while (pB)
        {
            l = (int)strlen(pB->GetName());
            if (l > maxStringLen)
                maxStringLen = l;
            pB = pB->GetNext();
        }
    }

    for (i = 0; i < m_tSize; ++i)
    {
        if (m_ppTab[i] == NULL)
        {
            pB = NULL;
        }
        else
            pB = m_ppTab[i]->GetHead();
        while (pB)
        {
            pB->Print(pOut);
            pB = pB->GetNext();
        }
    }
}


bool CSymTab::FindAll(CBin::BinType Type, int NumberOfObject, CBin** ppObjects)
{
    bool rV = true;
    int ItemCount = 0;
    CBucket* pBucket;
    CBin* pBin;
    int i;

    for (i = 0; i < m_tSize; ++i)
    {
        pBucket = this->GetTable()[i];
        if (pBucket)
        {
            pBin = pBucket->GetHead();
            while (pBin)
            {
                if (pBin->GetType() == Type)
                {
                    if (ItemCount < NumberOfObject)
                    {
                        ppObjects[ItemCount] = pBin;
                        ItemCount++;
                    }
                    else
                    {
                        ++ItemCount;
                    }
                }
                pBin = pBin->GetNext();
            }
        }
    }
    if (ItemCount > NumberOfObject - 1)
        rV = false;
    return rV;
}


 ---------- UnResolvedSymbol.cpp -------------
#include "pch.h"

CUnResolvedSymbol::CUnResolvedSymbol():CBin(CBin::BinType::UNRESOLVED)
{
    m_Address = 0;
    m_pSection = 0;
    m_UnResRefType = CWhereSymbolIsUsed::UnResolvedType::ABSOLUTE_REFERENCE;
}

CUnResolvedSymbol::~CUnResolvedSymbol()
{
}

bool CUnResolvedSymbol::Create()
{
    return CBin::Create();
}

void CUnResolvedSymbol::SetAddress(unsigned a)
{
    m_Address = a;
    fprintf(
        Act()->LogFile(),
        "Set Unresolved Symbol Location : %04x\n",
        a
    );
}

 ---------- Value.cpp -------------
#include "pch.h"

CValue::CValue()
{
    m_pSym = 0;
}

CValue::~CValue()
{
}

bool CValue::Create(CBin* pSym)
{
    bool rV = true;

    SetSymbol(pSym);
    return rV;
}

 ---------- WhereSymbolIsUsed.cpp -------------
#include "pch.h"

CWhereSymbolIsUsed::CWhereSymbolIsUsed() :CBin(CBin::BinType::WHERE_USED)
{
    m_Address = 0;
    m_pSection = 0;
    m_UnResRefType = UnResolvedType::ABSOLUTE_REFERENCE;
}

CWhereSymbolIsUsed::~CWhereSymbolIsUsed()
{
}

bool CWhereSymbolIsUsed::Create()
{
    return CBin::Create();
}

void CWhereSymbolIsUsed::SetAddress(int a)
{
    m_Address = a;
//    fprintf(
//        Act()->LogFile(),
//        "Set Unresolved Symbol Location : %04x\n",
//        a
//    );
}
