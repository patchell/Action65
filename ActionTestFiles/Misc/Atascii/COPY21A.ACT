;**********************************›;›; Copy Program›;›;**********************************›;›SET $E=$4100›SET $491=$4100››PROC h=*()[$00$00$00$07$00$00]›[$AD$2A$07$8D$E7$02$85$0E$AD$2B$07$8D]›[$E8$02$85$0F$AD$28$07$85$0A$8D$04$07]›[$AD$29$07$85$0B$8D$05$07$18$60]›MODULE›DEFINE STRING="CHAR ARRAY"››CARD Start›CARD EndProg›STRING ban1="Äõðìéãáôïò Ãïðù Ðòïçòáí ÒÅÖ ²®µ±",›       ban2="    by Jim Patchell",›       ban3=" concept by Bob Gardner"› ›MODULE ; SYS.ACT››DEFINE EOL="$9B"›DEFINE OpenBuf =  "$0500"›DEFINE OpenBufL = "$00"›DEFINE OpenBufH = "$05"››STRING copy_right(0) =›    "(c)1983 Action Computer Services"››; Primitive IO routines›PROC Clos=*(BYTE d)[$FFA2$A686$CA0$AD0]››PROC Output=*(BYTE d, STRING s)›[$A684$BA0$4D0]› ›PROC In=*(BYTE d, STRING s)›[$A684$5A0$A586$A2$0$A386]››PROC XIOstr=*(BYTE d,x,c,a1,a2,STRING s)›[$A0A$A0A$98AA$9D$342$A3A5$AF0$9D$34A$A4A5$9D$34B$A9$0$9DA8$349›$A5B1$9D$348$12F0$18$A5A5$169$9D$344$A6A5$69$0$9D$345$4C$E456$60]››PROC Opn=*(BYTE d,STRING s,BYTE m,o)›[$A586$A684$3A0$4CXIOstr]››PROC Prt=*(BYTE d,STRING s)›[$A586$A684$A2$0$A386$9A0$20XIOstr$AD0$BA9$9D$342$9BA9$4C$E456$60]››PROC Error(BYTE err)[$6C$A$0$1113$8301]››PROC Break=*()›[$BA$8E$4C1$80A0$98$4C Error]›››; math library routines›PROC LShift=*()›[$84A4$AF0$8586$A$8526$88$FAD0$85A6$60]››PROC RShift=*()›[$84A4$AF0$8586$8546$6A$88$FAD0$85A6$60]››PROC SetSign=*()[$D3A4$1010]›PROC SS1=*()›[$8685$8786$38$A9$0$86E5$A8$A9$0$87E5$AA$98$60]››PROC SMOps=*()›[$D386$E0$0$310$20SS1$8285$8386$85A5$E10$AA$D345$D385›$84A5$20SS1$8485$8586$A9$0$8785$60]››PROC MultB=*()›[$1BF0$CA$C786$AA$15F0$C686$A9$0$8A2$A$C606$290$C765$CA$F6D0›$18$8765$8785$86A5$87A6$60]››PROC MultI=*()›[$20SMOps$82A6$1BF0$C686$84A6$15F0$CA$C786›$8A2$A$8726$C606$690$C765$290$87E6$CA$F0D0›$8685$82A5$85A6$20MultB$83A5$84A6$20MultB$4CSetSign]››PROC SArgs=*()›[$A085$A186$A284$18$68$8485$369$A8$68$8585$69$0$48$98$48$1A0›$84B1$8285$C8$84B1$8385$C8$84B1›$A8$B9$A0$0$8291$88$F810$11A5$FD0$11E6$4C Break$6308$1109$1819$2113$3323$60]››SET $4E4=LShift›SET $4E6=RShift›SET $4E8=MultI›SET $4EE=SArgs››PROC ChkErr=*(BYTE r,b,eC)[$1610$88C0$8F0›$98$80C0$11F0›$4C Error$8A$4A4A$4A4A$98AA$9D EOF$60]››PROC Break1=*(BYTE err)›[$1A2$1186$48$20 Break$68$A8$60]››PROC Open=*(BYTE d,STRING f,BYTE m,a2)›[$48$A186$A284$A8$A9$0$99 EOF$A8$A1B1$8D OpenBuf $A8$C8$9BA9$2D0$A1B1$99 OpenBuf $88$F8D0›$68$A2 OpenBufL $A0 OpenBufH $20Opn$4C ChkErr]››PROC PrintE=*(STRING s)[$A186$AA$A1A4$A5device]›PROC PrintDE=*(BYTE d,STRING s)›[$20 Prt$4C ChkErr]››PROC Close=*(BYTE d)[$20 Clos$4C ChkErr]››PROC Print=*(STRING s)[$A186$AA$A1A4$A5device]›PROC PrintD=*(BYTE d,STRING s)›[$20Output$4C ChkErr]››PROC InS=*()›[$20In$A084$BD$348$3F0$38$1E9$A0$0$A591$A0A4$60]››PROC InputS=*(STRING s)[$A286$AA$A2A4$A5device]›PROC InputSD=*(BYTE d,STRING s)[$48$FFA9$A385$68]›PROC InputMD=*(BYTE d,STRING s,BYTE m)›[$48$A186$A284$A0$0$A3A5$A191$68$A2A4]›PROC InputD=*(BYTE d,STRING s)[$20InS$4C ChkErr]››CHAR FUNC GetD=*(BYTE d)[$7A2]›PROC CCIO=*()›[$A486$A0A$A0A$AA$A4A5$9D$342$A9$0$9D$348$9D$349›$98$20$E456$A085$4C ChkErr]››PROC PutE=*()[$A9$9B]›PROC Put=*(CHAR c)[$AA$A5device]›PROC PutD=*(BYTE d,CHAR c)[$A186$A1A4]›PROC PutD1=*()[$BA2$4C CCIO]››PROC PutDE=*(BYTE dev)[$A0$9B$F7D0]››PROC XIO=*(BYTE d,f,c,a1,a2,STRING s)›[$20XIOstr$4C ChkErr]››PROC CToStr=*()›[$D485$D586$20$D9AA$20$D8E6$FFA0$A2$0$C8$E8›$F3B1$9D$550$F710$8049$9D$550$8E$550$60]››PROC PrintB=*(BYTE n)[$A2$0]›PROC PrintC=*(CARD n)[$20 CToStr$A5device]›PROC PNum=*()[$50A2$5A0$20 Output$4C ChkErr]››PROC PrintBE=*(BYTE n)[$A2$0]›PROC PrintCE=*(CARD n)[$20PrintC$4CPutE]››PROC PrintBD=*(BYTE d, n)[$A0$0]›PROC PrintCD=*(BYTE d, CARD n)›[$A085$8A$A284$A2A6$20 CToStr$A0A5$4CPNum]››PROC PrintBDE=*(BYTE n)[$A0$0]›PROC PrintCDE=*(BYTE d,CARD n)›[$20PrintCD$A0A5$4CPutDE]››PROC PrintI=*(INT n)[$A286$AA$A2A4$A5device]›PROC PrintID=*(BYTE d,INT n)[$C0$0$1610$48$A186$A284$2DA0›$20PutD1$38$A9$0$A1E5$AA$A9$0$A2E5$A8$68$4CPrintCD]››PROC PrintIE=*(INT n)[$20PrintI$4CPutE]››PROC PrintIDE=*(BYTE d,INT n)›[$20PrintID$A0A5$4CPutDE]››PROC StrB=*(BYTE n, STRING s)[$A286$A384$A2$0$A2A4]›PROC StrC=*(CARD n, STRING s)[$A284$20 CToStr$C8$B9$550$A291$88$F810$60]›PROC StrI=*(INT n, STRING s)[$E0$0$ED10$A085$A186$A284›$38$A9$0$A0E5$A8$A9$0$A1E5$AA$98$20 CToStr$E8$8A›$A8$B9$54F$A291$88$F8D0$8A$A291$C8$2DA9$A291$60]››BYTE FUNC InputB=*()›CARD FUNC InputC=*()›INT FUNC InputI=*()›[$A5 device]›BYTE FUNC InputBD=*(BYTE d)›CARD FUNC InputCD=*(BYTE d)›INT FUNC InputID=*(BYTE d)›[$13A2$8E$550$50A2$5A0$20InputD$50A9$5A2]›BYTE FUNC ValB=*(STRING s)›CARD FUNC ValC=*(STRING s)›INT FUNC ValI=*(STRING s)›[$A485$A586$A0$0$A084$A184$A284$A4B1$A385$A3E6›$20A9$C8$A4D1$5D0$C8$A3C4$F730$A4B1$2DC9$3D0$A285$C8$A3C4$3610›$A4B1$30C9$3030$3AC9$2C10$38$30E9$AA›$A1A5$48$A0A5$A$A126$A$A126$18$A065$A085$68$A165$A185$A006$A126›$18$8A$A065$A085$290$A1E6$C8$A3C4$CA30›$A2A5$DF0$38$A9$0$A0E5$A085$A9$0$A1E5$A185$60]›MODULE››DEFINE NULL="0"››TYPE BLOCK=[CARD size,next]››CARD MemLo=$2E7, MemHi=$2E5››BLOCK POINTER FreeList››CARD FUNC Alloc(CARD nBytes)››  BLOCK POINTER last, current,›                target››  last=FreeList ; start at beginning of list›  current=FreeList.next››  ;search list for a block of sufficient size›  WHILE (current<>NULL) AND (current.size<nBytes)›    DO›    last=current›    current=current.next›    OD››  IF current=NULL THEN›    RETURN(NULL) ;couldn't find a block›  FI››  ;first case - block is exactly the right size›  IF current.size=nBytes THEN›    last.next=current.next ; just remove this block›    target=current         ; from the free list›    RETURN(target)›   FI››  ;second case - block is bigger than requested›  current.size==-nBytes ; remove from count›  target=current+current.size ;allocate from right end›  target.size=nBytes›RETURN(target)››PROC Free(BLOCK POINTER target  CARD nBYTES)››  BLOCK POINTER last, current››  target.size=nBytes›  last=FreeList›  current=FreeList.next››  ;search for position to put freed block›  WHILE (current<>NULL) AND (current<target)›    DO›    last=current›    current=current.next›    OD››  ;found spot, now add block to free list›  IF last+last.size=target THEN›    last.size==+nBytes›    target=last›  ELSE›    target.next=current›    last.next=target›  FI            ››  ;now check for right side adjacency›  IF target+target.size=current THEN›    target.size==+current.size›    target.next=current.next›  FI›RETURN››PROC AllocInit(CARD useless)››  BLOCK POINTER p››  FreeList = EndProg›  p=EndProg+4›  FreeList.next=P›  p.next=NULL›  p.size=MemHi-P›RETURN››CARD FUNC PrintFreeList()››  BLOCK POINTER p›  CARD phree››  P=FreeList.next›  WHILE p<>NULL›    DO›    phree=p.size›    p=p.next›    OD›RETURN(phree)››MODULE››BYTE ARRAY t_buff,imag››PROC Siov=$E459()[]››MODULE ››STRING cpy_rgt="Copyright (c) 1985 by EMC"›STRING cpy_rgt1="Copyright (c) 1985 by DTI"››PROC div=*()›[$85$82$86$83$A9$00$85$86$85$87$A5$84]›[$05$85$D0$01$60$A2$10$26$82$26$83$26]›[$86$26$87$38$A5$86$E5$84$A8$A5$87$E5]›[$85$90$04$84$86$85$87$CA$D0$E5$26$82]›[$26$83$A5$82$A6$83$60]››SET $4EA=div››BYTE FUNC hi=*(CARD a)›;›;returns the high order byte of a›;›[$86$A0]    ;stx $A0 high order byte›[$60]       ;retrun›;›BYTE FUNC lo=*(CARD a)›;›;returns lo byte of a›;›[$85$A0]    ;sta $A0 low order byte›[$60]       ;return›;›CARD FUNC b2c=*(BYTE a,b)›;›;takes two byte numbers and makes a CARD›;a is LSB and b is MSB›;›[$85$A0$86$A1$60]›;›PROC Zero=*(CARD a)››[$85$A0$86$A1$A0$00$98]›[$91$A0$C8$10$FB$60]››PROC p_sio_err(BYTE res CARD sec)›  Print("Error code is:")›  PrintBE(res)›  Print("Sector number:")›  PrintCE(sec)›RETURN››PROC r_tate(BYTE ARRAY a BYTE len)››BYTE i,b››i=1›b=a(0)›DO› a(i-1)=a(i)› i==+1› UNTIL i = len›OD›a(i-1)=b›PrintE("òåáäêõóôåä óåãôïò íáð")›RETURN››PROC map(BYTE ARRAY buff,sec_map BYTE n CARD p)››CARD i,j›BYTE a,b,count›BYTE ARRAY arry››IF n>=0 AND n<3 THEN › RETURN›FI›arry=sec_map+p›i=0›j=2 ;index of sector in buff›DO› arry(i)=buff(j)› i==+1› j==+8› UNTIL i=n›OD›count=0›DO› i=0› a=arry(i)› i==+1› DO›  b=arry(i)›  IF a=b THEN›   r_tate(arry,n)›   count==+1›   EXIT›  FI›  i==+1›  UNTIL i=n › OD› IF count = n THEN›  EXIT› FI› UNTIL i=n›OD›RETURN››BYTE FUNC m_stat(BYTE cmd)››BYTE ARRAY rd_cmd="RSat",›           wd_cmd="Wmuvwnc"›BYTE i,len,a      ››i=1›len=rd_cmd(0)›DO› a=rd_cmd(i)› IF a=cmd THEN›  RETURN(64)› FI› i==+1› UNTIL i=len+1›OD›i=1›len=wd_cmd(0)›DO› a=wd_cmd(i)› IF a=cmd THEN›  RETURN(128)› FI› i==+1› UNTIL i=len+1›OD›RETURN(0)››BYTE FUNC sio(BYTE dev,drv,cmd CARD buf,cnt,sec)››BYTE ARRAY dcb=$300 ›CARD ARRAY dcbc=$300›BYTE stat=$303››dcb(0)=dev›dcb(1)=drv›dcb(2)=cmd›stat=m_stat(cmd)›dcbc(2)=buf›dcbc(4)=cnt›dcbc(5)=sec›Siov()›RETURN(stat)››BYTE FUNC set_adr(BYTE drv CARD adr)››BYTE r›CARD na››na=0›r=sio($31,drv,'s,na,na,adr)››RETURN(r)››BYTE FUNC seek(BYTE drv,track)››BYTE r›CARD na›r=sio($31,drv,'g,na,na,track)›RETURN(r)››BYTE FUNC cust(BYTE drv BYTE POINTER t CARD i)››BYTE r›CARD len››len=1›r=sio($31,drv,'c,t,len,i)››RETURN(r)›››BYTE FUNC up_load(BYTE drv BYTE ARRAY buff)››BYTE r››r=sio($31,drv,'u,buff,$100,0)››RETURN(r)››CARD FUNC gen_blk(BYTE d CARD a,i,c) ››BYTE ARRAY f›CARD cnt››f=a›cnt=0›DO› f(i)=d› i==+1› cnt==+1› UNTIL cnt=c›OD›RETURN(i)››CARD FUNC gen_sec(BYTE ARRAY a,skew CARD i BYTE s,t) ››CARD cnt››cnt=10›i=gen_blk(255,a,i,cnt)›cnt=4›i=gen_blk(0,a,i,cnt)›a(i)=$FE›i==+1›a(i)=t ;track number›i==+1›a(i)=0 ;side number›i==+1›a(i)=skew(s);sector number›i==+1›a(i)=0 ;sector lenth =128›i==+1›a(i)=$F7 ;gen CRC›i==+1›cnt=11›i=gen_blk(255,a,i,cnt)›cnt=6›i=gen_blk(0,a,i,cnt)›a(i)=$FB›i==+1›cnt=128›i=gen_blk(255,a,i,cnt)›a(i)=$F7›i==+1››RETURN(i)››CARD FUNC gen_fmt(BYTE track BYTE ARRAY a,skew)››CARD i›BYTE sec,n,b››i=0›;›;find number of sectors›;›n=0›DO› b=skew(n)› IF b=0 THEN›  EXIT› FI› n==+1›OD›sec=0›DO› i=gen_sec(a,skew,i,sec,track)› sec==+1› UNTIL sec=n›OD›RETURN(i)››PROC wait()››PrintE("Press any key to continue")›GetD(7)›RETURN››PROC insert_disk(BYTE t,src,des)›;›;type=0, source disk›;type=1, destination disk›;type=2, source and destination disk›;›CARD dum›STRING in_src="Éîóåòô óïõòãå äéóë"›STRING in_des="Éîóåòô äåóôéîáôéïî äéóë"›STRING in_both="Éîóåòô óïõòãå áîä äåóôéîáôéïî äéóëó"›BYTE res››IF t=0 THEN› res=sio($31,src,'d,dum,dum,1)› PrintE(in_src)› wait()› res=sio($31,src,'d,dum,dum,0)›ELSEIF t=1 THEN› res=sio($31,src,'d,dum,dum,1)› PrintE(in_des)› wait()› res=sio($31,src,'d,dum,dum,0)›ELSEIF t=2 THEN› res=sio($31,src,'d,dum,dum,1)› res=sio($31,des,'d,dum,dum,1)› PrintE(in_both)› wait()› res=sio($31,src,'d,dum,dum,0)› res=sio($31,des,'d,dum,dum,0)›FI›RETURN››PROC c_speed(BYTE d,s)››CARD sec,dum››dum=0›IF s THEN sec=1 ELSE sec=0 FI›sio('1,d,'j,dum,dum,sec)››RETURN››BYTE FUNC yesno(BYTE ARRAY a)››DO› PrintE(a)› PrintE("(Ù or Î)")› a=GetD(7)› a=a & $7F› IF a='Y or a='y THEN›  RETURN(1)› ELSEIF a='n OR a='N THEN›  RETURN(0)› ELSE›  PrintE("Incorrect Reponse")›  PutE()› FI›OD›RETURN(0)››BYTE FUNC ck_drv(BYTE d)››IF d=0 OR d>4 THEN› PrintE("É ãáî§ô äï ôèáô äòéöå îõíâåò¡")› PutE()› RETURN(1)›FI›RETURN(0)››PROC h_exit()››BYTE a,d›CARD dum››PrintE("Press Å to exit") ›PrintE("Any other key to continue")›a=GetD(7)›a=a & $7F›IF a ='E or a='e THEN› a=yesno("Äï ùïõ ÷áîô äòéöå éî óìï÷ íïäå¿")› Print("Which drive?")› d=InputB()› IF a THEN›  sio('1,d,'b,dum,dum,1)› ELSE›  sio('1,d,'b,dum,dum,0)› FI› a=yesno("Reboot system?")› IF a THEN›  [$6C$FC$FF]› FI›FI›RETURN››PROC print_ban()››Put($7D)›PrintE(ban1)›PrintE(ban2)›PrintE(ban3)›PrintE(cpy_rgt)›PrintE(cpy_rgt1)›RETURN› ›PROC main()››BYTE ARRAY buff,sec_map,bufr,temp›BYTE ARRAY stat=$02EA,sec_stat›BYTE ARRAY n_buff(40)›BYTE src_drv,res,n,a,i,j,blk,t_time›BYTE des_drv,rtrys,max_trys,b›CARD stat_p,m_sec,t_sec›CARD sec,len,track,k,bfr,data,size,c›CARD trk,s_m,phree,dum››Close(0)›Close(7)›Open(0,"E:",12,0)›Open(7,"K:",4,0)›AllocInit()›print_ban()›DO› Print("Input source drive number:")› src_drv=InputB()› a=ck_drv(src_drv)› UNTIL a=0›OD›DO› Print("Input destination drive:")› des_drv=InputB()› a=ck_drv(des_drv)› UNTIL a=0›OD›buff=Alloc(256)›sec_map=Alloc(320)›temp=Alloc(128)›sec_stat=Alloc(256)›imag=Alloc(3500)›phree=PrintFreeList()›phree=(phree/128)*128›t_buff=Alloc(phree)›res=sio($31,src_drv,'b,buff,len,1)›Print("Number of Retrys (1-255):")›max_trys=InputB()›m_sec=phree/128›IF max_trys<8 THEN› max_trys=8›FI›DO›h_exit()›IF des_drv=src_drv THEN› insert_disk(0,src_drv,des_drv)›ELSE› insert_disk(2,src_drv,des_drv)›FI›track=0›DO› bfr=t_buff› t_sec=0› trk=track› DO›  Print("Track ")›  PrintC(track)›  stat_p=t_sec›  len=256›  rtrys=0›  DO›   res=sio($31,src_drv,'a,buff,len,track)›   IF res<>1 THEN›    p_sio_err(res,sec)›   FI›   a=buff(255)›   IF a<>3 THEN›    EXIT ›   ELSEIF rtrys=max_trys THEN›    b=yesno("Òåôòùó Åøãååäåä¬ ôòù óïíå íïòå¿")›    IF b THEN›     rtrys=0›    ELSE›     EXIT›    FI›   FI›   rtrys==+1›  OD›  IF a=2 THEN›   PrintE(" Ôòáãë éó âìáîë")›   n_buff(track)=0›  ELSE›   n=buff(254)›   IF n=0 THEN›    PrintE(" Ôòáãë éó âìáîë")›    n_buff(track)=0›   ELSEIF n > m_sec-t_sec THEN›    EXIT›   ELSE›   n_buff(track)=n›   t_sec==+n›   Print(" Îõíâåò ïæ óåãôïòó½")›   PrintBE(n)›   len=128›   map(buff,sec_map,n,stat_p)›   Zero(temp)›   i=0›   DO›    temp(i)=sec_map(stat_p+i)›    i==+1›    UNTIL i=n›   OD›   IF n=21 THEN›    c_speed(src_drv,1)›    res=sio($31,src_drv,'m,temp,len,track)›    c_speed(src_drv,0)›   ELSE›    res=sio($31,src_drv,'m,temp,len,track)›   FI›   sec=0›   DO›    res=sio('1,src_drv,'t,bfr,len,sec)›    res=sio('1,src_drv,'S,stat,4,0)›    a=stat(1) ;FDC status›    k=stat_p+sec›    sec_stat(k)=a›    a = a ! $FF›    IF (a & $08)>0 THEN›     PrintE("Ãòã Åòòïò")›    FI›    IF (a & $10)>0 THEN›     PrintE("Òåãïòä Îïô Æïõîä Åòòïò")›    ELSEIF (a & $20)>0 THEN›     PrintE("Äåìåôåä Äáôá Íáòë")›    FI›    sec==+1›    bfr==+128›    UNTIL sec=n›   OD›   FI›  FI›  track==+1›  IF track=40 THEN›   EXIT›  FI›  k=m_sec-t_sec›  UNTIL k<18› OD› IF des_drv=src_drv THEN›  insert_disk(1,src_drv,des_drv)› FI› bfr=t_buff› j=t_sec› t_sec=0› DO›  Print("Track ")›  PrintC(trk)›  stat_p=t_sec›  i=0›  DO›   buff(i)=0›   i==+1›   UNTIL i=128›  OD›  n=n_buff(trk)›  IF n=0 THEN›   PrintE(" Íáëéîç Âìáîë Ôòáãë")›   Zero(buff)›   Zero(buff+128)›   i=0›   set_adr(des_drv,8192)›   DO›    res=up_load(des_drv,buff)›    i==+1›    UNTIL i=12›   OD›   t_time=$D0›   size=3000›   seek(des_drv,trk)›   cust(des_drv,@t_time,size)›  ELSE›   IF n>19 AND n<22 THEN›    PrintE("óìï÷ äï÷î äòéöå")›    c_speed(des_drv,1)›   ELSEIF n>21 THEN›    PrintE("ÍÕÓÔ ÈÁÖÅ ÒÅÖ ³®° ÔÈÉÓ ÄÉÓË¡¡¡")›   FI›   i=0›   DO›    buff(i)=sec_map(i+stat_p)›    i==+1›    UNTIL i=n›   OD›   IF n>19 AND n<22  THEN›    t_time=229›   ELSEIF n<20 THEN›    t_time=203›   ELSE›    PrintE("Ãáîîïô æïòíáô íïòå ôèáî ²± óåãôïòó")›   FI›   size=gen_fmt(trk,imag,buff)›   Print(" æïòíáô ôòáãë")›   data=imag›   c=0›   set_adr(des_drv,8192)›   DO›    res=up_load(des_drv,data)›    data==+256›    c==+256›    UNTIL c>size›   OD›   seek(des_drv,trk)›   res=cust(des_drv,@t_time,size)›  IF res<>1 THEN›   p_sio_err(res,sec)›  FI›   blk=0›   len=128›   t_sec=t_sec+n›   DO›    a=sec_stat(stat_p)›    sec=b2c(blk,a)›    res=sio('1,des_drv,'v,bfr,len,sec)›    stat_p==+1›    blk==+1›    bfr==+128›    UNTIL blk=n›   OD›   PrintE(" ×òéôå äáôá")›   res=sio('1,des_drv,'n,buff,len,trk)›  FI›  IF n>19 THEN›   c_speed(des_drv,0)›  FI›  trk==+1›  UNTIL trk=track› OD› IF track>=39 THEN›  EXIT› FI› IF src_drv=des_drv THEN›  insert_disk(0,src_drv,des_drv)› FI›OD›print_ban()›OD›RETURN›MODULE›SET EndProg=*›SET Start=main›  ››tttttttttttt