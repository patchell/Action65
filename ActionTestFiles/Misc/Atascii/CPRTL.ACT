;**********************************›;›; SECTOR Copy Program RUN TIME LIB›;›;**********************************›;›MODULE›DEFINE STRING="CHAR ARRAY"›DEFINE EOL="$9B"›DEFINE OpenBuf =  "$0500"›DEFINE OpenBufL = "$00"›DEFINE OpenBufH = "$05"››STRING copy_right(0) =›    "(c)1983 Action Computer Services"››; Primitive IO routines›PROC Clos=*(BYTE d)[$FFA2$A686$CA0$AD0]››PROC Output=*(BYTE d, STRING s)›[$A684$BA0$4D0]› ›PROC In=*(BYTE d, STRING s)›[$A684$5A0$A586$A2$0$A386]››PROC XIOstr=*(BYTE d,x,c,a1,a2,STRING s)›[$A0A$A0A$98AA$9D$342$A3A5$AF0$9D$34A$A4A5$9D$34B$A9$0$9DA8$349›$A5B1$9D$348$12F0$18$A5A5$169$9D$344$A6A5$69$0$9D$345$4C$E456$60]››PROC Opn=*(BYTE d,STRING s,BYTE m,o)›[$A586$A684$3A0$4CXIOstr]››PROC Prt=*(BYTE d,STRING s)›[$A586$A684$A2$0$A386$9A0$20XIOstr$AD0$BA9$9D$342$9BA9$4C$E456$60]››PROC Error(BYTE err)[$6C$A$0$1113$8301]››PROC Break=*()›[$BA$8E$4C1$80A0$98$4C Error]›››; math library routines›PROC LShift=*()›[$84A4$AF0$8586$A$8526$88$FAD0$85A6$60]››PROC RShift=*()›[$84A4$AF0$8586$8546$6A$88$FAD0$85A6$60]››PROC SetSign=*()[$D3A4$1010]›PROC SS1=*()›[$8685$8786$38$A9$0$86E5$A8$A9$0$87E5$AA$98$60]››PROC SMOps=*()›[$D386$E0$0$310$20SS1$8285$8386$85A5$E10$AA$D345$D385›$84A5$20SS1$8485$8586$A9$0$8785$60]››PROC MultB=*()›[$1BF0$CA$C786$AA$15F0$C686$A9$0$8A2$A$C606$290$C765$CA$F6D0›$18$8765$8785$86A5$87A6$60]››PROC MultI=*()›[$20SMOps$82A6$1BF0$C686$84A6$15F0$CA$C786›$8A2$A$8726$C606$690$C765$290$87E6$CA$F0D0›$8685$82A5$85A6$20MultB$83A5$84A6$20MultB$4CSetSign]››PROC DivI=*()›[$20SMOps$85A5$27F0›$8A2$8226$8326$8726$38$83A5$84E5$A8$87A5$85E5$490›$8785$8384$CA$E7D0$82A5$2A$A2$0$83A4$8684$4CSetSign›$10A2$8226$8326$2A$4B0$84C5$390$84E5$38$CA$EFD0›$8226$8326$8685$82A5$83A6$4CSetSign]››PROC RemI=*()[$20 DivI$86A5$87A6$60]›››PROC SArgs=*()›[$A085$A186$A284$18$68$8485$369$A8$68$8585$69$0$48$98$48$1A0›$84B1$8285$C8$84B1$8385$C8$84B1›$A8$B9$A0$0$8291$88$F810$11A5$FD0$11E6$4C Break$6308$1109$1819$2113$3323$60]››SET $4E4=LShift›SET $4E6=RShift›SET $4E8=MultI›SET $4EA=DivI›SET $4EC=RemI›SET $4EE=SArgs›››PROC ChkErr=*(BYTE r,b,eC)[$1610$88C0$8F0›$98$80C0$11F0›$4C Error$8A$4A4A$4A4A$98AA$9D EOF$60]››PROC Break1=*(BYTE err)›[$1A2$1186$48$20 Break$68$A8$60]››PROC Open=*(BYTE d,STRING f,BYTE m,a2)›[$48$A186$A284$A8$A9$0$99 EOF$A8$A1B1$8D OpenBuf $A8$C8$9BA9$2D0$A1B1$99 OpenBuf $88$F8D0›$68$A2 OpenBufL $A0 OpenBufH $20Opn$4C ChkErr]››PROC PrintE=*(STRING s)[$A186$AA$A1A4$A5device]›PROC PrintDE=*(BYTE d,STRING s)›[$20 Prt$4C ChkErr]››PROC Close=*(BYTE d)[$20 Clos$4C ChkErr]››PROC Print=*(STRING s)[$A186$AA$A1A4$A5device]›PROC PrintD=*(BYTE d,STRING s)›[$20Output$4C ChkErr]››PROC InS=*()›[$20In$A084$BD$348$3F0$38$1E9$A0$0$A591$A0A4$60]››PROC InputS=*(STRING s)[$A286$AA$A2A4$A5device]›PROC InputSD=*(BYTE d,STRING s)[$48$FFA9$A385$68]›PROC InputMD=*(BYTE d,STRING s,BYTE m)›[$48$A186$A284$A0$0$A3A5$A191$68$A2A4]›PROC InputD=*(BYTE d,STRING s)[$20InS$4C ChkErr]››CHAR FUNC GetD=*(BYTE d)[$7A2]›PROC CCIO=*()›[$A486$A0A$A0A$AA$A4A5$9D$342$A9$0$9D$348$9D$349›$98$20$E456$A085$4C ChkErr]››PROC PutE=*()[$A9$9B]›PROC Put=*(CHAR c)[$AA$A5device]›PROC PutD=*(BYTE d,CHAR c)[$A186$A1A4]›PROC PutD1=*()[$BA2$4C CCIO]››PROC PutDE=*(BYTE dev)[$A0$9B$F7D0]››PROC XIO=*(BYTE d,f,c,a1,a2,STRING s)›[$20XIOstr$4C ChkErr]››PROC CToStr=*()›[$D485$D586$20$D9AA$20$D8E6$FFA0$A2$0$C8$E8›$F3B1$9D$550$F710$8049$9D$550$8E$550$60]››PROC PrintB=*(BYTE n)[$A2$0]›PROC PrintC=*(CARD n)[$20 CToStr$A5device]›PROC PNum=*()[$50A2$5A0$20 Output$4C ChkErr]››PROC PrintBE=*(BYTE n)[$A2$0]›PROC PrintCE=*(CARD n)[$20PrintC$4CPutE]››PROC PrintBD=*(BYTE d, n)[$A0$0]›PROC PrintCD=*(BYTE d, CARD n)›[$A085$8A$A284$A2A6$20 CToStr$A0A5$4CPNum]››PROC PrintBDE=*(BYTE n)[$A0$0]›PROC PrintCDE=*(BYTE d,CARD n)›[$20PrintCD$A0A5$4CPutDE]››PROC PrintI=*(INT n)[$A286$AA$A2A4$A5device]›PROC PrintID=*(BYTE d,INT n)[$C0$0$1610$48$A186$A284$2DA0›$20PutD1$38$A9$0$A1E5$AA$A9$0$A2E5$A8$68$4CPrintCD]››PROC PrintIE=*(INT n)[$20PrintI$4CPutE]››PROC PrintIDE=*(BYTE d,INT n)›[$20PrintID$A0A5$4CPutDE]››PROC StrB=*(BYTE n, STRING s)[$A286$A384$A2$0$A2A4]›PROC StrC=*(CARD n, STRING s)[$A284$20 CToStr$C8$B9$550$A291$88$F810$60]›PROC StrI=*(INT n, STRING s)[$E0$0$ED10$A085$A186$A284›$38$A9$0$A0E5$A8$A9$0$A1E5$AA$98$20 CToStr$E8$8A›$A8$B9$54F$A291$88$F8D0$8A$A291$C8$2DA9$A291$60]››BYTE FUNC InputB=*()›CARD FUNC InputC=*()›INT FUNC InputI=*()›[$A5 device]›BYTE FUNC InputBD=*(BYTE d)›CARD FUNC InputCD=*(BYTE d)›INT FUNC InputID=*(BYTE d)›[$13A2$8E$550$50A2$5A0$20InputD$50A9$5A2]›BYTE FUNC ValB=*(STRING s)›CARD FUNC ValC=*(STRING s)›INT FUNC ValI=*(STRING s)›[$A485$A586$A0$0$A084$A184$A284$A4B1$A385$A3E6›$20A9$C8$A4D1$5D0$C8$A3C4$F730$A4B1$2DC9$3D0$A285$C8$A3C4$3610›$A4B1$30C9$3030$3AC9$2C10$38$30E9$AA›$A1A5$48$A0A5$A$A126$A$A126$18$A065$A085$68$A165$A185$A006$A126›$18$8A$A065$A085$290$A1E6$C8$A3C4$CA30›$A2A5$DF0$38$A9$0$A0E5$A085$A9$0$A1E5$A185$60]›MODULE››DEFINE NULL="0"››TYPE BLOCK=[CARD size,next]››CARD MemLo=$2E7, MemHi=$2E5››BLOCK POINTER FreeList››CARD FUNC Alloc(CARD nBytes)››  BLOCK POINTER last, current,›                target››  last=FreeList ; start at beginning of list›  current=FreeList.next››  ;search list for a block of sufficient size›  WHILE (current<>NULL) AND (current.size<nBytes)›    DO›    last=current›    current=current.next›    OD››  IF current=NULL THEN›    RETURN(NULL) ;couldn't find a block›  FI››  ;first case - block is exactly the right size›  IF current.size=nBytes THEN›    last.next=current.next ; just remove this block›    target=current         ; from the free list›    RETURN(target)›   FI››  ;second case - block is bigger than requested›  current.size==-nBytes ; remove from count›  target=current+current.size ;allocate from right end›  target.size=nBytes›RETURN(target)››PROC Free(BLOCK POINTER target  CARD nBYTES)››  BLOCK POINTER last, current››  target.size=nBytes›  last=FreeList›  current=FreeList.next››  ;search for position to put freed block›  WHILE (current<>NULL) AND (current<target)›    DO›    last=current›    current=current.next›    OD››  ;found spot, now add block to free list›  IF last+last.size=target THEN›    last.size==+nBytes›    target=last›  ELSE›    target.next=current›    last.next=target›  FI            ››  ;now check for right side adjacency›  IF target+target.size=current THEN›    target.size==+current.size›    target.next=current.next›  FI›RETURN››PROC AllocInit(CARD useless)››  BLOCK POINTER p››  FreeList = EndProg›  p=EndProg+4›  FreeList.next=P›  p.next=NULL›  p.size=MemHi-P›RETURN››CARD FUNC PrintFreeList()››  BLOCK POINTER p›  CARD phree››  P=FreeList.next›  WHILE p<>NULL›    DO›    phree=p.size›    p=p.next›    OD›RETURN(phree)››PROC Siov=$E459()[]››MODULE ››STRING cpy_rgt="Copyright (c) 1985 by EMC"›STRING cpy_rgt1="Copyright (c) 1985 by DTI"››PROC div=*()›[$85$82$86$83$A9$00$85$86$85$87$A5$84]›[$05$85$D0$01$60$A2$10$26$82$26$83$26]›[$86$26$87$38$A5$86$E5$84$A8$A5$87$E5]›[$85$90$04$84$86$85$87$CA$D0$E5$26$82]›[$26$83$A5$82$A6$83$60]››SET $4EA=div››BYTE FUNC hi=*(CARD a)›;›;returns the high order byte of a›;›[$86$A0]    ;stx $A0 high order byte›[$60]       ;retrun›;›BYTE FUNC lo=*(CARD a)›;›;returns lo byte of a›;›[$85$A0]    ;sta $A0 low order byte›[$60]       ;return›;›CARD FUNC b2c=*(BYTE a,b)›;›;takes two byte numbers and makes a CARD›;a is LSB and b is MSB›;›[$85$A0$86$A1$60]›;›PROC Zero=*(CARD a)››[$85$A0$86$A1$A0$00$98]›[$91$A0$C8$10$FB$60]››PROC p_sio_err(BYTE res CARD sec)›  Print("Error code is:")›  PrintBE(res)›  Print("Sector number:")›  PrintCE(sec)›RETURN››BYTE FUNC m_stat(BYTE cmd)››BYTE ARRAY rd_cmd="RSat",›           wd_cmd="PWmuvwnc"›BYTE i,len,a      ››i=1›len=rd_cmd(0)›DO› a=rd_cmd(i)› IF a=cmd THEN›  RETURN(64)› FI› IF cmd = '" THEN›  RETURN(64)› FI› i==+1› UNTIL i=len+1›OD›i=1›len=wd_cmd(0)›DO› a=wd_cmd(i)› IF a=cmd THEN›  RETURN(128)› FI› i==+1› UNTIL i=len+1›OD›RETURN(0)››BYTE FUNC sio(BYTE dev,drv,cmd CARD buf,cnt,sec)››BYTE ARRAY dcb=$300 ›CARD ARRAY dcbc=$300›BYTE stat=$303››IF cmd = '" THEN› dcbc(3) = $FF›ELSE› dcbc(3) = $2F›FI›dcb(0)=dev›dcb(1)=drv›dcb(2)=cmd›stat=m_stat(cmd)›dcbc(2)=buf›dcbc(4)=cnt›dcbc(5)=sec›Siov()›RETURN(stat)››PROC wait()››PrintE("Press any key to continue")›GetD(7)›RETURN››PROC insert_disk(BYTE t,src,des)›;›;type=0, source disk›;type=1, destination disk›;type=2, source and destination disk›;›STRING in_src="Éîóåòô óïõòãå äéóë"›STRING in_des="Éîóåòô äåóôéîáôéïî äéóë"›STRING in_both="Éîóåòô óïõòãå áîä äåóôéîáôéïî äéóëó"›BYTE res››IF t=0 THEN› PrintE(in_src)› wait()›ELSEIF t=1 THEN› PrintE(in_des)› wait()›ELSEIF t=2 THEN› PrintE(in_both)› wait()›FI›RETURN››BYTE FUNC yesno(BYTE ARRAY a)››DO› PrintE(a)› PrintE("(Ù or Î)")› a=GetD(7)› a=a & $7F› IF a='Y or a='y THEN›  RETURN(1)› ELSEIF a='n OR a='N THEN›  RETURN(0)› ELSE›  PrintE("Incorrect Reponse")›  PutE()› FI›OD›RETURN(0)››BYTE FUNC ck_drv(BYTE d)››IF d=0 OR d>4 THEN› PrintE("É ãáî§ô äï ôèáô äòéöå îõíâåò¡")› PutE()› RETURN(1)›FI›RETURN(0)››PROC print_ban()››Put($7D)›PrintE(ban1)›PrintE(ban2)›PrintE(ban3)›PrintE(cpy_rgt)›PrintE(cpy_rgt1)›RETURN› ›MODULE›